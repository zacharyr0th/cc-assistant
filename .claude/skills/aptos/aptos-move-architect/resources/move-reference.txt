# Smart Contracts

> Learn to write secure, efficient smart contracts on Aptos using the Move programming language with examples, tutorials, and developer resources

import { CardGrid, LinkCard } from '@astrojs/starlight/components';

import { RemoteCodeblock } from '~/components/RemoteCodeblock';

Aptos contracts are written using Move, a next generation language for secure, sandboxed, and formally verified programming which is used for multiple chains.
Move allows developers to write programs that flexibly manage and transfer assets while providing security and protections against attacks on those assets.

## üìñ Learn Move

<CardGrid>
  <LinkCard href="/build/smart-contracts/why-move" title="Why Move?" description="Learn why Aptos uses the Move Language" />

  <LinkCard href="/build/smart-contracts/create-package" title="Create Package" description="Get started by learning how to create a Move package" />

  <LinkCard href="/build/smart-contracts/objects" title="Objects" description="Learn how to use the Object standard on Aptos to create composable and flexible primitives on chain" />
</CardGrid>

## üë®‚Äçüíª Move Examples

<CardGrid>
  <LinkCard href="https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples" title="Aptos Move Examples" description="30+ examples on how to develop Move on Aptos" target="_blank" />

  <LinkCard href="https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/move-tutorial" title="Move Tutorial" description="Covers the basics of programming with Move" target="_blank" />

  <LinkCard href="/build/guides/first-move-module" title="Your first Move Module" description="A  example of how to publish your first move module" />
</CardGrid>

Here is a `hello_blockchain` example of move

<RemoteCodeblock permalink="https://github.com/aptos-labs/aptos-core/blob/77e1d222ebc5e7294e115e0d090c001da1d0e072/aptos-move/move-examples/hello_blockchain/sources/hello_blockchain.move#L1-L59" />

## ‚öíÔ∏è Developer Resources

### FAQ and Discussions

- [Aptos Dev Discussions](https://github.com/aptos-labs/aptos-developer-discussions/discussions) for Q\&A about Move.

### Move IDE plugins

- Move on Aptos extension for [VSCode](https://marketplace.visualstudio.com/items?itemName=AptosLabs.move-on-aptos) and [OpenVSX](https://open-vsx.org/extension/aptoslabs/move-on-aptos).
- [Move language plugin for JetBrains IDEs](https://plugins.jetbrains.com/plugin/14721-move-language)

### External Resources

- [Aptos Move by Example](https://move-developers-dao.gitbook.io/aptos-move-by-example)
- [Teach yourself Move on Aptos](https://github.com/econia-labs/teach-yourself-move).
- [Formal Verification, the Move Language, and the Move Prover](https://www.certik.com/resources/blog/2wSOZ3mC55AB6CYol6Q2rP-formal-verification-the-move-language-and-the-move-prover)
- [Pontem Move Playground](https://playground.pontem.network/)
- [Collection of nestable Move resources](https://github.com/taoheorg/taohe)

We have a new Move on Aptos compiler that supports Move 2. See [this page](/build/smart-contracts/compiler_v2) for more information.

# Aptos Coin Standard (Legacy)

> Learn about aptos coin for Move smart contract development on Aptos blockchain.

import { Aside } from '@astrojs/starlight/components';

[Coin](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move)
provides a standard, type-safe framework for simple, fungible tokens or coins.

<Aside type="note">
  Coin is stored in `0x1::coin`.
</Aside>

## Structures

### Reusability

A coin is defined in Move as:

```move
module 0x1::coin {
  struct Coin<phantom CoinType> has store {
    /// Amount of coin this address has.
    value: u64,
  }
}
```

A Coin uses the `CoinType` to support re-usability of the Coin framework for
distinct Coins. For example, `Coin<A>` and `Coin<B>` are two distinct coins.

### Global store

Coin also supports a resource for storing coins in global store:

```move
module 0x1::coin {
  struct CoinStore<phantom CoinType> has key {
    coin: Coin<CoinType>,
    frozen: bool,
    deposit_events: EventHandle<DepositEvent>,
    withdraw_events: EventHandle<WithdrawEvent>,
  }
}
```

Coin information or metadata is stored in global store under the coin creators
account:

```move
module 0x1::coin {
  struct CoinInfo<phantom CoinType> has key {
    name: string::String,
    /// Symbol of the coin, usually a shorter version of the name.
    /// For example, Singapore Dollar is SGD.
    symbol: string::String,
    /// Number of decimals used to get its user representation.
    /// For example, if `decimals` equals `2`, a balance of `505` coins should
    /// be displayed to a user as `5.05` (`505 / 10 ** 2`).
    decimals: u8,
    /// Amount of this coin type in existence.
    supply: Option<OptionalAggregator>,
  }
}
```

## Primitives

Coin provides the primitives for users creating and managing the coin and the
users who use it.

### Creators

Coin creators and managers can:

- Initialize a coin and set its metadata and supply monitoring.
- Minting and burning Coin value.
- Burning coins from a `CoinStore`.
- Freezing mobility into and out of a `CoinStore`.

### Users

Coin users can:

- Merging two Coin structs of the same type.
- Extracting value from a Coin struct into a new Coin struct.
- Ability to deposit and withdraw from a `CoinStore` and emit events as a result.
- Allows for users to register a `CoinStore<CoinType>` in their account to
  handle coin.

### Coin module key struct

The following tables describe fields at the struct level. For the definitive list,
see the [Aptos Framework](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/overview.md)
containing [`coin`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/coin.md).

##### [`Coin`](https://github.com/aptos-labs/aptos-core/blob/744c2def47cddced878fda9bbd5633022fdb083a/aptos-move/framework/aptos-framework/sources/coin.move#L68)

| Field   | Type | Description                        |
| ------- | ---- | ---------------------------------- |
| `value` | u64  | Value of the token, eg: 1000000000 |

##### [`CoinInfo`](https://github.com/aptos-labs/aptos-core/blob/744c2def47cddced878fda9bbd5633022fdb083a/aptos-move/framework/aptos-framework/sources/coin.move#L92)

| Field      | Type                        | Description                                                                                                                      |
| ---------- | --------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| `name`     | String                      | Name of the token, eg: Aptos Coin                                                                                                |
| `symbol`   | String                      | Symbol for the token, eg: APT                                                                                                    |
| `decimals` | u8                          | Determines how the value of coin is represented; for example APT‚Äôs decimal is 8, so a value of 100000000 is represented by 1 APT |
| `supply`   | Option\<OptionalAggregator> | option::some(optional\_aggregator::new(MAX\_U128, parallelizable))                                                               |

### Creating a new CoinType

A coin creator can publish to an on-chain account a new module that defines a
struct to represent a new `CoinType`. The coin creator will then call
`coin:initialize<CoinType>` from that account to register this as a valid coin,
and in return receive back structs that enable calling the functions to burn and
mint coins and freeze `CoinStore`s. These will need to be stored in global
storage by the creator to manage the use of the coin.

```move
module 0x1::coin {
  public fun initialize<CoinType>(
    account: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool,
  ): (BurnCapability<CoinType>, FreezeCapability<CoinType>, MintCapability<CoinType>) {
    // ...
  }
}
```

The creator has the opportunity to define a name, symbol, decimals, and whether
the total supply for the coin is monitored. The following applies:

- The first three of the above (`name`, `symbol`, `decimals`) are purely
  metadata and have no impact for on-chain applications. Some applications may use
  decimal to equate a single Coin from fractional coin.
- Monitoring supply (`monitor_supply`) helps track total coins in supply.
  However, due to the way the parallel executor works, turning on this option will
  prevent any parallel execution of mint and burn. If the coin will be regularly
  minted or burned, consider disabling `monitor_supply`.

### Minting Coins

If the creator or manager would like to mint coins, they must retrieve a
reference to their `MintCapability`, which was produced in the `initialize`,
and call:

```move
module 0x1::coin {
  public fun mint<CoinType>(
    amount: u64,
    _cap: &MintCapability<CoinType>,
  ): Coin<CoinType> acquires CoinInfo {
    // ...
  }
}
```

This will produce a new Coin struct containing a value as dictated by the
`amount`. If supply is tracked, then it will also be adjusted.

### Burning Coins

If the creator or manager would like to burn coins, they must retrieve a
reference to their `BurnCapability`, which was produced in the `initialize`, and
call:

```move
module 0x1::coin {
  public fun burn<CoinType>(
    coin: Coin<CoinType>,
    _cap: &BurnCapability<CoinType>,
  ) acquires CoinInfo {
    // ...
  }
}
```

The creator or manager can also burn coins from a `CoinStore`:

```move
module 0x1::coin {
  public fun burn_from<CoinType>(
    account_addr: address,
    amount: u64,
    burn_cap: &BurnCapability<CoinType>,
  ) acquires CoinInfo, CoinStore {
   // ...
  }
}
```

<Aside type="note">
  ### burn vs burn\_from

  The function `burn` eliminates the total value stored in the coin, while
  `burn_from` only eliminates a given amount of value from a `CoinStore`. If
  supply is tracked, then it will also be adjusted.

  Burning coins from an account does not emit a `WithdrawEvent` as the
  `withdraw`
  function does.
</Aside>

### Freezing Accounts

If the creator or manager would like to freeze a `CoinStore` on a specific
account, they must retrieve a reference to their `FreezeCapability`, which was
produced in `initialize`, and call:

```move
module 0x1::coin {
  public entry fun freeze_coin_store<CoinType>(
    account_addr: address,
    _freeze_cap: &FreezeCapability<CoinType>,
  ) acquires CoinStore {
    // ...
  }
}
```

### Merging Coins

Two coins of the same type can be merged into a single Coin struct that
represents the accumulated value of the two coins independently by calling:

```move
module 0x1::coin {
  public fun merge<CoinType>(
    dst_coin: &mut Coin<CoinType>,
    source_coin: Coin<CoinType>,
  ) {
    // ...
  }
}
```

### Extracting Coins

A Coin can have value deducted to create another Coin by calling:

```move
module 0x1::coin {
  public fun extract<CoinType>(
		coin: &mut Coin<CoinType>,
		amount: u64,
  ): Coin<CoinType> {
    // ...
  }
}
```

### Withdrawing Coins from CoinStore

A holder of a `CoinStore` can extract a Coin of a specified value by calling:

```move
module 0x1::coin {
  public fun withdraw<CoinType>(
    account: &signer,
    amount: u64,
  ): Coin<CoinType> acquires CoinStore {
    // ...
  }
}
```

<Aside type="note">
  This function will emit a `WithdrawEvent`.
</Aside>

### Depositing Coins into CoinStore

Any entity can deposit coins into an account‚Äôs `CoinStore` by calling:

```move
module 0x1::coin {
  public fun deposit<CoinType>(
		account_addr: address,
		coin: Coin<CoinType>,
  ) acquires CoinStore {
    // ...
  }
}
```

<Aside type="note">
  This function will emit a `DepositEvent`.
</Aside>

### Transferring Coins

A holder of a `CoinStore` can directly transfer coins from their account to
another account‚Äôs `CoinStore` by calling:

```move
module 0x1::coin {
  public entry fun transfer<CoinType>(
    from: &signer,
    to: address,
    amount: u64,
  ) acquires CoinStore {
    // ...
  }
}
```

<Aside type="note">
  This will emit both a `WithdrawEvent` and `DepositEvent` on the respective
  `CoinStore`s.
</Aside>

## Events

```move
module 0x1::coin {
  struct DepositEvent has drop, store {
    amount: u64,
  }
}
```

```move
module 0x1::coin {
  struct WithdrawEvent has drop, store {
    amount: u64,
  }
}
```

# Aptos Standards

> Learn about aptos standards for Move smart contract development on Aptos blockchain.

Standards define a common interoperable interface for all developers to build
upon. They consist of rules to ensure compatibility across applications and
wallets on the Aptos blockchain. See a [list of known coin resource addresses](https://github.com/hippospace/aptos-coin-list)
on Aptos provided by hippospace.

## Move Standards

### [Aptos Object](/build/smart-contracts/objects)

The [Object model](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/object.move)
allows Move to represent a complex type as a set of resources stored within a
single address and offers a rich capability model that allows for fine-grained
resource control and ownership management.

## Asset Standards

### [Digital Asset (DA)](/build/smart-contracts/digital-asset)

The new [Aptos Digital Asset Standard](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/token.move)
allows:

- Rich, flexible assets and collectibles.
- Easy enhancement of base functionality to provide richer custom
  functionalities. An example of this is the [aptos\_token module](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/aptos_token.move)

Digital Asset (DA) is recommended for any new collections or protocols that want
to build NFT or semi-fungible tokens.

### [Fungible Asset (FA)](/build/smart-contracts/fungible-asset)

The new [Aptos Fungible Asset Standard](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/fungible_asset.move)
is a standard meant for simple, type-safe, and fungible assets based on object
model intending to replace Aptos coin. Fungible Asset (FA) offers more features
and flexibility to Aptos move developers on creating and managing fungible assets.

## Legacy Standards

### [Aptos Token](/build/smart-contracts/aptos-token)

The old
existing [Token module](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/sources/token.move),
on the other hand:

- Encapsulates rich, flexible assets and collectibles. These assets are discrete
  (non-decimal) and can be fungible, semi-fungible, or non-fungible.
- The token standard is in its own `AptosToken` package at the Address `0x3` to
  allow for rapid iteration based on feedback from the community.

### [Aptos Coin](/build/smart-contracts/aptos-coin)

The [Coin module](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move)
is a lightweight standard meant for simple, type-safe, and fungible assets. The
coin standard is separated out into its own Move module to ensure that:

- Applications and users can create and use simple tokens, with high performance
  and low gas overhead.
- The Coin standard is part of the Aptos core framework, so it can be used for
  currencies, including the gas currency.

# Aptos Token Standard (Legacy)

> Learn about aptos token for Move smart contract development on Aptos blockchain.

import { ThemedImage } from '~/components/ThemedImage';

import { Aside } from '@astrojs/starlight/components';

## Overview of NFT

An [NFT](https://en.wikipedia.org/wiki/Non-fungible_token) is a non-fungible [token](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/sources/token.move) or data stored on a blockchain that
uniquely defines ownership of an asset. NFTs were first defined in [EIP-721](https://eips.ethereum.org/EIPS/eip-721)
and later expanded upon in [EIP-1155](https://eips.ethereum.org/EIPS/eip-1155).
NFTs are typically defined using the following properties:

- `name`: The name of the asset. It must be unique within a collection.
- `description`: The description of the asset.
- `uri`: A URL pointer to off-chain for more information about the asset. The
  asset could be media such as an image or video or more metadata.
- `supply`: The total number of units of this NFT. Many NFTs have only a single
  supply, while those that have more than one are referred to as editions.

Additionally, most NFTs are part of a collection or a set of NFTs with a common
attribute, for example, a theme, creator, or minimally contract. Each collection
has a similar set of attributes:

- `name`: The name of the collection. The name must be unique within the
  creator's account.
- `description`: The description of the collection.
- `uri`: A URL pointer to off-chain for more information about the asset. The
  asset could be media such as an image or video or more metadata.
- `supply`: The total number of NFTs in this collection.
- `maximum`: The maximum number of NFTs that this collection can have. If
  `maximum` is set to 0, then supply is not tracked.

## Design principles

The [Aptos token standard](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/sources/token.move) is developed with the following principles:

- **Interoperability**: Provide a standard implementation to improve
  interoperability across the ecosystem projects. Moreover, Move being a static
  language without dynamic dispatch makes this principle even more imperative.
- **Liquidity**: Achieve maximal liquidity by defining the NFT, fungible
  (non-decimal) and semi-fungible tokens in one contract. These different types of
  tokens can be easily stored, transferred and transacted in the same way. As a
  consequence, it becomes easier to achieve maximal interoperability across the
  marketplaces, exchanges, and other methods of exchange.
- **Rich on-chain token properties**: Enable the customization of on-chain token
  properties. Users can define their own properties and store them on-chain. This
  can potentially eliminate the need for the off-chain metadata.
- **Reduced overhead**: Reduce the cost of creating large amounts of NFTs from
  fungible tokens. This can lead to, for example, reduced overhead for similar
  tokens by the reuse of on-chain metadata for certain fungible tokens.

<Aside type="note">
  **Fungible token ‚Üí NFT**<br />
  The Aptos token standard supports [mutation of a fungible token to an
  NFT](#evolving-from-fungible-token-to-nft).
</Aside>

### Storing customized token properties on-chain

The Aptos token standard uses the [`PropertyMap`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/sources/property_map.move) module to store on-chain
properties of tokens. `PropertyMap` maps a string key to a property value
on-chain, which stores the value in Binary Canonical Serialization (BCS) format
and its type. Currently, only primitive types (bool, u8, u64, u128, address and
String) are supported in `PropertyMap`. Applications, such as [Aptos Names](https://www.aptosnames.com/),
define application specific properties that are read and written by the
applications smart contract.

#### Default properties

You can add your properties to [`default_properties`](https://github.com/aptos-labs/aptos-core/blob/e62fd09cb1c916d857fa655b3f174991ef8698b3/aptos-move/framework/aptos-token/sources/token.move#L98) in the TokenData. The
properties defined here are shared by all tokens by default.

The `default_properties` field is a key-value store with type information. It
leverages the PropertyMap module which contain functions for serializing and
deserializing different primitive types to the property value.

#### Token properties

You can also use the `token_properties` defined in the token itself for
customization on-chain. You can create customized values for a property of this
specific token, thereby allowing a token to have a different property value from
its default.

Note that limits exist to storing customized token properties on-chain, namely
1000 properties per token with field names limited to 128 characters.

### Evolving from fungible token to NFT

Fungible tokens share the same default property values. However, these property
values can evolve over time and become different from each other. To support
such evolution of token properties, the Aptos token standard provides the
`property_version` field. Here is how it works:

- During the token creation (minting), all tokens initially have
  `property_version` set to `0` and these tokens can be stacked together as
  fungible token.
- When the creators mutate the default properties of a token, the mutated token
  will be assigned a unique `property_version` to create a new [`token_id`](https://github.com/aptos-labs/aptos-core/blob/bba1690d7268759bd86ccd7459d7967172f1da24/aptos-move/framework/aptos-token/sources/token.move#L288)
  to differentiate it from other fungible tokens. This unique `token_id` allows
  the token to have its own property values, and all further mutation of this
  token does **not** change the `property_version` again. This token essentially
  becomes an NFT now.

#### Configuring mutability

To make mutability explicit for both the creator and owner, the Aptos token
standard provides [`mutability_config`](https://github.com/aptos-labs/aptos-core/blob/bba1690d7268759bd86ccd7459d7967172f1da24/aptos-move/framework/aptos-token/sources/token.move#L100)
at both the collection level and the token level to control which fields are
mutable. Configurable here means the creator can configure this field to be
mutable or immutable during creation.

### Storing metadata off-chain

Follow the standard below to ensure your NFT can be correctly displayed by
various wallets.

You should store the metadata in a JSON file located in an onchain data solution like [Irys](https://docs.irys.xyz/), and provide the URL to the
JSON file in the `uri` field of the token or the collection. We recommend the
developers follow the [ERC-1155 off-chain data](https://eips.ethereum.org/EIPS/eip-1155)
schema to format their JSON files.

```json
{
  "image": "https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-TGPInmofp-O-o",
  "animation_url": "https://gateway.irys.xyz/QH3rksVhbFg5L9vvjHzb4POUibCEG-TGPInmofp-O-o",
  "external_url": "https://petra.app/",
  "attributes": [
    {
      "trait_type": "web",
      "value": "yes"
    },
    {
      "trait_type": "mobile",
      "value": "yes"
    },
    {
      "trait_type": "extension",
      "value": "yes"
    }
  ],
  "properties": {
    "files": [
      {
        "uri": "https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-ENXUnmofp-O-o",
        "type": "image/png"
      },
      {
        "uri": "https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-UENCnmofp-O-o",
        "type": "unknown",
        "cdn": true
      },
      {
        "uri": "https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-DJHUUnmofp-O-o",
        "type": "video/mp4"
      }
    ],
    "category": "video"
  }
}
```

- `image`: URL to the image asset. You may use the `?ext={file_extension}` query
  to provide information on the file type.
- `animation_url`: URL to the multimedia attachment of the asset. You may use
  the same `file_extension` query to provide the file type.
- `external_url`: URL to an external website where the user can also view the
  image.
- `attributes` - Object array, where an object should contain `trait_type` and
  `value` fields. `value` can be a string or a number.
- `properties.files`: Object array, where an object should contain the URI and
  type of the file that is part of the asset. The type should match the file
  extension. The array should also include files specified in `image` and
  `animation_url` fields, as well as any other files associated with the asset.
  You may use the `?ext={file_extension}` query to provide information on the file
  type.
- `properties.category`: Has supported categories:
- `image` - PNG, GIF, JPG
- `video` - MP4, MOV
- `audio` - MP3, FLAC, WAV
- `vr` - 3D models; GLB, GLTF
- `html` - HTML pages; scripts and relative paths within the HTML page are also
  supported

You can also host your files on CDN to provide faster loading time by using the
`cdn` flag in the file object. When the file exists, this should be the primary
location to read the media file (`video`, `audio`, `vr`) by wallet. If the file
is no longer available, the wallet can fall back to use the `animation_url` to
load the file.

```json
{
  "properties": {
    "files": [
      {
        "uri": "https://watch.videodelivery.net/52a52c4a261c88f19d267931426c9be6",
        "type": "unknown",
        "cdn": true
      }
    ]
  }
}
```

## Token data model

The following diagram depicts the flow of token data through Aptos:

<ThemedImage
  alt="Signed Transaction Flow"
  sources={{
light: '~/images/aptos-token-standard-flow.svg',
dark: '~/images/aptos-token-standard-flow-dark.svg',
}}
/>

## Token resources

As shown in the diagram above, token-related data are stored at both the
creator‚Äôs account and the owner‚Äôs account.

### Struct-level resources

The following tables describe fields at the struct level. For the definitive
list, see the [Aptos Token Framework](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/overview.md).

#### Resource stored at the creator‚Äôs address

| Field                                                                                                                                                                 | Description                                                                                                                                                                                                                                                |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`Collections`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#resource-collections)                                | Maintains a table called `collection_data`, which maps the collection name to the `CollectionData`. It also stores all the `TokenData` that this creator creates.                                                                                          |
| [`CollectionData`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#struct-collectiondata)                            | Stores the collection metadata. The supply is the number of tokens created for the current collection. The maximum is the upper bound of tokens in this collection.                                                                                        |
| [`CollectionMutabilityConfig`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_CollectionMutabilityConfig) | Specifies which field is mutable.                                                                                                                                                                                                                          |
| [`TokenData`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_TokenData)                                   | Acts as the main struct for holding the token metadata. Properties is a where users can add their own properties that are not defined in the token data. Users can mint more tokens based on the `TokenData`, and those tokens share the same `TokenData`. |
| [`TokenMutabilityConfig`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_TokenMutabilityConfig)           | Controls which fields are mutable.                                                                                                                                                                                                                         |
| [`TokenDataId`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_TokenDataId)                               | An ID used for representing and querying `TokenData` on-chain. This ID mainly contains three fields including creator address, collection name and token name.                                                                                             |
| [`Royalty`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_Royalty)                                       | Specifies the denominator and numerator for calculating the royalty fee. It also has the payee account address for depositing the royalty.                                                                                                                 |
| `PropertyValue`                                                                                                                                                       | Contains both value of a property and type of property.                                                                                                                                                                                                    |

#### Resource stored at the owner‚Äôs address

| Field                                                                                                                                 | Description                                                                                                                                                            |
| ------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`TokenStore`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_TokenStore) | The main struct for storing the token owned by this address. It maps `TokenId` to the actual token.                                                                    |
| [`Token`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_Token)           | The amount is the number of tokens.                                                                                                                                    |
| [`TokenId`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_TokenId)       | `TokenDataId` points to the metadata of this token. The `property_version` represents a token with mutated `PropertyMap` from `default_properties` in the `TokenData`. |

For more detailed descriptions, see [Aptos Token Framework](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/overview.md).

## Token lifecycle

### Token creation

Every Aptos token belongs to a collection. The developer first needs to create a
collection through `create_collection_script` and then create the token
belonging to the collection `create_token_script`. To achieve parallel
`TokenData` and `Token` creation, a developer can create unlimited collection
and `TokenData` where the `maximum` of the collection and `TokenData` are set as
`0`. With this setting, the token contract won‚Äôt track the supply of types of
token (`TokenData` count) and supply of token within each token type. As the
result, the `TokenData` and token can be created in parallel.

Aptos also enforces simple validation of the input size and prevents duplication:

- Token name - unique within each collection
- Collection name - unique within each account
- Token and collection name length - smaller than 128 characters
- URI length - smaller than 512 characters
- Property map - can hold at most 1000 properties, and each key should be
  smaller than 128 characters

### Token mutation

Our standard supports mutation with a principle that the mutable fields are
specified during the token creation. This allows the token owner to be informed
which fields are mutable when they get the token from the creator. Our contract
uses `CollectionMutabilityConfig` to check if a field is mutable. Our contract
uses `TokenMutabilityConfig` to check if a `TokenData` field is mutable.

For mutation of properties, we have both

- `default_properties` stored in `TokenData` shared by all tokens belonging to
  the `TokenData`
- `token_properties` stored in the token itself

To mutate `default_properties`, developers can use `mutate_tokendata_property`
to mutate the properties when `TokenMutabilityConfig` is set to `true`.

> **CAUTION: Set the `TokenMutabilityConfig` field to `false` unless it is
> absolutely necessary. Allowing `default_properties` to be mutable provides
> creators too much power; creators can change the burnable config to provide
> themselves the authority to burn tokens after token creation.**

To mutate `token_properties` stored in the token, our standard uses the
`TOKEN_PROPERTY_MUTABLE` property stored in `default_properties`. When the
creator creates the `TokenData` with the `TOKEN_PROPERTY_MUTABLE` property
set to `true`, the creator can mutate `token_properties`. Note that if the
`mutate_tokendata_property` is set to `true`, creators can mutate the
`token_properties` anyway since they can overwrite the setting in
`default_properties`.

### Token burn

We provide `burn` and `burn_by_creator` functions for token owners and token
creators to burn (or destroy) tokens. However, these two functions are also
guarded by configs that are specified during the token creation so that both
creator and owner are clear on who can burn the token. Burn is allowed only when
the `BURNABLE_BY_OWNER` property is set to `true` in `default_properties`. Burn
by creator is allowed when `BURNABLE_BY_CREATOR` is `true` in
`default_properties`. Once all the tokens belonging to a `TokenData` are burned,
the `TokenData` will be removed from the creator‚Äôs account. Similarly, if all
`TokenData` belonging to a collection are removed, the `CollectionData` will be
removed from the creator‚Äôs account.

### Token transfer

We provide three different modes for transferring tokens between the sender and
receiver.

#### Two-step transfer

To protect users from receiving undesired NFTs, they must be first offered NFTs,
and then accept the offered NFTs. Then only the offered NFTs will be deposited
in the users' token stores. This is the default token transfer behavior. For
example:

1. If Alice wants to send Bob an NFT, she must first offer Bob this NFT. This
   NFT is still stored under Alice‚Äôs account.
2. Only when Bob claims the NFT, will the NFT be removed from Alice‚Äôs account
   and stored in Bob‚Äôs token store.

<Aside type="note">
  **Token transfer module**<br />
  The token transfer is implemented in the
  [`token_transfers`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/sources/token_transfers.move)
  module.
</Aside>

#### Transfer with opt-in

If a user wants to receive direct transfer of the NFT, skipping the initial
steps of offer and claim, then the user can call [`opt_in_direct_transfer`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_opt_in_direct_transfer)
to allow other people to directly transfer the NFTs into the user's token store.
After opting into direct transfer, the user can call [`transfer`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#0x3_token_transfer)
to transfer tokens directly. For example, Alice and anyone can directly send a
token to Bob's token store once Bob opts in.

<Aside type="note">
  **Turning off direct transfer**<br />
  The user can also turn off this direct transfer behavior by calling the same
  `opt_in_direct_transfer` function to reset to the default behavior.
</Aside>

#### Multi-agent transfer

The sender and receiver can both sign a transfer transaction to directly
transfer a token from the sender to receiver [`direct_transfer_script`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/doc/token.md#function-direct_transfer_script).
For example, once Alice and Bob both sign the transfer transaction, the token
will be directly transferred from Alice's account to Bob.

# Binary Canonical Serialization (BCS)

> Learn about bcs for Move smart contract development on Aptos blockchain.

import { TabItem, Tabs } from '@astrojs/starlight/components';

Binary Canonical Serialization (BCS) is the serialization format used on the Aptos
blockchain. It is a binary canonical non-self-describing serialization format
that is used to serialize data structures.  BCS is used to serialize all data
on-chain, provide binary responses on the REST API, and encode input arguments
to transactions.

## Overview

Because BCS is not a self describing format, the reader must know the format of
the bytes ahead of time.

## Primitive Types

8-bit, 16-bit, 32-bit, 64-bit, 128-bit, and 256-bit unsigned integers are
supported.  They are serialized in little-endian byte order.

### Bool (boolean)

Booleans are serialized as a single byte.  `true` is serialized as `0x01` and
`false` is serialized as `0x00`.  All other values are invalid.

| Value   | Bytes  |
| ------- | ------ |
| `true`  | `0x01` |
| `false` | `0x00` |

<Tabs>
  <TabItem label="Move">
    ```move filename="bool.move"
    #[test_only]
    module 0x42::example {
      use std::bcs;
      use std::from_bcs;

      #[test]
      fun test_bool() {
        // Serialize
        let val: bool = true;
        let bytes: vector<u8> = bcs::to_bytes(&val);
        assert!(bytes == vector[0x01]);

        // Deserialize
        let val_des = from_bcs::to_bool(bytes);
        assert!(val_des == true);
      }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="bool.rs"
    // Serialize
    let val: bool = true;
    let bytes: Vec<u8> = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![0x01]);

    // Deserialize
    let val_des = bcs::from_bytes::<bool>(&bytes).unwrap();
    assert_eq!(val_des, true);
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="bool.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeBool(true);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([1]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeBool();
    console.log(val == true);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="bool.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      ser.Bool(true)
      trueBytes := ser.ToBytes()
      trueBytes == []byte{0x01}

      // Deserialize
      des := bcs.NewDeserializer(trueBytes)
      val := des.Bool()
      val == true
    }
    ```
  </TabItem>
</Tabs>

### U8 (unsigned 8-bit integer)

Unsigned 8-bit integers are serialized as a single byte.

<Tabs>
  <TabItem label="Move">
    ```move filename="u8.move"
    #[test_only]
    module 0x42::example {
      use std::bcs;
      use std::from_bcs;

      #[test]
      fun test_u8() {
        // Serialize
        let val: u8 = 1;
        let bytes: vector<u8> = bcs::to_bytes(&val);
        assert!(bytes == vector[0x01]);

        // Deserialize
        let val_des = from_bcs::to_u8(bytes);
        assert!(val_des == 1);
      }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="u8.rs"
    // Serialize
    let val: u8 = 1;
    let bytes: Vec<u8> = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![0x01]);

    // Deserialize
    let val_des = bcs::from_bytes::<u8>(&bytes).unwrap();
    assert_eq!(val_des, 1);
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="bool.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeU8(1);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([1]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeU8();
    console.log(val == 1);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="bool.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      ser.U8(1)
      trueBytes := ser.ToBytes()
      trueBytes == []byte{0x01}

      // Deserialize
      des := bcs.NewDeserializer(trueBytes)
      val := des.U8()
      val == 1
    }
    ```
  </TabItem>
</Tabs>

### U16 (unsigned 16-bit integer)

Unsigned 16-bit integers are serialized as 2 bytes in little-endian byte order.

<Tabs>
  <TabItem label="Move">
    ```move filename="u16.move"
    #[test_only]
    module 0x42::example {
     use std::bcs;
     use std::from_bcs;

     #[test]
     fun test_u16() {
       // Serialize
       let val: u16 = 1000;
       let bytes: vector<u8> = bcs::to_bytes(&val);
       assert!(bytes == vector[0xe8, 0x03]);

       // Deserialize
       let val_des = from_bcs::to_u16(bytes);
       assert!(val_des == 1000);
     }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="u16.rs"
    // Serialize
    let val: u16 = 1000;
    let bytes: Vec<u8> = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![0xe8, 0x03]);

    // Deserialize
    let val_des = bcs::from_bytes::<u16>(&bytes).unwrap();
    assert_eq!(val_des, 1000);
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="u16.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeU16(1000);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([0xe8, 0x03]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeU16();
    console.log(val == 1000);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="u16.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      ser.U16(1000)
      bytes := ser.ToBytes()
      bytes == []byte{0xe8, 0x03}

      // Deserialize
      des := bcs.NewDeserializer(bytes)
      val := des.U16()
      val == 1000
    }
    ```
  </TabItem>
</Tabs>

### U32 (unsigned 32-bit integer)

Unsigned 32-bit integers are serialized as 4 bytes in little-endian byte order.

<Tabs>
  <TabItem label="Move">
    ```move filename="u32.move"
    #[test_only]
    module 0x42::example {
      use std::bcs;
      use std::from_bcs;

      #[test]
      fun test_u32() {
        // Serialize
        let val: u32 = 1000000000;
        let bytes: vector<u8> = bcs::to_bytes(&val);
        assert!(bytes == vector[0x00, 0xca, 0x9a, 0x3b]);

        // Deserialize
        let val_des = from_bcs::to_u32(bytes);
        assert!(val_des == 1000000000);
      }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="u32.rs"
    // Serialize
    let val: u32 = 1000000000;
    let bytes: Vec<u8> = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![0x00, 0xca, 0x9a, 0x3b]);

    // Deserialize
    let val_des = bcs::from_bytes::<u32>(&bytes).unwrap();
    assert_eq!(val_des, 1000000000);
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="u32.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeU32(1000000000);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([0x00, 0xca, 0x9a, 0x3b]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeU32();
    console.log(val == 1000000000);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="u32.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      ser.U32(1000000000)
      bytes := ser.ToBytes()
      bytes == []byte{0x00, 0xca, 0x9a, 0x3b}

      // Deserialize
      des := bcs.NewDeserializer(bytes)
      val := des.U32()
      val == 1000000000
    }
    ```
  </TabItem>
</Tabs>

### U64 (unsigned 64-bit integer)

Unsigned 64-bit integers are serialized as 8 bytes in little-endian byte order.

<Tabs>
  <TabItem label="Move">
    ```move filename="u64.move"
    #[test_only]
    module 0x42::example {
      use std::bcs;
      use std::from_bcs;

      #[test]
      fun test_u64() {
        // Serialize
        let val: u64 = 10000000000000000;
        let bytes: vector<u8> = bcs::to_bytes(&val);
        assert!(bytes == vector[0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]);

        // Deserialize
        let val_des = from_bcs::to_u64(bytes);
        assert!(val_des == 10000000000000000);
      }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="u64.rs"
    // Serialize
    let val: u64 = 10000000000000000;
    let bytes: Vec<u8> = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]);

    // Deserialize
    let val_des = bcs::from_bytes::<u64>(&bytes).unwrap();
    assert_eq!(val_des, 10000000000000000);
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="u64.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeU64(10000000000000000n);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeU64();
    console.log(val == 10000000000000000n);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="u64.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      ser.U64(10000000000000000)
      bytes := ser.ToBytes()
      bytes == []byte{0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00}

      // Deserialize
      des := bcs.NewDeserializer(bytes)
      val := des.U64()
      val == 10000000000000000
    }
    ```
  </TabItem>
</Tabs>

### U128 (unsigned 128-bit integer)

Unsigned 128-bit integers are serialized as 16 bytes in little-endian byte order.

<Tabs>
  <TabItem label="Move">
    ```move filename="u128.move"
    #[test_only]
    module 0x42::example {
      use std::bcs;
      use std::from_bcs;

      #[test]
      fun test_u128() {
        // Serialize
        let val: u128 = 10000000000000000;
        let bytes: vector<u8> = bcs::to_bytes(&val);
        assert!(bytes == vector[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]);

        // Deserialize
        let val_des = from_bcs::to_u128(bytes);
        assert!(val_des == 10000000000000000);
      }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="u128.rs"
    // Serialize
    let val: u128 = 10000000000000000;
    let bytes: Vec<u8> = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]);

    // Deserialize
    let val_des = bcs::from_bytes::<u128>(&bytes).unwrap();
    assert_eq!(val_des, 10000000000000000);
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="u128.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeU128(10000000000000000n);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeU128();
    console.log(val == 10000000000000000n);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="u128.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
      "math/big"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      val := new(big.Int)
      val.SetString("10000000000000000", 10)
      ser.U128(val)
      bytes := ser.ToBytes()
      bytes == []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00}

      // Deserialize
      des := bcs.NewDeserializer(bytes)
      val_des := des.U128()
      val_des.String() == "10000000000000000"
    }
    ```
  </TabItem>
</Tabs>

### U256 (unsigned 256-bit integer)

Unsigned 256-bit integers are serialized as 32 bytes in little-endian byte order.

<Tabs>
  <TabItem label="Move">
    ```move filename="u256.move"
    #[test_only]
    module 0x42::example {
      use std::bcs;
      use std::from_bcs;

      #[test]
      fun test_u256() {
        // Serialize
        let val: u256 = 10000000000000000;
        let bytes: vector<u8> = bcs::to_bytes(&val);
        assert!(bytes == vector[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]);

        // Deserialize
        let val_des = from_bcs::to_u256(bytes);
        assert!(val_des == 10000000000000000);
      }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="u256.rs"
    // Serialize
    let val: U256 = U256::from(10000000000000000u64);
    let bytes: Vec<u8> = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]);

    // Deserialize
    let val_des = bcs::from_bytes::<U256>(&bytes).unwrap();
    assert_eq!(val_des, U256::from(10000000000000000u64));
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="u256.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeU256(10000000000000000n);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeU256();
    console.log(val == 10000000000000000n);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="u256.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
      "math/big"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      val := new(big.Int)
      val.SetString("10000000000000000", 10)
      ser.U256(val)
      bytes := ser.ToBytes()
      bytes == []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x9c, 0x4f, 0x2c, 0x68, 0x00, 0x00}

      // Deserialize
      des := bcs.NewDeserializer(bytes)
      val_des := des.U256()
      val_des.String() == "10000000000000000"
    }
    ```
  </TabItem>
</Tabs>

### Uleb128 (unsigned 128-bit variable length integer)

Unsigned 128-bit variable length integers are serialized as a variable number of bytes.  The most significant bit of each byte is used to indicate if there are more bytes to read.  The remaining 7 bits are used to store the value.

This is common used for variable lengths of vectors, or for enums.

<Tabs>
  <TabItem label="Move">
    ```move filename="uleb128.move"
    // Currently not supported by itself in Move
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="uleb128.rs"
    // Currently not supported by itself in Rust with serde
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="uleb128.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeU32AsUleb128(127);
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([0x7f]));

    const ser = new Serializer();
    ser.serializeU32AsUleb128(128);
    const bytes2 = ser.toUint8Array();
    console.log(bytes2 == Uint8Array.from([0x80, 0x01]));

    // Deserialize
    const des = new Deserializer(bytes2);
    const val = des.deserializeUleb128AsU32();
    console.log(val == 128);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="uleb128.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
      "math/big"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      val := new(big.Int)
      val.SetInt64(127)
      ser.Uleb128(val)
      bytes := ser.ToBytes()
      bytes == []byte{0x7f}

      // Deserialize
      des := bcs.NewDeserializer(bytes)
      val_des := des.Uleb128()
      val_des.Int64() == 127
    }
    ```
  </TabItem>
</Tabs>

### Sequence and FixedSequence

Sequences are serialized as a variable length vector of an item.  The length of
the vector is serialized as a Uleb128 followed by repeated items.  FixedSequences
are serialized without the leading size byte.  The reader must know the number
of bytes prior to deserialization.

<Tabs>
  <TabItem label="Move">
    ```move filename="vector.move"
    #[test_only]
    module 0x42::example {
      use std::bcs;
      use std::from_bcs;

      #[test]
      fun test_vector() {
        // Serialize
        let val = vector[1u8, 2u8, 3u8];
        let bytes = bcs::to_bytes(&val);
        assert!(bytes == vector[3, 1, 2, 3]);

        // Deserialize, only supports bytes for now
        let val_des = from_bcs::to_bytes(bytes);
        assert!(val_des == vector[1, 2, 3]);
      }
    }
    ```
  </TabItem>

  <TabItem label="Rust">
    ```rust filename="vector.rs"
    // Serialize
    let val = vec![1u8, 2u8, 3u8];
    let bytes = bcs::to_bytes(&val).unwrap();
    assert_eq!(bytes, vec![3, 1, 2, 3]);

    // Deserialize
    let val_des = bcs::from_bytes::<Vec<u8>>(&bytes).unwrap();
    assert_eq!(val_des, vec![1, 2, 3]);
    ```
  </TabItem>

  <TabItem label="TypeScript">
    ```typescript filename="vector.ts"
    import { Serializer, Deserializer } from "@aptos-labs/ts-sdk";

    // Serialize
    const ser = new Serializer();
    ser.serializeVector([1, 2, 3], (s, item) => s.serializeU8(item));
    const bytes = ser.toUint8Array();
    console.log(bytes == Uint8Array.from([3, 1, 2, 3]));

    // Deserialize
    const des = new Deserializer(bytes);
    const val = des.deserializeVector((d) => d.deserializeU8());
    console.log(val == [1, 2, 3]);
    ```
  </TabItem>

  <TabItem label="Go">
    ```go filename="vector.go"
    import (
      "github.com/aptos-labs/aptos-go-sdk"
    )

    func main() {
      // Serialize
      ser := bcs.Serializer{}
      ser.SerializeVector([]uint8{1, 2, 3}, func(s *bcs.Serializer, item uint8) {
        s.U8(item)
      })
      bytes := ser.ToBytes()
      bytes == []byte{3, 1, 2, 3}

      // Deserialize
      des := bcs.NewDeserializer(bytes)
      val := des.DeserializeVector(func(d *bcs.Deserializer) uint8 {
        return d.U8()
      })
      val == []uint8{1, 2, 3}
    }
    ```
  </TabItem>
</Tabs>

## Complex types

### String

Strings are serialized as a vector of bytes, however the bytes are encoded as UTF-8.

```rust
// Note that this string has 10 characters but has a byte length of 24
let utf8_str = "√ß√•‚àû‚â†¬¢√µ√ü‚àÇ∆í‚à´";
let expecting = vec![
    24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e, 0xe2, 0x89, 0xa0, 0xc2,
    0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab,
];
assert_eq!(to_bytes(&utf8_str)?, expecting);
```

### AccountAddress

AccountAddress is serialized as a fixed 32 byte vector of bytes.

```
@0x1 => [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01]
```

### Struct

Structs are serialized as an ordered set of fields.  The fields are serialized in the order they are defined in the struct.

```
struct Color {
  r: u8 = 1,
  g: u8 = 2,
  b: u8 = 3,
} => [0x01, 0x02, 0x03]
```

### Option

Options are serialized as a single byte to determine whether it's filled. If the
option is `None`, the byte is `0x00`. If the option is `Some`, the byte is
`0x01` followed by the serialized value.

```rust
let some_data: Option<u8> = Some(8);
assert_eq!(to_bytes(&some_data)?, vec![1, 8]);

let no_data: Option<u8> = None;
assert_eq!(to_bytes(&no_data)?, vec![0]);
```

### Enum

Enums are serialized as a uleb128 to determine which variant is being used.
The size is followed by the serialized value of the variant.

```rust
#[derive(Serialize)]
enum E {
    Variant0(u16),
    Variant1(u8),
    Variant2(String),
}

let v0 = E::Variant0(8000);
let v1 = E::Variant1(255);
let v2 = E::Variant2("e".to_owned());

assert_eq!(to_bytes(&v0)?, vec![0, 0x40, 0x1F]);
assert_eq!(to_bytes(&v1)?, vec![1, 0xFF]);
assert_eq!(to_bytes(&v2)?, vec![2, 1, b'e']);
```

### Maps

Maps are stored as a sequence of tuples.  The length of the map is serialized as a Uleb128 followed by repeated key-value pairs.

```rust
let mut map = HashMap::new();
map.insert(b'e', b'f');
map.insert(b'a', b'b');
map.insert(b'c', b'd');

let expecting = vec![(b'a', b'b'), (b'c', b'd'), (b'e', b'f')];

assert_eq!(to_bytes(&map)?, to_bytes(&expecting)?);
```

## Reference

- [BCS Specification](https://github.com/diem/bcs)

# The Move Book

> Learn about book in Move programming language for Aptos smart contract development.

Welcome to Move, a next generation language for secure, sandboxed, and formally
verified programming. It has been used as the smart contract language for
several blockchains including Aptos. Move allows developers to write programs
that flexibly manage and transfer assets, while providing the security and
protections against attacks on those assets. However, Move has been developed
with use cases in mind outside a blockchain context as well.

Move takes its cue from [Rust](https://www.rust-lang.org/) by using resource
types with move (hence the name) semantics as an explicit representation of
digital assets, such as currency.

## Who is Aptos Move Book for?

Move was designed and created as a secure, verified, yet flexible programming
language. The first use of Move is for the implementation of the Diem
blockchain, and it is currently being used on Aptos.

This book is suitable for developers with some programming experience
and who want to begin understanding the core programming language and see
examples of its usage.

## Where Do I Start?

Begin with understanding [modules and scripts](/build/smart-contracts/book/modules-and-scripts)
and then work through the [Move Tutorial](/build/smart-contracts/book/move-tutorial).

# Abilities

> Learn about abilities in Move programming language for Aptos smart contract development.

Abilities are a typing feature in Move that control what actions are permissible for values of a given type. This system grants fine-grained control over the "linear" typing behavior of values, as well as if and how values are used in global storage. This is implemented by gating access to certain bytecode instructions so that for a value to be used with the bytecode instruction, it must have the ability required (if one is required at all‚Äînot every instruction is gated by an ability).

{/* TODO future section on detailed walk through, maybe. We have some examples at the end, but it might be helpful to explain why we have precisely this set of abilities */}

{/* If you are already somewhat familiar with abilities from writing Move programs, but are still confused as to what is going on, it might be helpful to skip to the [motivating walkthrough](#motivating-walkthrough) section to get an idea of what the system is set up in the way that it is. --> */}

## The Four Abilities

The four abilities are:

- [`copy`](#copy)
  - Allows values of types with this ability to be copied.
- [`drop`](#drop)
  - Allows values of types with this ability to be popped/dropped.
- [`store`](#store)
  - Allows values of types with this ability to exist inside a struct in global storage.
- [`key`](#key)
  - Allows the type to serve as a key for global storage operations.

### `copy`

The `copy` ability allows values of types with that ability to be copied. It gates the ability to copy values out of local variables with the [`copy`](/build/smart-contracts/book/variables#move-and-copy) operator and to copy values via references with [dereference `*e`](/build/smart-contracts/book/references#reading-and-writing-through-references).

If a value has `copy`, all values contained inside of that value have `copy`.

### `drop`

The `drop` ability allows values of types with that ability to be dropped. By dropped, we mean that value is not transferred and is effectively destroyed as the Move program executes. As such, this ability gates the ability to ignore values in a multitude of locations, including:

- not using the value in a local variable or parameter
- not using the value in a [sequence via `;`](/build/smart-contracts/book/variables#expression-blocks)
- overwriting values in variables in [assignments](/build/smart-contracts/book/variables#assignments)
- overwriting values via references when [writing `*e1 = e2`](/build/smart-contracts/book/references#reading-and-writing-through-references).

If a value has `drop`, all values contained inside of that value have `drop`.

### `store`

The `store` ability allows values of types with this ability to exist inside a struct (resource) in global storage, _but_ not necessarily as a top-level resource in global storage. This is the only ability that does not directly gate an operation. Instead, it gates the existence in global storage when used in tandem with `key`.

If a value has `store`, all values contained inside of that value have `store`

### `key`

The `key` ability allows the type to serve as a key for [global storage operations](/build/smart-contracts/book/global-storage-operators). It gates all global storage operations, so in order for a type to be used with `move_to`, `borrow_global`, `move_from`, etc., the type must have the `key` ability. Note that the operations still must be used in the module where the `key` type is defined (in a sense, the operations are private to the defining module).

If a value has `key`, all values contained inside of that value have `store`. This is the only ability with this sort of asymmetry.

## Builtin Types

Most primitive, builtin types have `copy`, `drop`, and `store` except for `signer`, which just has `drop`

- `bool`, `u8`, `u16`, `u32`, `u64`, `u128`, `u256`, and `address` all have `copy`, `drop`, and `store`.
- `signer` has `drop`
  - Cannot be copied and cannot be put into global storage
- `vector<T>` may have `copy`, `drop`, and `store` depending on the abilities of `T`.
  - See [Conditional Abilities and Generic Types](#conditional-abilities-and-generic-types) for more details.
- Immutable references `&` and mutable references `&mut` both have `copy` and `drop`.
  - This refers to copying and dropping the reference itself, not what they refer to.
  - References cannot appear in global storage, hence they do not have `store`.

None of the primitive types have `key`, meaning none of them can be used directly with the [global storage operations](/build/smart-contracts/book/global-storage-operators).

## Annotating Structs

To declare that a `struct` has an ability, it is declared with `has <ability>` after the struct name but before the fields. For example:

```move
module 0x42::example {
  struct Ignorable has drop { f: u64 }

  struct Pair has copy, drop, store { x: u64, y: u64 }
}
```

In this case: `Ignorable` has the `drop` ability. `Pair` has `copy`, `drop`, and `store`.

All of these abilities have strong guarantees over these gated operations. The operation can be performed on the value only if it has that ability; even if the value is deeply nested inside some other collection!

As such: when declaring a struct‚Äôs abilities, certain requirements are placed on the fields. All fields must satisfy these constraints. These rules are necessary so that structs satisfy the reachability rules for the abilities given above. If a struct is declared with the ability...

- `copy`, all fields must have `copy`.
- `drop`, all fields must have `drop`.
- `store`, all fields must have `store`.
- `key`, all fields must have `store`.
  - `key` is the only ability currently that doesn't require itself.

For example:

```move
module 0x42::example {
  // A struct without any abilities
  struct NoAbilities {}

  struct WantsCopy has copy {
    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'
  }
}
```

and similarly:

```move
module 0x42::example {
  // A struct without any abilities
  struct NoAbilities {}

  struct MyResource has key {
    f: NoAbilities, // Error 'NoAbilities' does not have 'store'
  }
}
```

## Conditional Abilities and Generic Types

When abilities are annotated on a generic type, not all instances of that type are guaranteed to have that ability. Consider this struct declaration:

```move
module 0x42::example {
  struct Cup<T> has copy, drop, store, key { item: T }
}
```

It might be very helpful if `Cup` could hold any type, regardless of its abilities. The type system can _see_ the type parameter, so it should be able to remove abilities from `Cup` if it _sees_ a type parameter that would violate the guarantees for that ability.

This behavior might sound a bit confusing at first, but it might be more understandable if we think about collection types. We could consider the builtin type `vector` to have the following type declaration:

```move
vector<T> has copy, drop, store;
```

We want `vector`s to work with any type. We don't want separate `vector` types for different abilities. So what are the rules we would want? Precisely the same that we would want with the field rules above. So, it would be safe to copy a `vector` value only if the inner elements can be copied. It would be safe to ignore a `vector` value only if the inner elements can be ignored/dropped. And, it would be safe to put a `vector` in global storage only if the inner elements can be in global storage.

To have this extra expressiveness, a type might not have all the abilities it was declared with depending on the instantiation of that type; instead, the abilities a type will have depends on both its declaration **and** its type arguments. For any type, type parameters are pessimistically assumed to be used inside the struct, so the abilities are only granted if the type parameters meet the requirements described above for fields. Taking `Cup` from above as an example:

- `Cup` has the ability `copy` only if `T` has `copy`.
- It has `drop` only if `T` has `drop`.
- It has `store` only if `T` has `store`.
- It has `key` only if `T` has `store`.

Here are examples for this conditional system for each ability:

### Example: conditional `copy`

```move
module 0x42::example {
  struct NoAbilities {}

  struct S has copy, drop { f: bool }

  struct Cup<T> has copy, drop, store { item: T }

  fun example(c_x: Cup<u64>, c_s: Cup<S>) {
    // Valid, 'Cup<u64>' has 'copy' because 'u64' has 'copy'
    let c_x2 = copy c_x;
    // Valid, 'Cup<S>' has 'copy' because 'S' has 'copy'
    let c_s2 = copy c_s;
  }

  fun invalid(c_account: Cup<signer>, c_n: Cup<NoAbilities>) {
    // Invalid, 'Cup<signer>' does not have 'copy'.
    // Even though 'Cup' was declared with copy, the instance does not have 'copy'
    // because 'signer' does not have 'copy'
    let c_account2 = copy c_account;
    // Invalid, 'Cup<NoAbilities>' does not have 'copy'
    // because 'NoAbilities' does not have 'copy'
    let c_n2 = copy c_n;
  }
}
```

### Example: conditional `drop`

```move
module 0x42::example {
  struct NoAbilities {}

  struct S has copy, drop { f: bool }

  struct Cup<T> has copy, drop, store { item: T }

  fun unused() {
    Cup<bool> { item: true }; // Valid, 'Cup<bool>' has 'drop'
    Cup<S> { item: S { f: false } }; // Valid, 'Cup<S>' has 'drop'
  }

  fun left_in_local(c_account: Cup<signer>): u64 {
    let c_b = Cup<bool> { item: true };
    let c_s = Cup<S> { item: S { f: false } };
    // Valid return: 'c_account', 'c_b', and 'c_s' have values
    // but 'Cup<signer>', 'Cup<bool>', and 'Cup<S>' have 'drop'
    0
  }

  fun invalid_unused() {
    // Invalid, Cannot ignore 'Cup<NoAbilities>' because it does not have 'drop'.
    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'
    // because 'NoAbilities' does not have 'drop'
    Cup<NoAbilities> { item: NoAbilities {} };
  }

  fun invalid_left_in_local(): u64 {
    let c_n = Cup<NoAbilities> { item: NoAbilities {} };
    // Invalid return: 'c_n' has a value
    // and 'Cup<NoAbilities>' does not have 'drop'
    0
  }
}
```

### Example: conditional `store`

```move
module 0x42::example {
  struct Cup<T> has copy, drop, store { item: T }

  // 'MyInnerResource' is declared with 'store' so all fields need 'store'
  struct MyInnerResource has store {
    yes: Cup<u64>,
    // Valid, 'Cup<u64>' has 'store'
    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'
  }

  // 'MyResource' is declared with 'key' so all fields need 'store'
  struct MyResource has key {
    yes: Cup<u64>,
    // Valid, 'Cup<u64>' has 'store'
    inner: Cup<MyInnerResource>,
    // Valid, 'Cup<MyInnerResource>' has 'store'
    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'
  }
}
```

### Example: conditional `key`

```move
module 0x42::example {
  struct NoAbilities {}

  struct MyResource<T> has key { f: T }

  fun valid(account: &signer) acquires MyResource {
    let addr = signer::address_of(account);
    // Valid, 'MyResource<u64>' has 'key'
    let has_resource = exists<MyResource<u64>>(addr);
    if (!has_resource) {
      // Valid, 'MyResource<u64>' has 'key'
      move_to(account, MyResource<u64> { f: 0 })
    };
    // Valid, 'MyResource<u64>' has 'key'
    let r = borrow_global_mut<MyResource<u64>>(addr)
    r.f = r.f + 1;
  }

  fun invalid(account: &signer) {
    // Invalid, 'MyResource<NoAbilities>' does not have 'key'
    let has_it = exists<MyResource<NoAbilities>>(addr);
    // Invalid, 'MyResource<NoAbilities>' does not have 'key'
    let NoAbilities {} = move_from<NoAbilities>(addr);
    // Invalid, 'MyResource<NoAbilities>' does not have 'key'
    move_to(account, NoAbilities {});
    // Invalid, 'MyResource<NoAbilities>' does not have 'key'
    borrow_global<NoAbilities>(addr);
  }
}
```

# Abort and Assert

> Understand error handling in Move with abort statements, assert macros, and exception management patterns.

[`return`](/build/smart-contracts/book/functions) and `abort` are two control flow constructs that end execution, one for
the current function and one for the entire transaction.

More information on [`return` can be found in the linked section](/build/smart-contracts/book/functions)

## `abort`

`abort` is an expression that takes one argument: an **abort code** of type `u64`. For example:

```move
abort 42
```

The `abort` expression halts execution of the current function and reverts all changes made to global
state by the current transaction. There is no mechanism for "catching" or otherwise handling an
`abort`.

Luckily, in Move transactions are all or nothing, meaning any changes to global storage are made all
at once only if the transaction succeeds. Because of this transactional commitment of changes, after
an abort there is no need to worry about backing out changes. While this approach is lacking in
flexibility, it is incredibly simple and predictable.

Similar to [`return`](/build/smart-contracts/book/functions), `abort` is useful for exiting control flow when some
condition cannot be met.

In this example, the function will pop two items off of the vector, but will abort early if the
vector does not have two items

```move
script {
  use std::vector;
  fun pop_twice<T>(v: &mut vector<T>): (T, T) {
      if (vector::length(v) < 2) abort 42;

      (vector::pop_back(v), vector::pop_back(v))
  }
}
```

This is even more useful deep inside a control-flow construct. For example, this function checks
that all numbers in the vector are less than the specified `bound`. And aborts otherwise

```move
script {
  use std::vector;
  fun check_vec(v: &vector<u64>, bound: u64) {
      let i = 0;
      let n = vector::length(v);
      while (i < n) {
          let cur = *vector::borrow(v, i);
          if (cur > bound) abort 42;
          i = i + 1;
      }
  }
}
```

### `assert`

`assert` is a builtin, macro-like operation provided by the Move compiler. It takes two arguments, a
condition of type `bool` and a code of type `u64`

```move
assert!(condition: bool, code: u64)
assert!(condition: bool) // Since Move 2.0
```

Since the operation is a macro, it must be invoked with the `!`. This is to convey that the
arguments to `assert` are call-by-expression. In other words, `assert` is not a normal function and
does not exist at the bytecode level. It is replaced inside the compiler with

```move
if (condition) () else abort code
```

Since Move 2.0, `assert` without an error code is supported. If this assert is used, the
abort code `0xCA26CBD9BE0B0000` is generated.  In terms of the `std::error` convention, this code has
category `std::error::INTERNAL` and reason `0`.

`assert` is more commonly used than just `abort` by itself. The `abort` examples above can be
rewritten using `assert`

```move
script {
  use std::vector;
  fun pop_twice<T>(v: &mut vector<T>): (T, T) {
      assert!(vector::length(v) >= 2, 42); // Now uses 'assert'

      (vector::pop_back(v), vector::pop_back(v))
  }
}
```

and

```move
script {
  use std::vector;
  fun check_vec(v: &vector<u64>, bound: u64) {
      let i = 0;
      let n = vector::length(v);
      while (i < n) {
          let cur = *vector::borrow(v, i);
          assert!(cur <= bound, 42); // Now uses 'assert'
          i = i + 1;
      }
  }
}
```

Note that because the operation is replaced with this `if-else`, the argument for the `code` is not
always evaluated. For example:

```move
assert!(true, 1 / 0)
```

Will not result in an arithmetic error, it is equivalent to

```move
if (true) () else (1 / 0)
```

So the arithmetic expression is never evaluated!

### Abort codes in the Move VM

When using `abort`, it is important to understand how the `u64` code will be used by the VM.

Normally, after successful execution, the Move VM produces a change-set for the changes made to
global storage (added/removed resources, updates to existing resources, etc.).

If an `abort` is reached, the VM will instead indicate an error. Included in that error will be two
pieces of information:

- The module that produced the abort (address and name)
- The abort code.

For example

```move
module 0x42::example {
  public fun aborts() {
    abort 42
  }
}

script {
  fun always_aborts() {
    0x2::example::aborts()
  }
}
```

If a transaction, such as the script `always_aborts` above, calls `0x2::example::aborts`, the VM
would produce an error that indicated the module `0x2::example` and the code `42`.

This can be useful for having multiple aborts being grouped together inside a module.

In this example, the module has two separate error codes used in multiple functions

```move
module 0x42::example {

  use std::vector;

  const EMPTY_VECTOR: u64 = 0;
  const INDEX_OUT_OF_BOUNDS: u64 = 1;

  // move i to j, move j to k, move k to i
  public fun rotate_three<T>(v: &mut vector<T>, i: u64, j: u64, k: u64) {
    let n = vector::length(v);
    assert!(n > 0, EMPTY_VECTOR);
    assert!(i < n, INDEX_OUT_OF_BOUNDS);
    assert!(j < n, INDEX_OUT_OF_BOUNDS);
    assert!(k < n, INDEX_OUT_OF_BOUNDS);

    vector::swap(v, i, k);
    vector::swap(v, j, k);
  }

  public fun remove_twice<T>(v: &mut vector<T>, i: u64, j: u64): (T, T) {
    let n = vector::length(v);
    assert!(n > 0, EMPTY_VECTOR);
    assert!(i < n, INDEX_OUT_OF_BOUNDS);
    assert!(j < n, INDEX_OUT_OF_BOUNDS);
    assert!(i > j, INDEX_OUT_OF_BOUNDS);

    (vector::remove<T>(v, i), vector::remove<T>(v, j))
  }
}
```

## The type of `abort`

The `abort i` expression can have any type! This is because both constructs break from the normal
control flow, so they never need to evaluate to the value of that type.

The following are not useful, but they will type check

```move
let y: address = abort 0;
```

This behavior can be helpful in situations where you have a branching instruction that produces a
value on some branches, but not all. For example:

```move
script {
  fun example() {
    let b =
        if (x == 0) false
        else if (x == 1) true
        else abort 42;
    //       ^^^^^^^^ `abort 42` has type `bool`
  }
}
```

# Address

> Learn about address types in Move for account identification, authentication, and resource location on Aptos blockchain.

`address` is a built-in type in Move that is used to represent locations (sometimes called accounts) in global storage. An `address` value is a 256-bit (32-byte) identifier. At a given address, two things can be stored: [Modules](/build/smart-contracts/book/modules-and-scripts) and [Resources](/build/smart-contracts/book/structs-and-resources).

Although an `address` is a 256-bit integer under the hood, Move addresses are intentionally opaque---they cannot be created from integers, they do not support arithmetic operations, and they cannot be modified. Even though there might be interesting programs that would use such a feature (e.g., pointer arithmetic in C fills a similar niche), Move does not allow this dynamic behavior because it has been designed from the ground up to support static verification.

You can use runtime address values (values of type `address`) to access resources at that address. You _cannot_ access modules at runtime via address values.

## Addresses and Their Syntax

Addresses come in two flavors, named or numerical. The syntax for a named address follows the
same rules for any named identifier in Move. The syntax of a numerical address is not restricted
to hex-encoded values, and any valid [`u256` numerical value](/build/smart-contracts/book/integers) can be used as an
address value, e.g., `42`, `0xCAFE`, and `2021` are all valid numerical address
literals.

To distinguish when an address is being used in an expression context or not, the
syntax when using an address differs depending on the context where it's used:

- When an address is used as an expression the address must be prefixed by the `@` character, i.e., [`@<numerical_value>`](/build/smart-contracts/book/integers) or `@<named_address_identifier>`.
- Outside of expression contexts, the address may be written without the leading `@` character, i.e., [`<numerical_value>`](/build/smart-contracts/book/integers) or `<named_address_identifier>`.

In general, you can think of `@` as an operator that takes an address from being a namespace item to being an expression item.

## Named Addresses

Named addresses are a feature that allow identifiers to be used in place of
numerical values in any spot where addresses are used, and not just at the
value level. Named addresses are declared and bound as top level elements
(outside of modules and scripts) in Move Packages, or passed as arguments
to the Move compiler.

Named addresses only exist at the source language level and will be fully
substituted for their value at the bytecode level. Because of this, modules
and module members _must_ be accessed through the module's named address
and not through the numerical value assigned to the named address during
compilation, e.g., `use my_addr::foo` is _not_ equivalent to `use 0x2::foo`
even if the Move program is compiled with `my_addr` set to `0x2`. This
distinction is discussed in more detail in the section on [Modules and Scripts](/build/smart-contracts/book/modules-and-scripts).

### Examples

```move
script {
  fun example() {
    let a1: address = @0x1; // shorthand for 0x0000000000000000000000000000000000000000000000000000000000000001
    let a2: address = @0x42; // shorthand for 0x0000000000000000000000000000000000000000000000000000000000000042
    let a3: address = @0xDEADBEEF; // shorthand for 0x00000000000000000000000000000000000000000000000000000000DEADBEEF
    let a4: address = @0x000000000000000000000000000000000000000000000000000000000000000A;
    let a5: address = @std; // Assigns `a5` the value of the named address `std`
    let a6: address = @66;
    let a7: address = @0x42;
  }
}

module 66::some_module {   // Not in expression context, so no @ needed
    use 0x1::other_module; // Not in expression context so no @ needed
    use std::vector;       // Can use a named address as a namespace item when using other modules
    ...
}

module std::other_module {  // Can use a named address as a namespace item to declare a module
    ...
}
```

## Global Storage Operations

The primary purpose of `address` values are to interact with the global storage operations.

`address` values are used with the `exists`, `borrow_global`, `borrow_global_mut`, and `move_from` [operations](/build/smart-contracts/book/global-storage-operators).

The only global storage operation that _does not_ use `address` is `move_to`, which uses [`signer`](/build/smart-contracts/book/signer).

## Ownership

As with the other scalar values built-in to the language, `address` values are implicitly copyable, meaning they can be copied without an explicit instruction such as [`copy`](/build/smart-contracts/book/variables#move-and-copy).

# Bool

> Learn about bool in Move programming language for Aptos smart contract development.

`bool` is Move's primitive type for boolean `true` and `false` values.

## Literals

Literals for `bool` are either `true` or `false`.

## Operations

### Logical

`bool` supports three logical operations:

| Syntax | Description                  | Equivalent Expression                            |
| ------ | ---------------------------- | ------------------------------------------------ |
| `&&`   | short-circuiting logical and | `p && q` is equivalent to `if (p) q else false`  |
| `\|\|` | short-circuiting logical or  | `p \|\| q` is equivalent to `if (p) true else q` |
| `!`    | logical negation             | `!p` is equivalent to `if (p) false else true`   |

### Control Flow

`bool` values are used in several of Move's control-flow constructs:

- [`if (bool) { ... }`](/build/smart-contracts/book/conditionals)
- [`while (bool) { .. }`](/build/smart-contracts/book/loops)
- [`assert!(bool, u64)`](/build/smart-contracts/book/abort-and-assert)

## Ownership

As with the other scalar values built into the language, boolean values are implicitly copyable,
meaning they can be copied without an explicit instruction such as
[`copy`](/build/smart-contracts/book/variables#move-and-copy).

# Move Coding Conventions

> Follow Move coding conventions, style guidelines, and best practices for clean, maintainable smart contract code.

This section lays out some basic coding conventions for Move that the Move team has found helpful. These are only recommendations, and you should feel free to use other formatting guidelines and conventions if you have a preference for them.

## Naming

- **Module names**: should be lowercase snake case, e.g., `fixed_point32`, `vector`.
- **Type names**: should be camel case if they are not a native type, e.g., `Coin`, `RoleId`.
- **Function names**: should be lowercase snake case, e.g., `destroy_empty`.
- **Constant names**: should be upper camel case and begin with an `E` if they represent error codes (e.g., `EIndexOutOfBounds`) and upper snake case if they represent a non-error value (e.g., `MIN_STAKE`).
-
- **Generic type names**: should be descriptive, or anti-descriptive where appropriate, e.g., `T` or `Element` for the Vector generic type parameter. Most of the time the "main" type in a module should be the same name as the module e.g., `option::Option`, `fixed_point32::FixedPoint32`.
- **Module file names**: should be the same as the module name e.g., `option.move`.
- **Script file names**: should be lowercase snake case and should match the name of the "main" function in the script.
- **Mixed file names**: If the file contains multiple modules and/or scripts, the file name should be lowercase snake case, where the name does not match any particular module/script inside.

## Imports

- All module `use` statements should be at the top of the module.
- Functions should be imported and used fully qualified from the module in which they are declared, and not imported at the top level.
- Types should be imported at the top-level. Where there are name clashes, `as` should be used to rename the type locally as appropriate.

For example, if there is a module:

```move
module 0x1::foo {
  struct Foo { }
  const CONST_FOO: u64 = 0;
  public fun do_foo(): Foo { Foo{} }
  // ...
}
```

this would be imported and used as:

```move
module 0x1::bar {
  use 0x1::foo::{Self, Foo};

  public fun do_bar(x: u64): Foo {
    if (x == 10) {
      foo::do_foo()
    } else {
      abort 0
    }
  }
  // ...
}
```

And, if there is a local name-clash when importing two modules:

```move
module 0x1::other_foo {
  struct Foo {}
  // ...
}

module 0x1::importer {
  use 0x1::other_foo::Foo as OtherFoo;
  use 0x1::foo::Foo;
  // ...
}
```

## Comments

- Each module, struct, and public function declaration should be commented.
- Move has doc comments `///`, regular single-line comments `//`, block comments `/* */`, and block doc comments `/** */`.
- Starting Aptos CLI 7.4.0, UTF-8 characters are allowed in comments.

### Comments Example

Doc comments must be directly above the item they are commenting on. For example, the following is valid:

```move
/// My awesome module, doc comment can be used here
module 0x42::example { // double slash can be anywhere

  // Double slash can be anywhere

  /// My awesome constant
  const MY_VALUE: u64 = 5;

  /// My awesome error message
  const E_MY_ERROR: u64 = 10;

  #[view]
  /// My awesome view function
  fun show_me_the_money() {
    // ...
  }

  /* Similarly block comments can be anywhere */
}
```

Below here are examples of doc comments `///` that will fail

```move
module 0x42::example {

  /// My awesome view function <- must be below the annotation, right above the thing commented
  #[view]
  fun show_me_the_money() {
    // ...
    /// Within a function
  }

  /// Not attached to anything
}
```

## Formatting

The Move team plans to write an auto-formatter to enforce formatting conventions. However, in the meantime:

- Four space indentation should be used except for `script` and `address` blocks whose contents should not be indented.
- Lines should be broken if they are longer than 100 characters.
- Structs and constants should be declared before all functions in a module.

# Comparison

> Understand comparison operations and their semantics in Move programming language.

Move supports four comparison operations `<`, `>`, `<=`, and `>=`.

## Operations

| Syntax | Operation                |
| ------ | ------------------------ |
| `<`    | less than                |
| `>`    | greater than             |
| `<=`   | less than or equal to    |
| `>=`   | greater than or equal to |

### Typing

Comparison operations only work if both operands have the same type.

```move
script {
  fun example() {
    0 >= 0; // `true`
    1u128 > 2u128; // `false`
  }
}
```

If the operands have different types, there is a type checking error.

```move
script {
  fun example() {
    1u8 >= 1u128; // ERROR!
    //     ^^^^^ expected an argument of type `u8`
  }
}
```

Prior to language version 2.2, comparison operations only work with integer types. _Since language
version 2.2_, comparison operations work with all types.

| Type           | Semantics                                                                                                   |
| -------------- | ----------------------------------------------------------------------------------------------------------- |
| integer        | compare by the numerical value                                                                              |
| `bool`         | `true` being larger than `false`                                                                            |
| `address`      | compare as 256-bit unsigned integers                                                                        |
| `signer`       | compare by the `address` wrapped by the `signer`                                                            |
| `struct`       | compare by field values first, and then by the number of fields.                                            |
| `vector`       | compare by element values first, and then by the number of elements                                         |
| function value | compare in order by module address, module name, function name, argument type list, and captured value list |
| reference      | compare by the value being referenced                                                                       |

```move
module 0x42::example {
    struct S has copy, drop { f: u64, s: vector<u8> }

    fun true_example(): bool {
        let s1 = S { f: 0, s: b"" };
        let s2 = S { f: 1, s: b"" };
        // return true
        s1 < s2
    }

    fun false_example(): bool {
        let s1 = S { f: 0, s: b"abc" };
        let s2 = S { f: 0, s: b"" };
        // return false
        s1 < s2
    }
}
```

### Typing with references

When comparing [references](/build/smart-contracts/book/references), the values being referenced are compared. The type of the reference (immutable or mutable) does
not matter. This means that you can compare an immutable `&` reference with a mutable one `&mut` of
the same underlying type.

```move
script {
  fun example() {
    let i = &0u64;
    let m = &mut 1u64;

    i > m; // `false`
    m < i; // `false`
    m >= m; // `true`
    i <= i; // `true`
  }
}
```

The above is equivalent to applying an explicit freeze to each mutable reference where needed

```move
script {
  fun example() {
    let i = &0u64;
    let m = &mut 1u64;

    i > freeze(m); // `false`
    freeze(m) < i; // `false`
    m >= m; // `true`
    i <= i; // `true`
  }
}
```

But again, the underlying type must be the same.

```move
script {
  fun example() {
    let i = &0u64;
    let s = &b"";

    i > s; // ERROR!
    //   ^ expected an argument of type '&u64'
  }
}
```

## Comparing to `==` and `!=`

Comparison operations consume operands for integers but automatically borrow them for non-integer types.
This differs from the [equality `==` and inequality `!=`](/build/smart-contracts/book/equality#restrictions) operations, which always consume their operands
and mandate the [`drop` ability](/build/smart-contracts/book/abilities).

```move
module 0x42::example {
  struct Coin has store { value: u64 }
  fun invalid(c1: Coin, c2: Coin) {
    c1 <= c2 // OK!
    c1 == c2 // ERROR!
//  ^^    ^^ These resources would be destroyed!
  }
}
```

# Conditionals

> Learn conditional expressions and control flow patterns in Move with if-else statements and match expressions.

An `if` expression specifies that some code should only be evaluated if a certain condition is true. For example:

```move
script {
  fun example() {
    if (x > 5) x = x - 5
  }
}
```

The condition must be an expression of type `bool`.

An `if` expression can optionally include an `else` clause to specify another expression to evaluate when the condition is false.

```move
script {
  fun example() {
    if (y <= 10) y = y + 1 else y = 10
  }
}
```

Either the "true" branch or the "false" branch will be evaluated, but not both. Either branch can be a single expression or an expression block.

The conditional expressions may produce values so that the `if` expression has a result.

```move
script {
  fun example() {
    let z = if (x < 100) x else 100;
  }
}
```

The expressions in the true and false branches must have compatible types. For example:

```move
script {
  fun example() {
    // x and y must be u64 integers
    let maximum: u64 = if (x > y) x else y;

    // ERROR! branches different types
    let z = if (maximum < 10) 10u8 else 100u64;

    // ERROR! branches different types, as default false-branch is () not u64
    if (maximum >= 10) maximum;
  }
}
```

If the `else` clause is not specified, the false branch defaults to the unit value. The following are equivalent:

```move
script {
  fun example() {
    if (condition) true_branch // implied default: else ()
    if (condition) true_branch else ()
  }
}
```

Commonly, [`if` expressions](/build/smart-contracts/book/conditionals) are used in conjunction with expression blocks.

```move
script {
  fun example() {
    let maximum = if (x > y) x else y;
    if (maximum < 10) {
        x = x + 10;
        y = y + 10;
    } else if (x >= 10 && y >= 10) {
        x = x - 10;
        y = y - 10;
    }
  }
}

```

## Grammar for Conditionals

> _if-expression_ ‚Üí **if (** _expression_ **)** _expression_ _else-clause_<sub>_opt_</sub>

> _else-clause_ ‚Üí **else** _expression_

# Constants

> Learn about constants in Move programming language for Aptos smart contract development.

Constants are a way of giving a name to shared, static values inside of a `module` or `script`.

The constant's must be known at compilation. The constant's value is stored in the compiled module
or script. And each time the constant is used, a new copy of that value is made.

## Declaration

Constant declarations begin with the `const` keyword, followed by a name, a type, and a value. They
can exist in either a script or module

```text
const <name>: <type> = <expression>;
```

For example

```move
script {
  const MY_ERROR_CODE: u64 = 0;

  fun main(input: u64) {
    assert!(input > 0, MY_ERROR_CODE);
  }
}

module 0x42::example {
  const MY_ADDRESS: address = @0x42;

  public fun permissioned(s: &signer) {
    assert!(std::signer::address_of(s) == MY_ADDRESS, 0);
  }
}
```

## Naming

Constants must start with a capital letter `A` to `Z`. After the first letter, constant names can
contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, or digits `0` to `9`.

```move
script {
  const FLAG: bool = false;
  const MY_ERROR_CODE: u64 = 0;
  const ADDRESS_42: address = @0x42;
}
```

Even though you can use letters `a` to `z` in a constant. The
[general style guidelines](/build/smart-contracts/book/coding-conventions) are to use just uppercase letters `A` to `Z`,
with underscores `_` between each word.

This naming restriction of starting with `A` to `Z` is in place to give room for future language
features. It may or may not be removed later.

## Visibility

`public` constants are not currently supported. `const` values can be used only in the declaring
module.

## Valid Expressions

Currently, constants are limited to the primitive types `bool`, `u8`, `u16`, `u32`, `u64`, `u128`, `u256`, `address`, and
`vector<u8>`. Future support for other `vector` values (besides the "string"-style literals) will
come later.

### Values

Commonly, `const`s are assigned a simple value, or literal, of their type. For example

```move
script {
  const MY_BOOL: bool = false;
  const MY_ADDRESS: address = @0x70DD;
  const BYTES: vector<u8> = b"hello world";
  const HEX_BYTES: vector<u8> = x"DEADBEEF";
}
```

### Complex Expressions

In addition to literals, constants can include more complex expressions, as long as the compiler is
able to reduce the expression to a value at compile time.

Currently, equality operations, all boolean operations, all bitwise operations, and all arithmetic
operations can be used.

```move
script {
  const RULE: bool = true && false;
  const CAP: u64 = 10 * 100 + 1;
  const SHIFTY: u8 = {
    (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)
  };
  const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;
  const REM: u256 = 57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;
  const EQUAL: bool = 1 == 1;
}
```

If the operation results in a runtime exception, the compiler will give an error that it is
unable to generate the constant's value

```move
script {
  const DIV_BY_ZERO: u64 = 1 / 0; // error!
  const SHIFT_BY_A_LOT: u64 = 1 << 100; // error!
  const NEGATIVE_U64: u64 = 0 - 1; // error!
}
```

Note that constants cannot currently refer to other constants. This feature, along with support for
other expressions, will be added in the future.

## Builtin Constants

Builtin constants are predefined named values which can be used from anywhere in the code. The following constants are supported:

_since language version 2.2_

| Name                            | Value                                                |
| ------------------------------- | ---------------------------------------------------- |
| `__COMPILE_FOR_TESTING__: bool` | `true` when compiling unit tests, `false`  otherwise |

_since language version 2.3_

| Name             | Value               |
| ---------------- | ------------------- |
| `MAX_U8: u8`     | 2<sup>8</sup> - 1   |
| `MAX_U16: u16`   | 2<sup>16</sup> - 1  |
| `MAX_U32: u32`   | 2<sup>32</sup> - 1  |
| `MAX_U64: u64`   | 2<sup>64</sup> - 1  |
| `MAX_U128: u128` | 2<sup>128</sup> - 1 |
| `MAX_U256: u256` | 2<sup>256</sup> - 1 |
| `MAX_I8: i8`     | 2<sup>7</sup> - 1   |
| `MAX_I16: i16`   | 2<sup>15</sup> - 1  |
| `MAX_I32: i32`   | 2<sup>31</sup> - 1  |
| `MAX_I64: i64`   | 2<sup>63</sup> - 1  |
| `MAX_I128: i128` | 2<sup>127</sup> - 1 |
| `MAX_I256: i256` | 2<sup>255</sup> - 1 |
| `MIN_I8: i8`     | -2<sup>7</sup>      |
| `MIN_I16: i16`   | -2<sup>15</sup>     |
| `MIN_I32: i32`   | -2<sup>31</sup>     |
| `MIN_I64: i64`   | -2<sup>63</sup>     |
| `MIN_I128: i128` | -2<sup>127</sup>    |
| `MIN_I256: i256` | -2<sup>255</sup>    |

A builtin constant can be shadowed by a user declaration. For example, the below code is valid in language version 2.3, and the builtin constant will simply be shadowed:

```move
module 0x44::m {
   const MAX_U8: u8 = 255; // User defined constant shadowing builtin constant
}
```

# Enums

> Learn about enum types in Move for defining variant types, pattern matching, and type-safe state representation.

_Since language version 2.0_

Enum types are similar to struct types but support defining multiple _variants_ of the data layout. Each variant has its distinct set of fields. Enum variants are supported in expressions, tools for testing, matching, and deconstructing.

## Declaration of Enum Types

An enum type declaration lists the number of different variants, as seen in the example below:

```move
enum Shape {
    Circle{radius: u64},
    Rectangle{width: u64, height: u64}
}
```

There can be zero or more fields for an enum variant. If no arguments are given, the braces can also be omitted, declaring simple values:

```move
enum Color {
  Red, Blue, Green
}
```

Like struct types, enum types can have abilities. For example, the `Color` enum type would be appropriately declared as copyable, droppable, and storable, like primitive number types:

```move
enum Color has copy, drop, store, key { Red, Blue, Green }
```

Enum types can also have the `key` ability and appear as roots of data in global storage. A common usage of enums in this context is versioning of data:

```move
enum VersionedData has key {
  V1{name: String}
  V2{name: String, age: u64}
}
```

Similar to structs, enum types can be generic and take positional arguments. For example, the type below represents a generic result type, where the variant constructors use positional instead of named arguments (see also [positional structs](/build/smart-contracts/book/structs-and-resources#positional-structs)).

```move
enum Result<T> has copy, drop, store {
  Err(u64),
  Ok(T)
}
```

## Constructing Enum Values

An enum value is constructed similarly to a struct value:

```move
let s: String;
let data = VersionedData::V1{name: s};
```

If the enum variant has no fields, the braces can also be omitted:

```move
let color = Color::Blue;
```

## Name Resolution for Enum Variants

The variant names for an enum need to be qualified by the enum type name, as in `VersionedData::V1`.

> Note: Aliasing via the `use` clause is currently not supported for enum variants, but will be added in later language versions

In certain cases (such as match expressions, below), the Move compiler can infer the enum type from the context, and the qualification by the type name may be omitted:

```move
fun f(data: VersionedData) {
  match (data) { V1{..} => .., ..} // simple variant name OK
}
```

## Matching Enum Values

The value of an enum value can be inspected using a match expression. For example:

```move
fun area(self: &Shape): u64 {
    match (self) {
        Circle{radius}           => mul_with_pi(*radius * *radius),
        Rectangle{width, height} => *width * *height
    }
}
```

Notice above that the value matched is an immutable reference to an enum value. A match expression can also consume a value, or match over a mutable reference for interior updates:

```move
fun scale_radius(self: &mut Shape, factor:  u64) {
    match (self) {
        Circle{radius: r} => *r = *r * factor,
        _                 => {} // do nothing if not a Circle
  }
}
```

The patterns provided in the match expression are evaluated sequentially, in order of textual occurrence, until a match is found. It is a compile time error if not all known patterns are covered.

Patterns can be nested and contain conditions, as in the following example:

```move
let r : Result<Result<u64>> = Ok(Err(42));
let v = match (r) {
  Ok(Err(c)) if c < 42  => 0,
  Ok(Err(c)) if c >= 42 => 1,
  Ok(_)                 => 2,
  _                     => 3
};
assert!(v == 1);
```

Notice that in the above example, the last match clause (`_`) covers both patterns `Ok(Err(_))` and `Err(_)`.  Although at execution time, the earlier clauses match `Ok(Err(c))` for all values of `c`, the compiler cannot be sure all cases are covered due to the conditionals: conditions in match expressions are not considered when tracking coverage.  Thus the first two clauses in the match expression above are not sufficient for match completeness, and an additional clause is required to avoid a compiler error.

## Testing Enum Variants

With the `is` operator, one can examine whether a given enum value is of a given variant:

```move
let data: VersionedData;
if (data is VersionedData::V1) { .. }
```

The operator allows specifying a list of variants, separated by "`|`" characters. The variants need not be qualified by the enum name if the type of the expression being tested is known:

```move
assert!(data is V1|V2);
```

## Selecting From Enum Values

It is possible to directly select a field from an enum value. Recall the definition of versioned data:

```move
enum VersionedData has key {
  V1{name: String}
  V2{name: String, age: u64}
}
```

One can write code as below to directly select the fields of variants:

```move
let s: String;
let data1 = VersionedData::V1{name: s};
let data2 = VersionedData::V2{name: s, age: 20};
assert!(data1.name == data2.name)
assert!(data2.age == 20);
```

Notice that field selection aborts if the enum value has no variant with the given field. This is the case for  `data1.age`.
The abort code used for this case is `0xCA26CBD9BE0B0001`. In terms of the `std::error` convention, this code has
category `std::error::INTERNAL` and reason `1`.

Field selection is only possible if the field is uniquely named and typed throughout all variants. Thus, the following yields a compile time error:

```move
enum VersionedData has key {
  V1{name: String}
  V2{name: u64}
}

data.name
 // ^^^^^ compile time error that `name` field selection is ambiguous
```

## Using Enums Patterns in Lets

An enum variant pattern may be used in a `let` statement:

```move
let data: VersionData;
let V1{name} = data;
```

Unpacking the enum value will abort if the variant is not the expected one. To ensure that all variants of an enum are handled, a `match` expression is recommended instead of a `let`. The `match` is checked at compile time, ensuring that all variants are covered. In some cases, tools like the Move Prover can be used to verify that unexpected aborts cannot happen with a `let`.

## Destroying Enums via Pattern Matching

Similar to struct values, enum values can be destroyed by explicitly unpacking them. Enums can be unpacked with pattern matching in a `match` expression, enum pattern in a `let` binding, or enum pattern in an assignment.

```move
// Note: `Shape` has no `drop` ability, so must be destroyed with explicit unpacking.
enum Shape {
    Circle{radius: u64},
    Rectangle{width: u64, height: u64}
}

fun destroy_empty(self: Shape) {
    match (self) {
        Shape::Circle{radius} => assert!(radius == 0),
        Shape::Rectangle{width, height: _} => assert!(width == 0),
    }
}

fun example_destroy_shapes() {
    let c = Shape::Circle{radius: 0};
    let r = Shape::Rectangle{width: 0, height: 0};
    c.destroy_empty();
    r.destroy_empty();
}
```

## Enum Type Upgrade Compatibility

An enum type can be upgraded by another enum type if the new type only adds new variants at the end of the variant list. All variants present in the old enum type must also appear in the new type, in the same order and starting from the beginning. Consider the `VersionedData` type, which might have begun with a single version:

```move
enum VersionedData has key {
  V1{name: String}
}
```

This type could be upgraded to the version we used so far in this text:

```move
enum VersionedData has key {
  V1{name: String}
  V2{name: String, age: u64}
}
```

The following upgrade would not be allowed, since the order of variants must be preserved:

```move
enum VersionedData has key {
  V2{name: String, age: u64}   // not a compatible upgrade
  V1{name: String}
}
```

# Equality

> Understand equality operations, comparison semantics, and type checking in Move programming language.

Move supports two equality operations `==` and `!=`

## Operations

| Syntax | Operation | Description                                                                 |
| ------ | --------- | --------------------------------------------------------------------------- |
| `==`   | equal     | Returns `true` if the two operands have the same value, `false` otherwise   |
| `!=`   | not equal | Returns `true` if the two operands have different values, `false` otherwise |

### Typing

Both the equal (`==`) and not-equal (`!=`) operations only work if both operands are the same type

```move
script {
  fun example() {
    0 == 0; // `true`
    1u128 == 2u128; // `false`
    b"hello" != x"00"; // `true`
  }
}
```

Equality and non-equality also work over user defined types!

```move
module 0x42::example {
    struct S has copy, drop { f: u64, s: vector<u8> }

    fun always_true(): bool {
        let s = S { f: 0, s: b"" };
        // parens are not needed but added for clarity in this example
        (copy s) == s
    }

    fun always_false(): bool {
        let s = S { f: 0, s: b"" };
        // parens are not needed but added for clarity in this example
        (copy s) != s
    }
}
```

If the operands have different types, there is a type checking error

```move
script {
  fun example() {
    1u8 == 1u128; // ERROR!
    //     ^^^^^ expected an argument of type 'u8'
    b"" != 0; // ERROR!
    //     ^ expected an argument of type 'vector<u8>'
  }
}
```

### Typing with references

When comparing [references](/build/smart-contracts/book/references), the type of the reference (immutable or mutable) does
not matter. This means that you can compare an immutable `&` reference with a mutable one `&mut` of
the same underlying type.

```move
script {
  fun example() {
    let i = &0;
    let m = &mut 1;

    i == m; // `false`
    m == i; // `false`
    m == m; // `true`
    i == i; // `true`
  }
}
```

The above is equivalent to applying an explicit freeze to each mutable reference where needed

```move
script {
  fun example() {
    let i = &0;
    let m = &mut 1;

    i == freeze(m); // `false`
    freeze(m) == i; // `false`
    m == m; // `true`
    i == i; // `true`
  }
}
```

But again, the underlying type must be the same type

```move
script {
  fun example() {
    let i = &0;
    let s = &b"";

    i == s; // ERROR!
    //   ^ expected an argument of type '&u64'
  }
}
```

## Restrictions

Both `==` and `!=` consume the value when comparing them. As a result, the type system enforces that
the type must have [`drop`](/build/smart-contracts/book/abilities). Recall that without the
[`drop` ability](/build/smart-contracts/book/abilities), ownership must be transferred by the end of the function, and such
values can only be explicitly destroyed within their declaring module. If these were used directly
with either equality `==` or non-equality `!=`, the value would be destroyed which would break
[`drop` ability](/build/smart-contracts/book/abilities) safety guarantees!

```move
module 0x42::example {
  struct Coin has store { value: u64 }
  fun invalid(c1: Coin, c2: Coin) {
    c1 == c2 // ERROR!
//  ^^    ^^ These resources would be destroyed!
  }
}
```

But, a programmer can _always_ borrow the value first instead of directly comparing the value, and
reference types have the [`drop` ability](/build/smart-contracts/book/abilities). For example

```move
module 0x42::example {
  struct Coin has store { value: u64 }
  fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {
    let are_equal = &c1 == &c2; // valid
    if (are_equal) (c2, c1) else (c1, c2)
  }
}
```

## Avoid Extra Copies

While a programmer _can_ compare any value whose type has [`drop`](/build/smart-contracts/book/abilities), a programmer
should often compare by reference to avoid expensive copies.

```move
script {
  fun example() {
    let v1: vector<u8> = function_that_returns_vector();
    let v2: vector<u8> = function_that_returns_vector();
    assert!(copy v1 == copy v2, 42);
    //     ^^^^       ^^^^
    use_two_vectors(v1, v2);

    let s1: Foo = function_that_returns_large_struct();
    let s2: Foo = function_that_returns_large_struct();
    assert!(copy s1 == copy s2, 42);
    //     ^^^^       ^^^^
    use_two_foos(s1, s2);
  }
}
```

This code is perfectly acceptable (assuming `Foo` has [`drop`](/build/smart-contracts/book/abilities)), just not efficient.
The highlighted copies can be removed and replaced with borrows

```move
script {
  fun example() {
    let v1: vector<u8> = function_that_returns_vector();
    let v2: vector<u8> = function_that_returns_vector();
    assert!(&v1 == &v2, 42);
    //     ^      ^
    use_two_vectors(v1, v2);

    let s1: Foo = function_that_returns_large_struct();
    let s2: Foo = function_that_returns_large_struct();
    assert!(&s1 == &s2, 42);
    //     ^      ^
    use_two_foos(s1, s2);
  }
}
```

The efficiency of the `==` itself remains the same, but the `copy`s are removed and thus the program
is more efficient.

# Friends

> Learn about friend functions in Move for controlled access to internal module functionality and secure interfaces.

The `friend` syntax is used to declare modules that are trusted by the current module.
A trusted module is allowed to call any function defined in the current module that have the `public(friend)` visibility.
For details on function visibilities, please refer to the _Visibility_ section in [Functions](/build/smart-contracts/book/functions).

## Friend declaration

A module can declare other modules as friends via friend declaration statements, in the format of

- `friend <address::name>` ‚Äî friend declaration using fully qualified module name like the example below, or

  ```move
  module 0x42::a {
      friend 0x42::b;
  }
  ```

- `friend <module-name-alias>` ‚Äî friend declaration using a module name alias, where the module alias is introduced via the `use` statement.

  ```move
  module 0x42::a {
      use 0x42::b;
      friend b;
  }
  ```

A module may have multiple friend declarations, and the union of all the friend modules forms the friend list.
In the example below, both `0x42::B` and `0x42::C` are considered as friends of `0x42::A`.

```move
module 0x42::a {
    friend 0x42::b;
    friend 0x42::c;
}
```

Unlike `use` statements, `friend` can only be declared in the module scope and not in the expression block scope.
`friend` declarations may be located anywhere a top-level construct (e.g., `use`, `function`, `struct`, etc.) is allowed.
However, for readability, it is advised to place friend declarations near the beginning of the module definition.

Note that the concept of friendship does not apply to Move scripts:

- A Move script cannot declare `friend` modules as doing so is considered meaningless: there is no mechanism to call the function defined in a script.
- A Move module cannot declare `friend` scripts as well because scripts are ephemeral code snippets that are never published to global storage.

### Friend declaration rules

Friend declarations are subject to the following rules:

- A module cannot declare itself as a friend.

  ```move
  module 0x42::m {
    friend Self; // ERROR!
  //       ^^^^ Cannot declare the module itself as a friend
  }

  module 0x43::m {
    friend 0x43::M; // ERROR
  //       ^^^^^^^ Cannot declare the module itself as a friend
  }
  ```

- Friend modules must be known by the compiler

  ```move
  module 0x42::m {
    friend 0x42::nonexistent; // ERROR!
    //     ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'
  }
  ```

- Friend modules must be within the same account address. (Note: this is not a technical requirement but rather a policy decision which _may_ be relaxed later.)

  ```move
  module 0x42::m {}

  module 0x43::n {
    friend 0x42::m; // ERROR!
  //       ^^^^^^^ Cannot declare modules out of the current address as a friend
  }
  ```

- Friends relationships cannot create cyclic module dependencies.

  Cycles are not allowed in the friend relationships, e.g., the relation `0x2::a` friends `0x2::b` friends `0x2::c` friends `0x2::a` is not allowed.
  More generally, declaring a friend module adds a dependency upon the current module to the friend module (because the purpose is for the friend to call functions in the current module).
  If that friend module is already used, either directly or transitively, a cycle of dependencies would be created.

  ```move
  address 0x2 {
    module a {
      use 0x2::c;
      friend 0x2::b;

      public fun a() {
        c::c()
      }
    }

    module b {
      friend 0x2::c; // ERROR!
    //       ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'
    }

    module c {
      public fun c() {}
    }
  }
  ```

- The friend list for a module cannot contain duplicates.

  ```move
  address 0x42 {
    module a {}

    module m {
      use 0x42::a as aliased_a;
      friend 0x42::A;
      friend aliased_a; // ERROR!
    //       ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique
    }
  }
  ```

# Functions

> Learn about functions in Move programming language for Aptos smart contract development.

import { Aside } from '@astrojs/starlight/components';

Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.

## Declaration

Functions are declared with the `fun` keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.

```text
fun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <acquires [identifier],*> <function_body>
```

For example

```move
fun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
```

### Visibility

Module functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.

```move
address 0x42 {
module m {
    fun foo(): u64 { 0 }

    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
        //       ^^^^^ `foo` is internal to `0x42::m`
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
        //       ^^^^^ `foo` is internal to `0x42::m`
    }
}
```

To allow access from other modules or from scripts, the function must be declared `public` or `public(friend)`.

#### `public` visibility

A `public` function can be called by _any_ function defined in _any_ module or script. As shown in the following example, a `public` function can be called by:

- other functions defined in the same module,
- functions defined in another module, or
- the function defined in a script.

There are also no restrictions for what the argument types a public function can take and its return type.

```move
address 0x42 {
module m {
    public fun foo(): u64 { 0 }

    fun calls_foo(): u64 { foo() } // valid
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
```

### `package` visibility

_Since Language Version 2.0_

A `package` function can be only called within the same package. The notion of a package is
defined by the hosting environment of Move, and not explicit in the language. Typically, the package
is defined by a manifest file `Move.toml` which is processed by the build environment.

The following works, provided the two modules belong to the same package and are at the same address:

```move
module 0x42::m {
  package fun foo(): u64 { 0 }
}

module 0x42::other {
  fun calls_m_foo(): u64 {
    0x42::m::foo() // valid
  }
}
```

An attempt to access `0x42::m::foo` from another package will fail at compile time.

In addition to the notation `package fun`, also the longer notation `public(package) fun` is supported.

Notice that package visibility is a compile time concept which is reduced by the compiler to friend visibility (described [below](#friend-visibility)), which can be verified by the Move VM. The Move VM guarantees that friend functions
cannot be called across address boundaries, independent of what package system a compilation environment supports.

#### `public(friend)` visibility

_Since Language Version 2.0_, `friend fun` replaces `public(friend) fun`. The old notation is still supported.

The `public(friend)` visibility modifier is a more restricted form of the `public` modifier to give more control about where a function can be used. A `public(friend)` function can be called by:

- other functions defined in the same module, or
- functions defined in modules which are explicitly specified in the **friend list** (see [Friends](/build/smart-contracts/book/friends) on how to specify the friend list), and which reside at the same address.

Note that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a `public(friend)` function.

```move
address 0x42 {
module m {
    friend 0x42::n;  // friend declaration
    public(friend) fun foo(): u64 { 0 }
    friend fun foo2(): u64 { 0 } // Since Move 2.0

    fun calls_foo(): u64 { foo() } // valid
    fun calls_foo2(): u64 { foo2() } // valid, since Move 2.0
}

module n {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }

    fun calls_m_foo2(): u64 {
        0x42::m::foo2() // valid, since Move 2.0
    }
}

module other {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
        //       ^^^^^ `foo` can only be called from a `friend` of module `0x42::m`
    }

    fun calls_m_foo2(): u64 {
        0x42::m::foo2() // ERROR!
        //       ^^^^^^ `foo2` can only be called from a `friend` of module `0x42::m`
    }
}
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
        //       ^^^^^ `foo` can only be called from a `friend` of module `0x42::m`
    }
}
```

### `entry` modifier

The `entry` modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be invoked to begin execution. The module writer then knows that any non-`entry` function will be called from a Move program already in execution.

Essentially, `entry` functions are the "main" functions of a module, and they specify where Move programs start executing.

Note though, an `entry` function _can_ still be called by other Move functions. So while they _can_ serve as the start of a Move program, they aren't restricted to that case.

For example:

```move
address 0x42 {
module m {
    public entry fun foo() {}

    fun calls_foo() { foo(); } // valid!
}

module n {
    fun calls_m_foo() {
        0x42::m::foo(); // valid!
    }
}

module other {
    public entry fun calls_m_foo() {
        0x42::m::foo(); // valid!
    }
}
}

script {
    fun calls_m_foo() {
        0x42::m::foo(); // valid!
    }
}
```

Even internal functions can be marked as `entry`! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)

```move
address 0x42 {
module m {
    entry fun foo() {} // valid! entry functions do not have to be public
}

module n {
    fun calls_m_foo() {
        0x42::m::foo(); // ERROR!
        //       ^^^^^ `foo` is internal to `0x42::m`
    }
}

module other {
    public entry fun calls_m_foo() {
        0x42::m::foo(); // ERROR!
        //       ^^^^^ `foo` is internal to `0x42::m`
    }
}
}

script {
    fun calls_m_foo() {
        0x42::m::foo(); // ERROR!
        //       ^^^^^ `foo` is internal to `0x42::m`
    }
}
```

Entry functions can accept parameters that are: primitive types, reference to a
`signer`, vectors (where the element type is itself acceptable),
and certain standard library types such as `String`, `Object`, and `Option`.
Entry functions must not have any return values.

### Name

Function names can start with letters `a` to `z` or letters `A` to `Z`. After the first character, function names can contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, or digits `0` to `9`.

```move
module 0x42::example {
    // all valid
    fun FOO() {}

    fun bar_42() {}

    fun bAZ19() {}

    // invalid
    fun _bAZ19() {} // Function names cannot start with '_'
}
```

### Type Parameters

After the name, functions can have type parameters

```move
module 0x42::example {
    fun id<T>(x: T): T { x }

    fun example<T1: copy, T2>(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
}
```

For more details, see [Move generics](/build/smart-contracts/book/generics).

### Parameters

Functions parameters are declared with a local variable name followed by a type annotation

```move
module 0x42::example {
    fun add(x: u64, y: u64): u64 { x + y }
}
```

We read this as `x` has type `u64`

A function does not have to have any parameters at all.

```move
module 0x42::example {
    fun useless() {}
}
```

This is very common for functions that create new or empty data structures

```move
module 0x42::example {
    struct Counter { count: u64 }

    fun new_counter(): Counter {
        Counter { count: 0 }
    }
}
```

### Acquires

When a function accesses a resource using `move_from`, `borrow_global`, or `borrow_global_mut`, the function must indicate that it `acquires` that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.

```move
module 0x42::example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from<Balance>(addr); // acquires needed
        value
    }
}
```

`acquires` annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.

```move
module 0x42::example {

    struct Balance has key { value: u64 }

    public fun add_balance(s: &signer, value: u64) {
        move_to(s, Balance { value })
    }

    public fun extract_balance(addr: address): u64 acquires Balance {
        let Balance { value } = move_from<Balance>(addr); // acquires needed
        value
    }

    public fun extract_and_add(sender: address, receiver: &signer) acquires Balance {
        let value = extract_balance(sender); // acquires needed here
        add_balance(receiver, value)
    }
}

module 0x42::other {
    fun extract_balance(addr: address): u64 {
        0x42::example::extract_balance(addr) // no acquires needed
    }
}
```

A function can `acquire` as many resources as it needs to

```move
module 0x42::example {
    use std::vector;

    struct Balance has key { value: u64 }

    struct Box<T> has key { items: vector<T> }

    public fun store_two<Item1: store, Item2: store>(
        addr: address,
        item1: Item1,
        item2: Item2,
    ) acquires Balance, Box {
        let balance = borrow_global_mut<Balance>(addr); // acquires needed
        balance.value = balance.value - 2;
        let box1 = borrow_global_mut<Box<Item1>>(addr); // acquires needed
        vector::push_back(&mut box1.items, item1);
        let box2 = borrow_global_mut<Box<Item2>>(addr); // acquires needed
        vector::push_back(&mut box2.items, item2);
    }
}
```

### Return type

After the parameters, a function specifies its return type.

```move
module 0x42::example {
    fun zero(): u64 { 0 }
}
```

Here `: u64` indicates that the function's return type is `u64`.

<Aside type="note">
  A function can return an immutable `&` or mutable `&mut` [reference](/build/smart-contracts/book/references) if derived from an input reference. Keep in mind, this means that a function [cannot return a reference to global storage](/build/smart-contracts/book/references#references-cannot-be-stored) unless it is an [inline function](#inline-functions).
</Aside>

Using tuples, a function can return multiple values:

```move
module 0x42::example {
    fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
}
```

If no return type is specified, the function has an implicit return type of unit `()`. These functions are equivalent:

```move
module 0x42::example {
    fun just_unit1(): () { () }

    fun just_unit2() { () }

    fun just_unit3() {}
}
```

`script` functions must have a return type of unit `()`:

```move
script {
    fun do_nothing() {}
}
```

As mentioned in the [tuples section](/build/smart-contracts/book/tuples), these tuple "values" are virtual and do not exist at runtime. So for a function that returns unit `()`, it will not be returning any value at all during execution.

### Function body

A function's body is an expression block. The return value of the function is the last value in the sequence

```move
module 0x42::example {
    fun example(): u64 {
        let x = 0;
        x = x + 1;
        x // returns 'x'
    }
}
```

See [the section below for more information on returns](#returning-values)

For more information on expression blocks, see [Move variables](/build/smart-contracts/book/variables).

### Native Functions

Some functions do not have a body specified, and instead have the body provided by the VM. These functions are marked `native`.

Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that `native` functions are used for either standard library code or for functionality needed for the given Move environment.

Most `native` functions you will likely see are in standard library code such as `vector`

```move
module std::vector {
    native public fun empty<Element>(): vector<Element>;
    // ...
}
```

## Calling

When calling a function, the name can be specified either through an alias or fully qualified

```move
module 0x42::example {
    public fun zero(): u64 { 0 }
}

script {
    use 0x42::example::{Self, zero};

    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        0x42::example::zero();
        example::zero();
        zero();
    }
}
```

When calling a function, an argument must be given for every parameter.

```move
module 0x42::example {
    public fun takes_none(): u64 { 0 }

    public fun takes_one(x: u64): u64 { x }

    public fun takes_two(x: u64, y: u64): u64 { x + y }

    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
}

script {
    use 0x42::example;

    fun call_all() {
        example::takes_none();
        example::takes_one(0);
        example::takes_two(0, 1);
        example::takes_three(0, 1, 2);
    }
}
```

Type arguments can be either specified or inferred. Both calls are equivalent.

```move
module 0x42::example {
    public fun id<T>(x: T): T { x }
}

script {
    use 0x42::example;

    fun call_all() {
        example::id(0);
        example::id<u64>(0);
    }
}
```

For more details, see [Move generics](/build/smart-contracts/book/generics).

## Returning values

The result of a function, its "return value", is the final value of its function body. For example

```move
module 0x42::example {
    fun add(x: u64, y: u64): u64 {
        x + y
    }
}
```

[As mentioned above](#function-body), the function's body is an [expression block](/build/smart-contracts/book/variables). The expression block can be a sequence of various statements, and the final expression in the block will be the value of that block.

```move
module 0x42::example {
    fun double_and_add(x: u64, y: u64): u64 {
        let double_x = x * 2;
        let double_y = y * 2;
        double_x + double_y
    }
}
```

The return value here is `double_x + double_y`

### `return` expression

A function implicitly returns the value that its body evaluates to. However, functions can also use the explicit `return` expression:

```move
module 0x42::example {
    fun f1(): u64 { return 0 }

    fun f2(): u64 { 0 }
}
```

These two functions are equivalent. In this slightly more involved example, the function subtracts two `u64` values, but returns early with `0` if the second value is too large:

```move
module 0x42::example {
    fun safe_sub(x: u64, y: u64): u64 {
        if (y > x) return 0;
        x - y
    }
}
```

Note that the body of this function could also have been written as `if (y > x) 0 else x - y`.

However, where `return` really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:

```move
module 0x42::example {
    use std::vector;
    use std::option::{Self, Option};

    fun index_of<T>(v: &vector<T>, target: &T): Option<u64> {
        let i = 0;
        let n = vector::length(v);
        while (i < n) {
            if (vector::borrow(v, i) == target) return option::some(i);
            i = i + 1
        };

        option::none()
    }
}
```

Using `return` without an argument is shorthand for `return ()`. That is, the following two functions are equivalent:

```move
module 0x42::example {
    fun foo1() { return }

    fun foo2() { return () }
}
```

## Inline Functions

Inline functions are functions whose bodies are expanded in place at the caller location during compile time.
Thus, inline functions do not appear in Move bytecode as a separate functions: all calls to them are expanded away by the compiler.
In certain circumstances, they may lead to faster execution and save gas.
However, users should be aware that they could lead to larger bytecode size: excessive inlining potentially triggers various size restrictions.

One can define an inline function by adding the `inline` keyword to a function declaration as shown below:

```move
module 0x42::example {
    inline fun percent(x: u64, y: u64): u64 { x * 100 / y }
}
```

If we call this inline function as `percent(2, 200)`, the compiler will replace this call with the inline function's body, as if the user has written `2 * 100 / 200`.

### Function parameters and lambda expressions

Inline functions support _function parameters_, which accept lambda expressions (i.e., anonymous functions) as arguments.
This feature allows writing several common programming patterns elegantly.
Similar to inline functions, lambda expressions are also expanded at call site.

A lambda expression includes a list of parameter names (enclosed within `||`) followed by the body.
Some simple examples are: `|x| x + 1`, `|x, y| x + y`, `|| 1`, `|| { 1 }`.
A lambda's body can refer to variables available in the scope where the lambda is defined: this is also known as capturing.
Such variables can be read or written (if mutable) by the lambda expression.

The type of function parameter is written as `|<list of parameter types>| <return type>`.
For example, when the function parameter type is `|u64, u64| bool`, any lambda expression that takes two `u64` parameters and returns a `bool` value can be provided as the argument.

Below is an example that showcases many of these concepts in action (this example is taken from the `std::vector` module):

```move
module 0x42::example {
    /// Fold the function over the elements.
    /// E.g, `fold(vector[1,2,3], 0, f)` is the same as `f(f(f(0, 1), 2), 3)`.
    public inline fun fold<Accumulator, Element>(
        v: vector<Element>,
        init: Accumulator,
        f: |Accumulator, Element|Accumulator
    ): Accumulator {
        let accu = init;
        // Note: `for_each` is an inline function, but is not shown here.
        for_each(v, |elem| accu = f(accu, elem));
        accu
    }
}
```

The type signature of the elided public inline function `for_each` is `fun for_each<Element>(v: vector<Element>, f: |Element|)`.
Its second parameter `f` is a function parameter which accepts any lambda expression that consumes an `Element` and returns nothing.
In the code example, we use the lambda expression `|elem| accu = f(accu, elem)` as an argument to this function parameter.
Note that this lambda expression captures the variable `accu` from the outer scope.

### Current restrictions

There are plans to loosen some of these restrictions in the future, but for now,

- Only inline functions can have function parameters.
- Only explicit lambda expressions can be passed as an argument to an inline function's function parameters.
- Inline functions and lambda expressions
  - cannot have `return` expressions; or free `break` or `continue` expressions (occurring outside of a loop)
  - cannot return lambda expressions.
- Cyclic recursion involving only inline functions is not allowed.
- Parameters in lambda expressions must not be type annotated (e.g., `|x: u64| x + 1` is not allowed): their types are inferred.

### Additional considerations

- Avoid using module-private constants/methods in public inline functions.
  When such inline functions are called outside of that module, an in-place expansion at call site leads to invalid access of the private constants/methods.
- Avoid marking large functions that are called at different locations as inline. Also avoid inline functions calling lots of other inline functions transitively.
  These may lead to excessive inlining and increase the bytecode size.
- Inline functions can be useful for returning references to global storage, which non-inline functions cannot do.

### Inline functions and references

As mentioned briefly [in a "tip" above](#return-type) `inline` functions can use references more freely than normal functions.

For example, actual arguments to a call to a non-`inline` function may not be aliased unsafely
(multiple `&` parameters referring to the same object, with at least one of them `&mut`),
but calls to `inline` functions do not necessarily have that restriction, as long as no reference
usage conflicts remain after the function is inlined.

```move
inline fun add(dest: &mut u64, a: &u64, b: &u64) {
    *dest = *a + *b;
}

fun user(...) {
    ...
    x = 3;
    add(&mut x, &x, &x);  // legal only because of inlining
    ...
}
```

A reference-typed value returned from a non-inline function must be derived from a reference parameter
passed to the function, but this need not be the case for an inline function, as long as the referred
value is in the function scope after inlining.

The exact details of reference safety and "borrow checking" are complex and documented elsewhere.
Advanced Move users find new expressiveness by understanding that
"borrow checking" happens only after all `inline` function calls are expanded.

However, with this power comes new responsibility: documentation of a nontrivial `inline` function should
probably explain any underlying restrictions on reference parameters and results at a call site.

## Dot (receiver) function call style

_Since language version 2.0_

By using the well-known name `self` as the first parameter for a function declaration, one can enable calling this function with the `.` syntax -- often also called receiver style syntax. Example:

```move
module 0x42::example {
    struct S {}

    fun foo(self: &S, x: u64) { /* ... */ }

    //...

    fun example() {
        let s = S {};
        s.foo(1);
    }
}
```

The call `s.foo(1)` is syntactic sugar for `foo(&s, 1)`. Notice that the compiler automatically inserts the reference operator. The 2nd, old notation is still available for `foo`, so one can incrementally introduce the new call style without breaking existing code.

The type of the `self` argument can be a struct or an immutable or mutable reference to a struct. The struct must be declared in the same module as the function.

Notice that you do not need to `use` the modules which introduce receiver functions. The compiler will find those functions automatically based on the argument type of `s` in a call like `s.foo(1)`. This, in combination with the automatic insertion of reference operators, can make code using this syntax significantly more concise.

The receiver style syntax can also be used on generic functions, like shown below for the generic function `std::vector::remove<T>(self: &mut vector<T>, i: u64): T`.

```move
module 0x42::example {
   fun bar() {
       let v = vector[1, 2, 3];
       let e1 = v.remove(0); // type params inferred for `remove<T>`
       assert!(e1 == 1);
       let e2 = v.remove::<u8>(0); // type params explicitly specified
       assert!(e2 == 2);
   }
}
```

## Function Values

_Since language version 2.2_

Move supports _function values_ as first-class citizen of the language. A function value is constructed from the name of a function or by a lambda expression, and is evaluated by passing parameters to it and causing the underlying function to be executed. This feature is often also called _dynamic dispatch_. Which concrete function is called, is not known to the caller, and determined from the runtime value. Dynamic dispatch is an important tool for composing applications. Move makes dynamic dispatch safe by providing builtin protection mechanisms against reentrancy, which can be further refined by user choice.

### Function Types

The type of functions values is already known from [inline functions](#function-parameters-and-lambda-expressions). A function type is denoted, for example, as `|u64|bool`, indicating a function which takes a number and returns a boolean. Lists of types are separated by comma, as in `|u64, bool|(bool,u4)`.

Function types can have associated abilities, written as `|u64|bool has copy`. Multiple abilities are separated by plus, as in `|u64|bool has copy+drop`. If no abilities are provided, the value can be only moved around and evaluated (for evaluation of function values, see [below](#function-evaluation)).

Function values can be stored in fields of structs or enums. In this case, the field type inherits the abilities of the struct:

```move
struct S has key {
  func: |u64| bool /* has store */  // not needed since inherited
}
```

### Operations on Functions

A function value is evaluated by providing the corresponding number of parameters, similar as when calling a named function. During evaluation, the function value is _consumed_. Hence if the value needs to be evaluated multiple times, its type must have the `copy` ability:

```move
let f: |u64|bool has copy = |x| x > 0;
assert!(f(1) == f(2))
```

Function values support equality and ordering. Note that those relations are based on the name of the underlying function behind a runtime value, and do not reflect semantic equivalence.

### Function Type Wrappers

Function types, specifically if they come together with abilities, can be verbose, and if the same type of function type is used many times in the code, repetitive. For this purpose, Move recognizes struct wrappers around function types as a special case. They can be used to effectively create named function types:

```move
struct Predicate<T>(|&T|bool) has copy;
```

Move supports this feature by automatically converting function values into the wrapper type and vice versa. Examples:

```move
let f: Predicate<u64> = |x| *x > 0; // lambda converts to Predicate
assert!(f(&22)) // Predicate callable
```

### Denoting Function Values

Function values can be constructed by directly using a function name. The resulting function type is derived from the signature of the underlying function, with abilities `copy+drop`. If the function is public, those function values have the `store` ability as well:

```move
public fun is_even(x: u64): bool { x % 2 == 0 }
fun is_odd(x: u64): bool { x % 2 == 1 }
...
let f: |u64|bool has copy+drop+store = is_even;
let g: |u64|bool has copy+drop = is_odd;
```

A _persistent_ function is required to build a storable function value because it needs to be guaranteed that the underlying function exists and can be safely restored from storage at any point in the future. However, code upgrade may change the underlying implementation of the function, while its signature is persistent.

While `public` and `entry` functions are persistent by default, a non-public function needs to be marked with the attribute `#[persistent]` to become storable:

```move
#[persistent] fun is_odd(x: u64): bool { x % 2 == 1 }
...
let g: |u64|bool has copy+drop+store = is_odd;
```

Using the `#[persistent]` attribute is preferred if the only objective is to make a function storable, avoiding security implications with public or entry visibility.

### Lambda Expressions and Closures

Function values can be denoted by _lambda expressions_ (as also available as parameters for [inline functions](#function-parameters-and-lambda-expressions)). Lambda expressions can capture context variables _by value_: those values are moved (or copied) into a _closure_, from where they are produced when the function is evaluated. Examples:

```move
struct S(u64); // cannot be copied or dropped
...
let s = S(1);
let add = |y| { let S(x) = s; x + y }; // s will be moved into the closure
assert!(add(2) == 3)
```

Closures with captured values are lexicographical ordered using first the name of the underlying function (which maybe generated from lambda lifting), and then the captured values.

The type of the closure constructed by a lambda expression is inferred from the expression (for example, the type of `add` in the example above is inferred as `|u64|u64`). The abilities of this function type are derived as follows. By default, the function underlying a closure is a private function, so the function itself is `copy+drop` (and not `store`). This is intersected with the abilities of all the captured context variables. However, there is a special case for lambdas where instead of a private function an underlying persistent function can be identified, such that the lambda just 'delays' certain arguments of this function. This pattern is also called 'currying' in functional programming (named after the mathematician Curry). Here are some examples:

```move
#[persistent] fun add(x: u64, y: u64) { x + y }
...
let x = 22;
let f: |u64|u64 has copy+drop+store = |y| add(x, y);  // 1st argument captured, 2nd argument delayed
let f: |u64|u64 has copy+drop+store = |y| add(y, x);  // 1st argument delayed, 2nd argument captured
```

Notice it is not possible to _capture_ reference values at this point of time in Move. Thus, the following code does not compile:

```move
let x = &22;
let f = |y| add(*x, y) // DOES NOT COMPILE
```

Related, it is not possible to mutate any locals in the context of a lambda. Specifically, the following pattern as known from lambdas with inline functions, is not supported:

```move
let x = 0;
collection.for_each(|e| x += e) // DOES NOT COMPILE
```

However, the actual parameters of lambdas can be references, only captured values are restricted. For example:

```move
let x = 22;
let f : |&u64|u64 = |y| add(x, *y)
```

### Reentrancy Check

Via dynamic dispatch of function values, reentrancy of modules in a chain of function calls is possible. If module `m1` uses module `m2`, and `m1` calls `m2::f` passing a function value to it, this function value can callback into `m1`. This situation is called _reentrancy_, and is not possible in Move without function values, since the module usage relation is acyclic.

The Move VM dynamically detects reentrancy of a module, and _locks_ all resources declared in this module from being accessed. Thus during reentrancy of `m`, calling resource operations like `&m::R[addr]`, `&mut m::R[addr]`, and `move_from<m::R>` lead to an abort. Here is an example:

```move
module 0x42::caller {
  use 0x42::callee;
  struct R{ count: u64 } has key;
  fun calling() acquires R {
     let r = &mut R[@addr];
     // This callback is OK, because `R` is not accessed
     callee::call_me(r, |x| do_something(x))
     // This callback will lead to reentrancy runtime error
     callee::call_me(r, |_| R[@addr].count += 1)
     r.call_count += 1
  }
  fun do_something(r: &mut R) { .. }
}

module 0x42::callee {
  fun call_me<T(x: &mut T, action: |&mut T|) {
    action(x)
  }
}
```

Notice that dispatching a function value to a concrete function in the same module is also considered to be reentrancy. If the function `callee::call_me` would be moved into the module `caller`, the same semantics is in effect.

The default reentrancy check ensures consistency of Move's reference semantics and suppresses side effects of reentrancy for the resources owned by the re-entered module. However, re-entered code is allowed to still access resource state managed by modules outside the reentrancy path. Such state accesses can be considered bad design, but they exist.
For these purposes, the `#[module_lock]` attribute can be attached to a function:

```move
module 0x42::account { ... }
module 0x42::caller {
  #[module_lock] // without this lock, the notify call could withdraw more than intended.
  fun transfer(from: address, to: address, amount: u64, notify: |u64|) {
    // Oops. This should be really differently designed, using `Coin` type and moving it.
    assert!(account::balance(from) - MIN_BALANCE >= amount);
    account::deposit(to, amount)
    notify(amount); // attempt to re-enter `transfer` is blocked
    account::withdraw(from, amount);
  }
}
```

While a function with this attribute is running, all calls reentering any module will lead to an abort, given a stronger protection.

The attribute `#[module_lock]` restriction is not the default behavior since it is too strong for typical patterns of higher-order programming. For example, `collection.find(|x| cond(x))` will lead to a reentrancy of the module which contains this expression, from the module which defines the collection type.

# Generics

> Learn about generics in Move programming language for Aptos smart contract development.

Generics can be used to define functions and structs over different input data types. This language feature is sometimes referred to as _parametric polymorphism_. In Move, we will often use the term generics interchangeably with type parameters and type arguments.

Generics are commonly used in library code, such as in vector, to declare code that works over any possible instantiation (that satisfies the specified constraints). In other frameworks, generic code can sometimes be used to interact with global storage many different ways that all still share the same implementation.

## Declaring Type Parameters

Both functions and structs can take a list of type parameters in their signatures, enclosed by a pair of angle brackets `<...>`.

### Generic Functions

Type parameters for functions are placed after the function name and before the (value) parameter list. The following code defines a generic identity function that takes a value of any type and returns that value unchanged.

```move
module 0x42::example {
  fun id<T>(x: T): T {
    // this type annotation is unnecessary but valid
    (x: T)
  }
}
```

Once defined, the type parameter `T` can be used in parameter types, return types, and inside the function body.

### Generic Structs

Type parameters for structs are placed after the struct name, and can be used to name the types of the fields.

```move
module 0x42::example {
  struct Foo<T> has copy, drop { x: T }

  struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
  }
}
```

Note that [type parameters do not have to be used](#unused-type-parameters)

## Type Arguments

### Calling Generic Functions

When calling a generic function, one can specify the type arguments for the function's type parameters in a list enclosed by a pair of angle brackets.

```move
module 0x42::example {
  fun foo() {
    let x = id<bool>(true);
  }
}
```

If you do not specify the type arguments, Move's [type inference](#type-inference) will supply them for you.

### Using Generic Structs

Similarly, one can attach a list of type arguments for the struct's type parameters when constructing or destructing values of generic types.

```move
module 0x42::example {
  fun foo() {
    let foo = Foo<bool> { x: true };
    let Foo<bool> { x } = foo;
  }
}
```

If you do not specify the type arguments, Move's [type inference](#type-inference) will supply them for you.

### Type Argument Mismatch

If you specify the type arguments, and they conflict with the actual values supplied, an error will be given:

```move
module 0x42::example {
  fun foo() {
    let x = id<u64>(true); // error! true is not a u64
  }
}
```

and similarly:

```move
module 0x42::example {
  fun foo() {
    let foo = Foo<bool> { x: 0 }; // error! 0 is not a bool
    let Foo<address> { x } = foo; // error! bool is incompatible with address
  }
}
```

## Type Inference

In most cases, the Move compiler will be able to infer the type arguments, so you don't have to write them down explicitly. Here's what the examples above would look like if we omit the type arguments:

```move
module 0x42::example {
  fun foo() {
    let x = id(true);
    //        ^ <bool> is inferred

    let foo = Foo { x: true };
    //           ^ <bool> is inferred

    let Foo { x } = foo;
    //     ^ <bool> is inferred
  }
}
```

Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common scenario is to call a function with type parameters appearing only at return positions.

```move
module 0x2::m {
  use std::vector;

  fun foo() {
    // let v = vector::new();
    //                    ^ The compiler cannot figure out the element type.

    let v = vector::new<u64>();
    //                 ^~~~~ Must annotate manually.
  }
}
```

However, the compiler will be able to infer the type if that return value is used later in that function:

```move
module 0x2::m {
  use std::vector;

  fun foo() {
    let v = vector::new();
    //                 ^ <u64> is inferred
    vector::push_back(&mut v, 42);
  }
}
```

## Unused Type Parameters

For a struct definition,
an unused type parameter is one that
does not appear in any field defined in the struct,
but is checked statically at compile time.
Move allows unused type parameters so the following struct definition is valid:

```move
module 0x2::m {
  struct Foo<T> {
    foo: u64
  }
}
```

This can be convenient when modeling certain concepts. Here is an example:

```move
module 0x2::m {
  // Currency Specifiers
  struct Currency1 {}
  struct Currency2 {}

  // A generic coin type that can be instantiated using a currency
  // specifier type.
  //   e.g. Coin<Currency1>, Coin<Currency2> etc.
  struct Coin<Currency> has store {
    value: u64
  }

  // Write code generically about all currencies
  public fun mint_generic<Currency>(value: u64): Coin<Currency> {
    Coin { value }
  }

  // Write code concretely about one currency
  public fun mint_concrete(value: u64): Coin<Currency1> {
    Coin { value }
  }
}
```

In this example,
`struct Coin<Currency>` is generic on the `Currency` type parameter,
which specifies the currency of the coin and
allows code to be written either
generically on any currency or
concretely on a specific currency.
This genericity applies even when the `Currency` type parameter
does not appear in any of the fields defined in `Coin`.

### Phantom Type Parameters

In the example above,
although `struct Coin` asks for the `store` ability,
neither `Coin<Currency1>` nor `Coin<Currency2>` will have the `store` ability.
This is because of the rules for
[Conditional Abilities and Generic Types](/build/smart-contracts/book/abilities#conditional-abilities-and-generic-types)
and the fact that `Currency1` and `Currency2` don't have the `store` ability,
despite the fact that they are not even used in the body of `struct Coin`.
This might cause some unpleasant consequences.
For example, we are unable to put `Coin<Currency1>` into a wallet in the global storage.

One possible solution would be to
add spurious ability annotations to `Currency1` and `Currency2`
(i.e., `struct Currency1 has store {}`).
But, this might lead to bugs or security vulnerabilities
because it weakens the types with unnecessary ability declarations.
For example, we would never expect a resource in the global storage to have a field in type `Currency1`,
but this would be possible with the spurious `store` ability.
Moreover, the spurious annotations would be infectious,
requiring many functions generic on the unused type parameter to also include the necessary constraints.

Phantom type parameters solve this problem.
Unused type parameters can be marked as _phantom_ type parameters,
which do not participate in the ability derivation for structs.
In this way,
arguments to phantom type parameters are not considered when deriving the abilities for generic types,
thus avoiding the need for spurious ability annotations.
For this relaxed rule to be sound,
Move's type system guarantees that a parameter declared as `phantom` is either
not used at all in the struct definition, or
it is only used as an argument to type parameters also declared as `phantom`.

#### Declaration

In a struct definition
a type parameter can be declared as phantom by adding the `phantom` keyword before its declaration.
If a type parameter is declared as phantom we say it is a phantom type parameter.
When defining a struct, Move's type checker ensures that every phantom type parameter is either
not used inside the struct definition or
it is only used as an argument to a phantom type parameter.

More formally,
if a type is used as an argument to a phantom type parameter
we say the type appears in _phantom position_.
With this definition in place,
the rule for the correct use of phantom parameters can be specified as follows:
**A phantom type parameter can only appear in phantom position**.

The following two examples show valid uses of phantom parameters.
In the first one,
the parameter `T1` is not used at all inside the struct definition.
In the second one, the parameter `T1` is only used as an argument to a phantom type parameter.

```move
module 0x2::m {
  struct S1<phantom T1, T2> { f: u64 }
  //                ^^
  //                Ok: T1 does not appear inside the struct definition


  struct S2<phantom T1, T2> { f: S1<T1, T2> }
  //                                ^^
  //                                Ok: T1 appears in phantom position
}
```

The following code shows examples of violations of the rule:

```move
module 0x2::m {
  struct S1<phantom T> { f: T }
  //                        ^
  //                        Error: Not a phantom position

  struct S2<T> { f: T }

  struct S3<phantom T> { f: S2<T> }
  //                           ^
  //                           Error: Not a phantom position
}
```

#### Instantiation

When instantiating a struct,
the arguments to phantom parameters are excluded when deriving the struct abilities.
For example, consider the following code:

```move
module 0x2::m {
  struct S<T1, phantom T2> has copy { f: T1 }
  struct NoCopy {}
  struct HasCopy has copy {}
}
```

Consider now the type `S<HasCopy, NoCopy>`.
Since `S` is defined with `copy` and all non-phantom arguments have `copy`
then `S<HasCopy, NoCopy>` also has `copy`.

#### Phantom Type Parameters with Ability Constraints

Ability constraints and phantom type parameters are orthogonal features in the sense that
phantom parameters can be declared with ability constraints.
When instantiating a phantom type parameter with an ability constraint,
the type argument has to satisfy that constraint,
even though the parameter is phantom.
For example, the following definition is perfectly valid:

```move
module 0x2::m {
  struct S<phantom T: copy> {}
}
```

The usual restrictions apply and `T` can only be instantiated with arguments having `copy`.

## Constraints

In the examples above, we have demonstrated how one can use type parameters to define "unknown" types that can be plugged in by callers at a later time. This however means the type system has little information about the type and has to perform checks in a very conservative way. In some sense, the type system must assume the worst case scenario for an unconstrained generic. Simply put, by default generic type parameters have no [abilities](/build/smart-contracts/book/abilities).

This is where constraints come into play: they offer a way to specify what properties these unknown types have so the type system can allow operations that would otherwise be unsafe.

### Declaring Constraints

Constraints can be imposed on type parameters using the following syntax.

```move
// T is the name of the type parameter
T: <ability> (+ <ability>)*
```

The `<ability>` can be any of the four [abilities](/build/smart-contracts/book/abilities), and a type parameter can be constrained with multiple abilities at once. So all the following would be valid type parameter declarations:

```move
T: copy
T: copy + drop
T: copy + drop + store + key
```

### Verifying Constraints

Constraints are checked at call sites so the following code won't compile.

```move
module 0x2::m {
  struct Foo<T: key> { x: T }

  struct Bar { x: Foo<u8> }
  //                  ^ error! u8 does not have 'key'

  struct Baz<T> { x: Foo<T> }
  //                     ^ error! T does not have 'key'
}
```

```move
module 0x2::m {
  struct R {}

  fun unsafe_consume<T>(x: T) {
    // error! x does not have 'drop'
  }

  fun consume<T: drop>(x: T) {
    // valid!
    // x will be dropped automatically
  }

  fun foo() {
    let r = R {};
    consume<R>(r);
    //      ^ error! R does not have 'drop'
  }
}
```

```move
module 0x2::m {
  struct R {}

  fun unsafe_double<T>(x: T) {
    (copy x, x)
    // error! x does not have 'copy'
  }

  fun double<T: copy>(x: T) {
    (copy x, x) // valid!
  }

  fun foo(): (R, R) {
    let r = R {};
    double<R>(r)
    //     ^ error! R does not have 'copy'
  }
}
```

For more information, see the abilities section on [conditional abilities and generic types](/build/smart-contracts/book/abilities#conditional-abilities-and-generic-types).

## Limitations on Recursions

### Recursive Structs

Generic structs can not contain fields of the same type, either directly or indirectly, even with different type arguments. All the following struct definitions are invalid:

```move
module 0x2::m {
  struct Foo<T> {
    x: Foo<u64> // error! 'Foo' containing 'Foo'
  }

  struct Bar<T> {
    x: Bar<T> // error! 'Bar' containing 'Bar'
  }

  // error! 'A' and 'B' forming a cycle, which is not allowed either.
  struct A<T> {
    x: B<T, u64>
  }

  struct B<T1, T2> {
    x: A<T1>,
    y: A<T2>
  }
}
```

### Advanced Topic: Type-level Recursions

Move allows generic functions to be called recursively. However, when used in combination with generic structs, this could create an infinite number of types in certain cases, and allowing this means adding unnecessary complexity to the compiler, vm and other language components. Therefore, such recursions are forbidden.

Allowed:

```move
module 0x2::m {
  struct A<T> {}

  // Finitely many types -- allowed.
  // foo1<T> -> foo1<T> -> foo1<T> -> ... is valid
  fun foo1<T>() {
    foo1<T>();
  }

  // Finitely many types -- allowed.
  // foo2<T> -> foo2<A<u64>> -> foo2<A<u64>> -> ... is valid
  fun foo2<T>() {
    foo2<A<u64>>();
  }
}
```

Not allowed:

```move
module 0x2::m {
  struct A<T> {}

  // Infinitely many types -- NOT allowed.
  // error!
  // foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...
  fun foo<T>() {
    foo<A<T>>();
  }
}
```

```move
module 0x2::n {
  struct A<T> {}

  // Infinitely many types -- NOT allowed.
  // error!
  // foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>
  //   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>
  //   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>
  //   -> ...
  fun foo<T1, T2>() {
    bar<T2, T1>();
  }

  fun bar<T1, T2>() {
    foo<T1, A<T2>>();
  }
}
```

Note, the check for type level recursions is based on a conservative analysis on the call sites and does NOT take control flow or runtime values into account.

```move
module 0x2::m {
  struct A<T> {}

  fun foo<T>(n: u64) {
    if (n > 0) {
      foo<A<T>>(n - 1);
    };
  }
}
```

The function in the example above will technically terminate for any given input and therefore only creating finitely many types, but it is still considered invalid by Move's type system.

# Global Storage - Operators

> Master global storage operations including borrow_global, move_to, move_from for resource management on Aptos.

Move programs can create, delete, and update [resources](/build/smart-contracts/book/structs-and-resources) in global storage using the following five instructions:

| Operation                               | Description                                                     | Aborts?                                 |
| --------------------------------------- | --------------------------------------------------------------- | --------------------------------------- |
| `move_to<T>(&signer,T)`                 | Publish `T` under `signer.address`                              | If `signer.address` already holds a `T` |
| `move_from<T>(address): T`              | Remove `T` from `address` and return it                         | If `address` does not hold a `T`        |
| `borrow_global_mut<T>(address): &mut T` | Return a mutable reference to the `T` stored under `address`    | If `address` does not hold a `T`        |
| `borrow_global<T>(address): &T`         | Return an immutable reference to the `T` stored under `address` | If `address` does not hold a `T`        |
| `exists<T>(address): bool`              | Return `true` if a `T` is stored under `address`                | Never                                   |

Each of these instructions is parameterized by a type `T` with the [`key` ability](/build/smart-contracts/book/abilities). However, each type `T` _must be declared in the current module_. This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an [`address`](/build/smart-contracts/book/address) or [`&signer`](/build/smart-contracts/book/signer) representing the account address where the resource of type `T` is stored.

See also [index notation (`[]`)](#index-notation-for-storage-operators) for accessing global storage.

## References to resources

References to global resources returned by `borrow_global` or `borrow_global_mut` mostly behave like references to local storage: they can be extended, read, and written using ordinary [reference operators](/build/smart-contracts/book/references) and passed as arguments to other function. However, there is one important difference between local and global references: **a function cannot return a reference that points into global storage**. For example, these two functions will each fail to compile:

```move
module 0x42::example {
  struct R has key { f: u64 }
  // will not compile
  fun ret_direct_resource_ref_bad(a: address): &R {
    borrow_global<R>(a) // error!
  }
  // also will not compile
  fun ret_resource_field_ref_bad(a: address): &u64 {
    &borrow_global<R>(a).f // error!
  }
}
```

Move must enforce this restriction to guarantee absence of dangling references to global
storage. [This section](#reference-safety-for-global-resources) contains much more detail for the interested reader.

## Global storage operators with generics

Global storage operations can be applied to generic resources with both instantiated and uninstantiated generic type parameters:

```move
module 0x42::example {
  struct Container<T> has key { t: T }

  // Publish a Container storing a type T of the caller's choosing
  fun publish_generic_container<T>(account: &signer, t: T) {
    move_to<Container<T>>(account, Container { t })
  }

  /// Publish a container storing a u64
  fun publish_instantiated_generic_container(account: &signer, t: u64) {
    move_to<Container<u64>>(account, Container { t })
  }
}
```

The ability to index into global storage via a type parameter chosen at runtime is a powerful Move feature known as _storage polymorphism_. For more on the design patterns enabled by this feature, see [Move generics](/build/smart-contracts/book/generics).

## Example: `Counter`

The simple `Counter` module below exercises each of the five global storage operators. The API exposed by this module allows:

- Anyone to publish a `Counter` resource under their account
- Anyone to check if a `Counter` exists under any address
- Anyone to read or increment the value of a `Counter` resource under any address
- An account that stores a `Counter` resource to reset it to zero
- An account that stores a `Counter` resource to remove and delete it

```move
module 0x42::counter {
  use std::signer;

  /// Resource that wraps an integer counter
  struct Counter has key { i: u64 }

  /// Publish a `Counter` resource with value `i` under the given `account`
  public fun publish(account: &signer, i: u64) {
    // "Pack" (create) a Counter resource. This is a privileged operation that
    // can only be done inside the module that declares the `Counter` resource
    move_to(account, Counter { i })
  }

  /// Read the value in the `Counter` resource stored at `addr`
  public fun get_count(addr: address): u64 acquires Counter {
    borrow_global<Counter>(addr).i
  }

  /// Increment the value of `addr`'s `Counter` resource
  public fun increment(addr: address) acquires Counter {
    let c_ref = &mut borrow_global_mut<Counter>(addr).i;
    *c_ref = *c_ref + 1
  }

  /// Reset the value of `account`'s `Counter` to 0
  public fun reset(account: &signer) acquires Counter {
    let c_ref = &mut borrow_global_mut<Counter>(signer::address_of(account)).i;
    *c_ref = 0
  }

  /// Delete the `Counter` resource under `account` and return its value
  public fun delete(account: &signer): u64 acquires Counter {
    // remove the Counter resource
    let c = move_from<Counter>(signer::address_of(account));
    // "Unpack" the `Counter` resource into its fields. This is a
    // privileged operation that can only be done inside the module
    // that declares the `Counter` resource
    let Counter { i } = c;
    i
  }

  /// Return `true` if `addr` contains a `Counter` resource
  public fun exists_at(addr: address): bool {
    exists<Counter>(addr)
  }
}
```

## Annotating functions with `acquires`

_Note: Since language version 2.2, acquires annotations are optional. If no acquires is given, it will be inferred._

In the `counter` example, you might have noticed that the `get_count`, `increment`, `reset`, and `delete` functions are annotated with `acquires Counter`. A Move function `m::f` must be annotated with `acquires T` if and only if:

- The body of `m::f` contains a `move_from<T>`, `borrow_global_mut<T>`, or `borrow_global<T>` instruction, or
- The body of `m::f` invokes a function `m::g` declared in the same module that is annotated with `acquires`

For example, the following function inside `Counter` would need an `acquires` annotation:

```move
module 0x42::example {
  // Needs `acquires` because `increment` is annotated with `acquires`
  fun call_increment(addr: address): u64 acquires Counter {
    counter::increment(addr)
  }
}
```

However, the same function _outside_ `Counter` would not need an annotation:

```move
module 0x43::m {
  use 0x42::counter;

  // Ok. Only need annotation when resource acquired by callee is declared
  // in the same module
  fun call_increment(addr: address): u64 {
    counter::increment(addr)
  }
}
```

If a function touches multiple resources, it needs multiple `acquires`:

```move
module 0x42::two_resources {
  struct R1 has key { f: u64 }
  struct R2 has key { g: u64 }

  fun double_acquires(a: address): u64 acquires R1, R2 {
    borrow_global<R1>(a).f + borrow_global<R2>(a).g
  }
}
```

The `acquires` annotation does not take generic type parameters into account:

```move
module 0x42::m {
  struct R<T> has key { t: T }

  // `acquires R`, not `acquires R<T>`
  fun acquire_generic_resource<T: store>(a: address) acquires R {
    let _ = borrow_global<R<T>>(a);
  }

  // `acquires R`, not `acquires R<u64>
  fun acquire_instantiated_generic_resource(a: address) acquires R {
    let _ = borrow_global<R<u64>>(a);
  }
}
```

Finally: redundant `acquires` are not allowed. Adding this function inside `Counter` will result in a compilation error:

```move
module 0x42::m {
  // This code will not compile because the body of the function does not use a global
  // storage instruction or invoke a function with `acquires`
  fun redundant_acquires_bad() acquires Counter {}
}
```

For more information on `acquires`, see [Move functions](/build/smart-contracts/book/functions).

## Reference Safety For Global Resources

Move prohibits returning global references and requires the `acquires` annotation to prevent dangling references. This allows Move to live up to its promise of static reference safety (i.e., no dangling references, no `null` or `nil` dereferences) for all [reference](/build/smart-contracts/book/references) types.

This example illustrates how the Move type system uses `acquires` to prevent a dangling reference:

```move
module 0x42::dangling {
  struct T has key { f: u64 }

  fun borrow_then_remove_bad(a: address) acquires T {
    let t_ref: &mut T = borrow_global_mut<T>(a);
    let t = remove_t(a); // type system complains here
    // t_ref now dangling!
    let uh_oh = *&t_ref.f;
  }

  fun remove_t(a: address): T acquires T {
    move_from<T>(a)
  }
}
```

In this code, line 6 acquires a reference to the `T` stored at address `a` in global storage. The callee `remove_t` then removes the value, which makes `t_ref` a dangling reference.

Fortunately, this cannot happen because the type system will reject this program. The `acquires` annotation on `remove_t` lets the type system know that line 7 is dangerous, without having to recheck or introspect the body of `remove_t` separately!

The restriction on returning global references prevents a similar, but even more insidious problem:

```move
address 0x42 {
  module m1 {
    struct T has key {}

    public fun ret_t_ref(a: address): &T acquires T {
      borrow_global<T>(a) // error! type system complains here
    }

    public fun remove_t(a: address) acquires T {
      let T {} = move_from<T>(a);
    }
  }

  module m2 {
    fun borrow_then_remove_bad(a: address) {
      let t_ref = m1::ret_t_ref(a);
      let t = m1::remove_t(a); // t_ref now dangling!
    }
  }
}
```

Line 16 acquires a reference to a global resource `m1::T`, then line 17 removes that same resource, which makes `t_ref` dangle. In this case, `acquires` annotations do not help us because the `borrow_then_remove_bad` function is outside the `m1` module that declares `T` (recall that `acquires` annotations can only be used for resources declared in the current module). Instead, the type system avoids this problem by preventing the return of a global reference at line 6.

Fancier type systems that would allow returning global references without sacrificing reference safety are possible, and we may consider them in future iterations of Move. We chose the current design because it strikes a good balance between being expressive, annotation burden, and type system complexity.

## Index Notation for Storage Operators

_Since language version 2.0_

Instead of the verbose `borrow_global` and `borrow_global_mut` functions, one
can also use index notations to access global storage.

The table below gives an overview of index notations for storage:

| Indexing Syntax         | Storage Operation                          |
| ----------------------- | ------------------------------------------ |
| `&T[address]`           | `borrow_global<T>(address)`                |
| `&mut T[address]`       | `borrow_global_mut<T>(address)`            |
| `T[address]`            | `*borrow_global<T>(address)`               |
| `T[address] = x`        | `*borrow_global_mut<T>(address) = x`       |
| `&T[address].field`     | `&borrow_global<T>(address).field`         |
| `&mut T[address].field` | `&mut borrow_global_mut<T>(address).field` |
| `T[address].field`      | `borrow_global<T>(address).field`          |
| `T[address].field = x`  | `borrow_global_mut<T>(address).field = x`  |

Here `T` represents a generic resource type that can take type parameters.

Notice that `T[address].field` fetches a reference to the resource from storage and then makes a copy of the field value (which must
have the copy ability); it is a shortcut for `*&T[address].field`.

Examples:

```move
struct R has key, drop { value: bool }

fun f1() acquires R {
  let x = &mut R[@0x1];
  x.value = false;
  assert!(R[@0x1].value == false);
  R[@0x1].value = true;
  assert!(R[@0x1].value == true);
}
```

# Global Storage - Structure

> Understand global storage organization, resource management, and data access patterns in Move smart contracts.

The purpose of Move programs is to [read from and write to](/build/smart-contracts/book/global-storage-operators) tree-shaped persistent global storage. Programs cannot access the filesystem, network, or any other data outside of this tree.

In pseudocode, the global storage looks something like:

```move
module 0x42::example {
  struct GlobalStorage {
    resources: Map<(address, ResourceType), ResourceValue>,
    modules: Map<(address, ModuleName), ModuleBytecode>
  }
}
```

Structurally, global storage is a [forest](https://en.wikipedia.org/wiki/Tree_\(graph_theory\)) consisting of trees rooted at an account [`address`](/build/smart-contracts/book/address). Each address can store both [resource](/build/smart-contracts/book/structs-and-resources) data values and [module](/build/smart-contracts/book/modules-and-scripts) code values. As the pseudocode above indicates, each `address` can store at most one resource value of a given type and at most one module with a given name.

# Integers

> Learn about integers in Move programming language for Aptos smart contract development.

Move supports six unsigned integer types: `u8`, `u16`, `u32`, `u64`, `u128`, and `u256`. Values of these types range from 0 to a maximum that depends on the size of the type.

| Type                             | Value Range              |
| -------------------------------- | ------------------------ |
| Unsigned 8-bit integer, `u8`     | 0 to 2<sup>8</sup> - 1   |
| Unsigned 16-bit integer, `u16`   | 0 to 2<sup>16</sup> - 1  |
| Unsigned 32-bit integer, `u32`   | 0 to 2<sup>32</sup> - 1  |
| Unsigned 64-bit integer, `u64`   | 0 to 2<sup>64</sup> - 1  |
| Unsigned 128-bit integer, `u128` | 0 to 2<sup>128</sup> - 1 |
| Unsigned 256-bit integer, `u256` | 0 to 2<sup>256</sup> - 1 |

_Since version 2.3_, Move also supports signed integer types:

| Type                           | Value Range                             |
| ------------------------------ | --------------------------------------- |
| Signed 8-bit integer, `i8`     | -2<sup>7</sup> to 2<sup>7</sup> - 1     |
| Signed 16-bit integer, `i16`   | -2<sup>15</sup> to 2<sup>15</sup> - 1   |
| Signed 32-bit integer, `i32`   | -2<sup>31</sup> to 2<sup>31</sup> - 1   |
| Signed 64-bit integer, `i64`   | -2<sup>63</sup> to 2<sup>63</sup> - 1   |
| Signed 128-bit integer, `i128` | -2<sup>127</sup> to 2<sup>127</sup> - 1 |
| Signed 256-bit integer, `i256` | -2<sup>255</sup> to 2<sup>255</sup> - 1 |

## Literals

Literal values for these types are specified either as a sequence of digits (e.g.,`112`) or as hex literals, e.g., `0xFF`. The type of the literal can optionally be added as a suffix, e.g., `112u8`. If the type is not specified, the compiler will try to infer the type from the context where the literal is used. If the type cannot be inferred, it is assumed to be `u64`.

Number literals can be separated by underscores for grouping and readability. (e.g.,`1_234_5678`, `1_000u128`, `0xAB_CD_12_35`).

To denote a negative number, it can be prefixed by the `-` sign. (e.g., `-112`)

If a literal is too large for its specified (or inferred) size range, an error is reported.

### Examples

```move
script {
  fun example() {
    // literals with explicit annotations;
    let explicit_u8 = 1u8;
    let explicit_u16 = 1u16;
    let explicit_u32 = 1u32;
    let explicit_u64 = 2u64;
    let explicit_u128 = 3u128;
    let explicit_u256 = 1u256;
    let explicit_u64_underscored = 154_322_973u64;
    let explicit_i8 = -1i8;
    let explicit_i64 = -2i64;

    // literals with simple inference
    let simple_u8: u8 = 1;
    let simple_u16: u16 = 1;
    let simple_u32: u32 = 1;
    let simple_u64: u64 = 2;
    let simple_u128: u128 = 3;
    let simple_u256: u256 = 1;

    // literals with more complex inference
    let complex_u8 = 1; // inferred: u8
    // right hand argument to shift must be u8
    let _unused = 10 << complex_u8;

    let x: u8 = 38;
    let complex_u8 = 2; // inferred: u8
    // arguments to `+` must have the same type
    let _unused = x + complex_u8;

    let complex_u128 = 133_876; // inferred: u128
    // inferred from function argument type
    function_that_takes_u128(complex_u128);

    // literals can be written in hex
    let hex_u8: u8 = 0x1;
    let hex_u16: u16 = 0x1BAE;
    let hex_u32: u32 = 0xDEAD80;
    let hex_u64: u64 = 0xCAFE;
    let hex_u128: u128 = 0xDEADBEEF;
    let hex_u256: u256 = 0x1123_456A_BCDE_F;
  }
}
```

## Operations

### Arithmetic

Each of these types supports the same set of checked arithmetic operations. For all of these operations, both arguments (the left and right side operands) _must_ be of the same type. If you need to operate over values of different types, you will need to first perform a [cast](#casting). Similarly, if you expect the result of the operation to be too large for the integer type, perform a [cast](#casting) to a larger size before performing the operation.

All arithmetic operations abort instead of behaving in a way that mathematical integers would not (e.g., overflow, underflow, divide-by-zero).

| Syntax  | Operation           | Aborts If                                      |
| ------- | ------------------- | ---------------------------------------------- |
| `a + b` | addition            | Result is too large/small for the integer type |
| `a - b` | subtraction         | Result is less than zero                       |
| `a * b` | multiplication      | Result is too large/small for the integer type |
| `a % b` | modular division    | The divisor is `0`                             |
| `a / b` | truncating division | The divisor is `0`, or result overflow         |
| `-a`    | negation            | Negated result too large (e.g. `-MIN_I64`)     |

### Bitwise

The _unsigned_ integer types support the following bitwise operations that treat each number as a series of individual bits, either 0 or 1, instead of as numerical integer values.

Bitwise operations do not abort.

| Syntax | Operation   | Description                                           |
| ------ | ----------- | ----------------------------------------------------- |
| `&`    | bitwise and | Performs a boolean and for each bit pairwise          |
| `\|`   | bitwise or  | Performs a boolean or for each bit pairwise           |
| `^`    | bitwise xor | Performs a boolean exclusive or for each bit pairwise |

### Bit Shifts

Similar to the bitwise operations, each _unsigned_ integer type supports bit shifts. But unlike the other operations, the right-hand side operand (how many bits to shift by) must _always_ be a `u8` and need not match the left side operand (the number you are shifting).

Bit shifts abort if the number of bits to shift by is greater than or equal to `8`, `16`, `32`, `64`, `128` or `256` for `u8`, `u16`, `u32`, `u64`, `u128` and `u256` respectively.

| Syntax | Operation   | Aborts if                                                                           |
| ------ | ----------- | ----------------------------------------------------------------------------------- |
| `<<`   | shift left  | Number of bits to shift by is greater than or equal to the size of the integer type |
| `>>`   | shift right | Number of bits to shift by is greater than or equal to the size of the integer type |

### Comparisons

All integer types support the ["comparison"](/build/smart-contracts/book/comparison) operations. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to [cast](#casting) one of them first.

Comparison operations do not abort.

| Syntax | Operation                |
| ------ | ------------------------ |
| `<`    | less than                |
| `>`    | greater than             |
| `<=`   | less than or equal to    |
| `>=`   | greater than or equal to |

### Equality

Like all types with [`drop`](/build/smart-contracts/book/abilities) in Move, all integer types support the ["equal"](/build/smart-contracts/book/equality) and ["not equal"](/build/smart-contracts/book/equality) operations. Both arguments need to be of the same type. If you need to compare integers of different types, you will need to [cast](#casting) one of them first.

Equality operations do not abort.

| Syntax | Operation |
| ------ | --------- |
| `==`   | equal     |
| `!=`   | not equal |

For more details see the section on [equality](/build/smart-contracts/book/equality)

## Casting

Integer types of one size can be cast to integer types of another size. Integers are the only types in Move that support casting.

Casts _do not_ truncate. Casting will abort if the result is too large or too small for the specified type.

| Syntax     | Operation                                            | Aborts if                                           |
| ---------- | ---------------------------------------------------- | --------------------------------------------------- |
| `(e as T)` | Cast integer expression `e` into an integer type `T` | `e` is too large or too small to represent as a `T` |

Any integer can be cast into any other integer type, including signed to unsigned and unsigned to signed, provided the target type is able to represent the source type.

For example:

- `(x as u8)`
- `(y as u16)`
- `(873u16 as u32)`
- `(2u8 as u64)`
- `(1 + 3 as u128)`
- `(4/2 + 12345 as u256)`

Notice that since Language Version 2.0, casts don't always need to be in parentheses. Thus, `x as u8` is a valid expression.

## Ownership

As with the other scalar values built-in to the language, integer values are implicitly copyable, meaning they can be copied without an explicit instruction such as [`copy`](/build/smart-contracts/book/variables#move-and-copy).

# While, For, and Loop

> Master loop constructs in Move including while loops, iteration patterns, and control flow for smart contracts.

Move offers three constructs for looping: `while`, `for`, and `loop`.

## `while` loops

The `while` construct repeats the body (an expression of type unit) until the condition (an expression of type `bool`) evaluates to `false`.

Here is an example of simple `while` loop that computes the sum of the numbers from `1` to `n`:

```move
script {
  fun sum(n: u64): u64 {
    let sum = 0;
    let i = 1;
    while (i <= n) {
      sum = sum + i;
      i = i + 1
    };

    sum
  }
}
```

Infinite loops are allowed:

```move
script {
  fun foo() {
    while (true) { }
  }
}
```

### `break`

The `break` expression can be used to exit a loop before the condition evaluates to `false`. For example, this loop uses `break` to find the smallest factor of `n` that's greater than 1:

```move
script {
  fun smallest_factor(n: u64): u64 {
    // assuming the input is not 0 or 1
    let i = 2;
    while (i <= n) {
      if (n % i == 0) break;
      i = i + 1
    };

    i
  }
}
```

The `break` expression cannot be used outside of a loop.

### `continue`

The `continue` expression skips the rest of the loop and continues to the next iteration. This loop uses `continue` to compute the sum of `1, 2, ..., n`, except when the number is divisible by 10:

```move
script {
  fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    while (i < n) {
      i = i + 1;
      if (i % 10 == 0) continue;
      sum = sum + i;
    };

    sum
  }
}
```

The `continue` expression cannot be used outside of a loop.

### The type of `break` and `continue`

`break` and `continue`, much like `return` and `abort`, can have any type. The following examples illustrate where this flexible typing can be helpful:

```move
script {
  fun pop_smallest_while_not_equal(
    v1: vector<u64>,
    v2: vector<u64>,
  ): vector<u64> {
    let result = vector::empty();
    while (!vector::is_empty(&v1) && !vector::is_empty(&v2)) {
      let u1 = *vector::borrow(&v1, vector::length(&v1) - 1);
      let u2 = *vector::borrow(&v2, vector::length(&v2) - 1);
      let popped =
        if (u1 < u2) vector::pop_back(&mut v1)
        else if (u2 < u1) vector::pop_back(&mut v2)
        else break; // Here, `break` has type `u64`
      vector::push_back(&mut result, popped);
    };

    result
  }
}
```

```move
script {
  fun pick(
    indexes: vector<u64>,
    v1: &vector<address>,
    v2: &vector<address>
  ): vector<address> {
    let len1 = vector::length(v1);
    let len2 = vector::length(v2);
    let result = vector::empty();
    while (!vector::is_empty(&indexes)) {
      let index = vector::pop_back(&mut indexes);
      let chosen_vector =
        if (index < len1) v1
        else if (index < len2) v2
        else continue; // Here, `continue` has type `&vector<address>`
      vector::push_back(&mut result, *vector::borrow(chosen_vector, index))
    };

    result
  }
}
```

## The `for` expression

The `for` expression iterates over a range defined using integer-typed `lower_bound` (inclusive) and `upper_bound` (non-inclusive) expressions, executing its loop body for each element of the range. `for` is designed for scenarios where the number of iterations of a loop is determined by a specific range.

Here is an example of a `for` loop that computes the sum of the elements in a range from `0` to `n-1`:

```move
script {
  fun sum(n: u64): u64 {
    let sum = 0;
    for (i in 0..n) {
      sum = sum + i;
    };

    sum
  }
}
```

The loop iterator variable (`i` in the above example) currently must be a numeric type (inferred from the bounds), and the bounds `0` and `n` here can be replaced by arbitrary numeric expressions. Each is only evaluated once at the start of the loop. The iterator variable `i` is assigned the `lower_bound` (in this case `0`) and incremented after each loop iteration; the loop exits when the iterator `i` reaches or exceeds `upper_bound` (in this case `n`).

### `break` and `continue` in `for` loops

Similar to `while` loops, the `break` expression can be used in `for` loops to exit prematurely. The `continue` expression can be used to skip the current iteration and move to the next. Here's an example that demonstrates the use of both `break` and `continue`. The loop will iterate through numbers from `0` to `n-1`, summing up them up. It will skip numbers that are divisible by `3` (using `continue`) and stop when it encounters a number greater than `10` (using `break`):

```move
script {
  fun sum_conditional(n: u64): u64 {
    let sum = 0;
    for (iter in 0..n) {
      if (iter > 10) {
        break; // Exit the loop if the number is greater than 10
      };
      if (iter % 3 == 0) {
        continue; // Skip the current iteration if the number is divisible by 3
      };

      sum = sum + iter;
    };

    sum
  }
}
```

## The `loop` expression

The `loop` expression repeats the loop body (an expression with type `()`) until it hits a `break`

Without a `break`, the loop will continue forever

```move
script {
  fun foo() {
    let i = 0;
    loop { i = i + 1 }
  }
}

```

Here is an example that uses `loop` to write the `sum` function:

```move
script {
  fun sum(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
      i = i + 1;
      if (i > n) break;
      sum = sum + i
    };

    sum
  }
}
```

As you might expect, `continue` can also be used inside a `loop`. Here is `sum_intermediate` from above rewritten using `loop` instead of `while`

```move
script {
  fun sum_intermediate(n: u64): u64 {
    let sum = 0;
    let i = 0;
    loop {
      i = i + 1;
      if (i % 10 == 0) continue;
      if (i > n) break;
      sum = sum + i
    };

    sum
  }
}
```

## The type of `while`, `loop`, and `for` expression

Move loops are typed expressions. The `while` and `for` expression always has type `()`.

```move
script {
  fun example() {
    let () = while (i < 10) { i = i + 1 };
    let () = for (i in 0..10) {};
  }
}
```

If a `loop` contains a `break`, the expression has type unit `()`

```move
script {
  fun example() {
    (loop { if (i < 10) i = i + 1 else break }: ());
    let () = loop { if (i < 10) i = i + 1 else break };
  }
}
```

If `loop` does not have a `break` or a `continue`, `loop` can have any type much like `return`, `abort`, `break`, and `continue`.

```move
script {
  fun example() {
    (loop (): u64);
    (loop (): address);
    (loop (): &vector<vector<u8>>);
  }
}
```

## Loop Labels

_Since language version 2.1_

A `while` or `loop` statement can have a label which can be referred to by a `break` or `continue` statement. In the presence of nested loops, this allows to refer to outer loops. Example:

```move
script {
  fun example(x: u64): u64 {
    'label1: while (x > 10) {
      loop {
        if (x % 2 == 0) {
          x -= 1;
          continue 'label1;
        } else if (x < 10) {
          break 'label1
        } else
          x -= 2
      }
    };
    x
  }
}
```

# Modules and Scripts

> Learn about modules and scripts in Move programming language for Aptos smart contract development.

import { Aside } from '@astrojs/starlight/components';

Move has two different types of programs: \***Modules**\* and \*\*_Scripts_\*\*. Modules are libraries that define struct types along with functions that operate on these types. Struct types define the schema of Move's [global storage](/build/smart-contracts/book/global-storage-structure), and module functions define the rules for updating storage. Modules themselves are also stored in global storage. A scripts is an executable entrypoint similar to a `main` function in a conventional language. A script typically calls functions of a published module that perform updates to global storage. Scripts are ephemeral code snippets that are not published in global storage.

A Move source file (or **compilation unit**) may contain multiple modules and scripts. However, publishing a module or executing a script are separate VM operations.

## Syntax

### Scripts

<Aside type="note">
  To learn how to publish and execute a Move script, follow the [Move Scripts](/build/smart-contracts/scripts/script-tutorial) example.
</Aside>

A script has the following structure:

```text
script {
    <use>*
    <constants>*
    fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>
}
```

A `script` block must start with all of its [`use`](/build/smart-contracts/book/uses) declarations, followed by any [constants](/build/smart-contracts/book/constants) and (finally) the main
[function](/build/smart-contracts/book/functions) declaration.
The main function can have any name (i.e., it need not be called `main`), is the only function in a script block, can have any number of
arguments, and must not return a value. Here is an example with each of these components:

```move
script {
    // Import the debug module published at the named account address std.
    use std::debug;

    const ONE: u64 = 1;

    fun main(x: u64) {
        let sum = x + ONE;
        debug::print(&sum)
    }
}
```

Scripts have very limited power‚Äîthey cannot declare friends, struct types or access global storage. Their primary purpose is to invoke module functions.

### Modules

A module has the following syntax:

```move
module <address>::<identifier> {
    (<use> | <friend> | <type> | <function> | <constant>)*
}
```

where `<address>` is a valid [named or literal address](/build/smart-contracts/book/address).

For example:

```move
module 0x42::example {
    struct Example has copy, drop { i: u64 }

    use std::debug;
    friend 0x42::another_example;

    const ONE: u64 = 1;

    public fun print(x: u64) {
        let sum = x + ONE;
        let example = Example { i: sum };
        debug::print(&sum)
    }
}
```

The `module 0x42::example` part specifies that the module `example` will be published under the [account address](/build/smart-contracts/book/address) `0x42` in [global storage](/build/smart-contracts/book/global-storage-structure).

Modules can also be declared using [named addresses](/build/smart-contracts/book/address). For example:

```move
module example_addr::example {
    struct Example has copy, drop { a: address }

    use std::debug;
    friend example_addr::another_example;

    public fun print() {
        let example = Example { a: @example_addr };
        debug::print(&example)
    }
}
```

Because named addresses only exist at the source language level and during compilation,
named addresses will be fully substituted for their value at the bytecode
level. For example if we had the following code:

```move
script {
    fun example() {
        my_addr::m::foo(@my_addr);
    }
}
```

and we compiled it with `my_addr` set to `0xC0FFEE`, then it would be equivalent
to the following operationally:

```move
script {
    fun example() {
        0xC0FFEE::m::foo(@0xC0FFEE);
    }
}
```

However, at the source level, these _are not equivalent_‚Äîthe function
`m::foo` _must_ be accessed through the `my_addr` named address, and not through
the numerical value assigned to that address.

Module names can start with letters `a` to `z` or letters `A` to `Z`. After the first character, module names can contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, or digits `0` to `9`.

```move
module my_module {}
module foo_bar_42 {}
```

Typically, module names start with a lowercase letter. A module named `my_module` should be stored in a source file named `my_module.move`.

All elements inside a `module` block can appear in any order.
Fundamentally, a module is a collection of [`types`](/build/smart-contracts/book/structs-and-resources) and [`functions`](/build/smart-contracts/book/functions).
The [`use`](/build/smart-contracts/book/uses) keyword is used to import types from other modules.
The [`friend`](/build/smart-contracts/book/friends) keyword specifies a list of trusted modules.
The [`const`](/build/smart-contracts/book/constants) keyword defines private constants that can be used in the functions of a module.

# Move 2 Release Notes

> Explore Move 2.0 language features, improvements, and migration guide for enhanced smart contract development on Aptos.

The Move 2 language releases are described on this page. The reference documentation of the new features is integrated into the book, and marked in the text with "_Since language version 2.n_".

## Move 2.3

The Move 2.3 language release adds the following features to Move:

- **Signed Integer Types**: Move now supports `i8`, `i16`, `i32`, `i64`, `i128`, and `i256` signed integer types. See the [reference doc here](/build/smart-contracts/book/integers).
- **Builtin Constants**: Move now supports a number of builtin constants, namely min/max values for integer types (e.g. `MAX_U64`, `MIN_I32`), as well as a constant to determine whether code is running in testing mode. See the [reference doc here](/build/smart-contracts/book/constants#builtin-constants).

## Move 2.2

The Move 2.2 language release adds the following features to Move:

- **Optional Acquires**: The `acquires` annotation on function declarations can be omitted, to be inferred by the compiler.
- **Function Values**: Move now supports function values, which can be passed around as parameters and stored in resources. See the [reference doc here](/build/smart-contracts/book/functions#function-values).
- **Comparison Operations**: Move now supports comparison operations (`<`, `>`, `<=`, `>=`) on all types. See the [reference doc here](/build/smart-contracts/book/comparison#typing).

## Move 2.1

The Move 2.1 language release adds the following features to Move:

- **Compound Assignments** One can now use `x += n`, `x -= n`, etc. to combine assignments and arithmetic operations. See [reference doc here](/build/smart-contracts/book/variables#compound-assignments) for the supported operations.

- **Loop Labels** One can now use labels for loops and have a `break` or `continue` expression refer to those labels. This allows to continue or break outer loops from within nested loops. See [reference doc here](/build/smart-contracts/book/loops#loop-labels).

- **Underscore function parameters are wildcards, not symbols** Function parameters named `_` no longer act like variables: they do not bind a value, and multiple such parameters to a function does not cause a conflict.  Using `_` in a value expression will yield an error, as it has no value.  This makes the behavior of `_` more like the wildcard it is in patterns and let expressions, where it does not bind a value.

## Move 2.0

The Move 2.0 language release adds the following features to Move:

- **Enum Types** add the option to define different variants of data layout in one storable type. They are documented in the [Enum Type section](/build/smart-contracts/book/enums).

- **Receiver Style Functions** add the ability to call functions in the familiar notation `value.func(arg)`. They are documented in [this section](/build/smart-contracts/book/functions#dot-receiver-function-call-style).

- **Index Notation** allows access to [elements of vectors](/build/smart-contracts/book/vector#index-notation-for-vectors) and of [resource storage](/build/smart-contracts/book/global-storage-operators#index-notation-for-storage-operators) with notations like `&mut vector[index]`, or `&mut Resource[addr]`, respectively.

- **Positional Structs** allow to define wrapper types such as `struct Wrapped(u64)`. Positional structs are described [here](/build/smart-contracts/book/structs-and-resources#positional-structs). Enum variants are also allowed to be positional.

- **Dot-dot pattern wildcards** enable statements like `let Struct{x, ..} = value` to match selective parts of data. They are described [here](/build/smart-contracts/book/structs-and-resources#partial-patterns). Those patterns are also allowed for enum variants.

- **Package visibility** allows to declare a function to be visible anywhere inside, but not outside a package. Friend functions continue to be supported, although package visibility is in many cases more suitable. As a more concise notation, package and friend functions can be simply declared as `package fun` or `friend fun`, respectively, instead of the longer `public(package) fun` and `public(friend) fun`. This feature is documented [here](/build/smart-contracts/book/functions#package-visibility).

- **Assert abort code optional** The `assert!` macro can now be used with just one argument, omitting the abort code, in which case a default code will be chosen. See also [here](/build/smart-contracts/book/abort-and-assert#assert).

- **New Cast Syntax** Until now, casts had to always be in parentheses, requiring code like `function((x as u256))`. This requirement is now dropped and casts can be top-level expressions without parenthesis, as in `function(x as u256)`. One still needs to write `(x as u64) + (y as u64)` in expressions. This similarly applies to the new enum variant test, `data is VersionedData::V1`.

- **Well-defined evaluation order** The evaluation order in the cases below is now well-defined (these were previously unspecified):
  - The (a) arguments to a function call, and the (b) operand expressions in a binary operation, are both evaluated from left-to-right.
  - Given a "mutate" expression (see [mutating through a reference](/build/smart-contracts/book/variables#mutating-through-a-reference)) of the form `*lexp = rexp`, where `lexp` is an expression of type `&mut T` and `rexp` is an expression of type `T`, `rexp` is evaluated first, followed by `lexp`.

- **Bug fix for acquires annotation** [A function should be annotated with `acquires`](/build/smart-contracts/book/functions#acquires) if and only if it accesses a resource using `move_from`, `borrow_global`, or `borrow_global_mut`, either directly or transitively through a call. Otherwise, it is an error. Previously, when the transitive call graph included a cycle, such errors were not reported: this was incorrect behavior. We have now corrected this behavior to report these errors even when the transitive call graph has cycles.

# Move Tutorial

> Learn about move tutorial in Move programming language for Aptos smart contract development.

Please refer to the [Move Core Language Tutorial](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/move-tutorial).

# Package Upgrades

> Learn how to upgrade Move packages safely with compatibility checks and migration strategies on Aptos.

import { Aside } from '@astrojs/starlight/components';

Move code (e.g., Move modules) on the Aptos blockchain can be upgraded. This
allows code owners and module developers to update and evolve their contracts
under a single, stable, well-known account address that doesn't change. If a
module upgrade happens, all consumers of that module will automatically receive
the latest version of the code (e.g., the next time they interact with it).

The Aptos blockchain natively supports different _upgrade policies_, which allow
move developers to explicitly define the constraints around how their move code
can be upgraded. The default policy is _backwards compatible_. This means that
code upgrades are accepted only if they guarantee that no existing resource storage
or public APIs are broken by the upgrade (including public functions).
This compatibility checking is possible because of Move's strongly typed bytecode
semantics.

We note, however, that even compatible upgrades can have hazardous effects on
applications and dependent Move code (for example, if the semantics of the underlying
module are modified). As a result, developers should be careful when depending on
third-party Move code that can be upgraded on-chain. See
[Security considerations for dependencies](#security-considerations-for-dependencies)
for more details.

## How it works

Move code upgrades on the Aptos blockchain happen at the [Move package](/build/smart-contracts/book/packages)
granularity. A package specifies an upgrade policy in the `Move.toml` manifest:

```toml
[package]
name = "MyApp"
version = "0.0.1"
upgrade_policy = "compatible"
...
```

<Aside type="note">
  Aptos checks compatibility at the time a Move package is published via an Aptos transaction. This transaction will abort if deemed incompatible.
</Aside>

## How to upgrade

To upgrade already published Move code, simply attempt to republish the code at
the same address that it was previously published. This can be done by following the
instructions for code compilation and publishing using the
[Aptos CLI](/build/cli/working-with-move-contracts). For an example,
see the [Your First Move Module](/build/guides/first-move-module) tutorial.

## Upgrade policies

There are two different upgrade policies currently supported by Aptos:

- `compatible`: these upgrades must be backwards compatible, specifically:
  - For storage, all old struct declarations must be the same in
    the new code. This ensures that the existing state of storage is
    correctly interpreted by the new code. However, new struct declarations
    can be added.
  - For APIs, all existing public functions must have the same signature as
    before. New functions, including public and entry functions, can be added.
- `immutable`: the code is not upgradeable and is guaranteed to stay the same
  forever.

Those policies are ordered regarding strength such that `compatible < immutable`,
i.e., compatible is weaker than immutable. The policy of a package on-chain can
only get stronger, not weaker. Moreover, the policy of all dependencies of a
package must be stronger or equal to the policy of the given package. For example,
an `immutable` package cannot refer directly or indirectly to a `compatible` package.
This gives users the guarantee that no unexpected updates can happen under the hood.

Note that there is one exception to the above rule: framework packages
installed at addresses `0x1` to `0xa` are exempted from the dependency check.
This is necessary so one can define an `immutable` package based on the standard
libraries, which have the `compatible` policy to allow critical upgrades and fixes.

## Compatibility rules

When using `compatible` upgrade policy, a module package can be upgraded. However, updates to existing modules already
published previously need to be compatible and follow the rules below:

- All existing structs' fields cannot be updated. This means no new fields can be added and existing fields cannot be
  modified.
- All public and entry functions cannot change their signature (argument types, type argument, return types). However,
  argument names can change.
- `public(friend)` functions are treated as private and thus their signature can arbitrarily change. This is safe as
  only modules in the same package can call friend functions anyway, and they need to be updated if the signature changes.
- [Enum type upgrade compatibility rules](/build/smart-contracts/book/enums#enum-type-upgrade-compatibility).
- Existing abilities on a struct/enum type cannot be removed (but abilities can be added).

When updating your modules, if you see an incompatible error, make sure to check the above rules and fix any violations.

## Security considerations for dependencies

As mentioned above, even compatible upgrades can have disastrous effects for
applications that depend on the upgraded code. These effects can come from bugs,
but they can also be the result of malicious upgrades. For example,
an upgraded dependency can suddenly make all functions abort, breaking the
operation of your Move code. Alternatively, an upgraded dependency can make
all functions suddenly cost much more gas to execute then before the upgrade.
As result, dependencies to upgradeable packages need to be handled with care:

- The safest dependency is, of course, an `immutable` package. This guarantees
  that the dependency will never change, including its transitive dependencies.
  In order to update an immutable package, the owner would have to introduce a
  new major version, which is practically like deploying a new, separate
  and independent package. This is because major versioning can be expressed
  only by name (e.g., `module feature_v1` and `module feature_v2`). However,
  not all package owners like to publish their code as `immutable`, because this
  takes away the ability to fix bugs and update the code in place.
- If you have a dependency to a `compatible` package, it is highly
  recommended you know and understand the entity publishing the package.
  The highest level of assurance is when the package is governed by a
  Decentralized Autonomous Organization (DAO) where no single user can initiate
  an upgrade; a vote or similar has to be taken. This is the case for the Aptos
  framework.

## Programmatic upgrade

In general, Aptos offers, via the Move module `aptos_framework::code`,
ways to publish code from anywhere in your smart contracts. However,
notice that code published in the current transaction can be executed
only after that transaction ends.

The Aptos framework itself, including all the on-chain administration logic, is
an example for programmatic upgrade. The framework is marked as `compatible`.
Upgrades happen via specific generated governance scripts. For more details,
see [Aptos Governance](/network/blockchain/governance).

# Packages

> Learn about packages in Move programming language for Aptos smart contract development.

import { FileTree } from '@astrojs/starlight/components';

Packages allow Move programmers to more easily re-use code and share it
across projects. The Move package system allows programmers to easily do the following:

- Define a package containing Move code;
- Parameterize a package by [named addresses](/build/smart-contracts/book/address);
- Import and use packages in other Move code and instantiate named addresses;
- Build packages and generate associated compilation artifacts from packages; and
- Work with a common interface around compiled Move artifacts.

## Package Layout and Manifest Syntax

A Move package source directory contains a `Move.toml` package manifest
file along with a set of subdirectories:

<FileTree>
  - a\_move\_package/
    - Move.toml
    - sources (required)/
      - module.move
      - \*.move
    - examples (optional, test & dev mode)/
    - scripts (optional, can also put in sources)/
    - doc\_templates (optional)/
    - tests (optional, test mode)/
</FileTree>

The directories marked `required` _must_ be present in order for the directory
to be considered a Move package and to be compiled. Optional directories can
be present, and if so will be included in the compilation process. Depending on
the mode that the package is built with (`test` or `dev`), the `tests` and
`examples` directories will be included as well.

The `sources` directory can contain both Move modules and Move scripts (both
Move scripts and modules containing script functions). The `examples`
directory can hold additional code to be used only for development and/or
tutorial purposes that will not be included when compiled outside `test` or
`dev` mode.

A `scripts` directory is supported so Move scripts can be separated
from modules if that is desired by the package author. The `scripts`
directory will always be included for compilation if it is present.
Documentation will be built using any documentation templates present in
the `doc_templates` directory.

### Move.toml

The Move package manifest is defined within the `Move.toml` file and has the
following syntax. Optional fields are marked with `*`, `+` denotes
one or more elements:

```toml filename="Move.toml"
[package]
name = <string>                  # e.g., "MoveStdlib"
version = "<uint>.<uint>.<uint>" # e.g., "0.1.1"
license* = <string>              # e.g., "MIT", "GPL", "Apache 2.0"
authors* = [<string>]            # e.g., ["Joe Smith (joesmith@noemail.com)", "Jane Smith (janesmith@noemail.com)"]

[addresses]  # (Optional section) Declares named addresses in this package and instantiates named addresses in the package graph
# One or more lines declaring named addresses in the following format
<addr_name> = "_" | "<hex_address>" # e.g., std = "_" or my_addr = "0xC0FFEECAFE"

[dependencies] # (Optional section) Paths to dependencies and instantiations or renamings of named addresses from each dependency
# One or more lines declaring dependencies in the following format
<string> = { local = <string>, addr_subst* = { (<string> = (<string> | "<hex_address>"))+ } } # local dependencies
<string> = { git = <URL ending in .git>, subdir=<path to dir containing Move.toml inside git repo>, rev=<git commit hash or branch name>, addr_subst* = { (<string> = (<string> | "<hex_address>"))+ } } # git dependencies

[dev-addresses] # (Optional section) Same as [addresses] section, but only included in "dev" and "test" modes
# One or more lines declaring dev named addresses in the following format
<addr_name> = "_" | "<hex_address>" # e.g., std = "_" or my_addr = "0xC0FFEECAFE"

[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in "dev" and "test" modes
# One or more lines declaring dev dependencies in the following format
<string> = { local = <string>, addr_subst* = { (<string> = (<string> | <address>))+ } }
```

An example of a minimal package manifest with one local dependency and one git dependency:

```toml
[package]
name = "AName"
version = "0.0.0"
```

An example of a more standard package manifest that also includes the Move
standard library and instantiates the named address `Std` from it with the
address value `0x1`:

```toml
[package]
name = "AName"
version = "0.0.0"
license = "Apache 2.0"

[addresses]
address_to_be_filled_in = "_"
specified_address = "0xB0B"

[dependencies]
# Local dependency
LocalDep = { local = "projects/move-awesomeness", addr_subst = { "std" = "0x1" } }
# Git dependency
MoveStdlib = { git = "https://github.com/aptos-labs/aptos-framework", subdir="move-stdlib", rev = "mainnet" }

[dev-addresses] # For use when developing this module
address_to_be_filled_in = "0x101010101"
```

Most of the sections in the package manifest are self-explanatory, but named
addresses can be a bit difficult to understand, so it's worth examining them in
a bit more detail.

## Named Addresses During Compilation

Recall that Move has [named addresses](/build/smart-contracts/book/address) and that
named addresses cannot be declared in Move. Because of this, until now
named addresses and their values needed to be passed to the compiler on the
command line. With the Move package system this is no longer needed, and
you can declare named addresses in the package, instantiate other named
addresses in scope, and rename named addresses from other packages within
the Move package system manifest file. Let's go through each of these
individually:

### Declaration

Let's say we have a Move module in `example_pkg/sources/A.move` as follows:

```move
module named_addr::A {
  public fun x(): address { @named_addr }
}
```

We could in `example_pkg/Move.toml` declare the named address `named_addr` in
two different ways. The first:

```toml
[package]
name = "ExamplePkg"
# ...
[addresses]
named_addr = "_"
```

Declares `named_addr` as a named address in the package `ExamplePkg` and
that _this address can be any valid address value_. Therefore, an importing
package can pick the value of the named address `named_addr` to be any address
it wishes. Intuitively you can think of this as parameterizing the package
`ExamplePkg` by the named address `named_addr`, and the package can then be
instantiated later on by an importing package.

`named_addr` can also be declared as:

```toml
[package]
name = "ExamplePkg"
# ...
[addresses]
named_addr = "0xCAFE"
```

which states that the named address `named_addr` is exactly `0xCAFE` and cannot be
changed. This is useful so other importing packages can use this named
address without needing to worry about the exact value assigned to it.

With these two different declaration methods, there are two ways that
information about named addresses can flow in the package graph:

- The former ("unassigned named addresses") allows named address values to flow
  from the importation site to the declaration site.
- The latter ("assigned named addresses") allows named address values to flow
  from the declaration site upwards in the package graph to usage sites.

With these two methods for flowing named address information throughout the
package graph the rules around scoping and renaming become important to
understand.

## Scoping and Renaming of Named Addresses

A named address `N` in a package `P` is in scope if:

1. It declares a named address `N`; or
2. A package in one of `P`'s transitive dependencies declares the named address
   `N` and there is a dependency path in the package graph between `P` and the
   declaring package of `N` with no renaming of `N`.

Additionally, every named address in a package is exported. Because of this and
the above scoping rules each package can be viewed as coming with a set of
named addresses that will be brought into scope when the package is imported,
e.g., if the `ExamplePkg` package was imported, that importation would bring
into scope the `named_addr` named address. Because of this, if `P` imports two
packages `P1` and `P2` both of which declare a named address `N` an issue
arises in `P`: which "`N`" is meant when `N` is referred to in `P`? The one
from `P1` or `P2`? To prevent this ambiguity around which package a named
address is coming from, we enforce that the sets of scopes introduced by all
dependencies in a package are disjoint, and provide a way to _rename named
addresses_ when the package that brings them into scope is imported.

Renaming a named address when importing can be done as follows in our `P`,
`P1`, and `P2` example above:

```toml
[package]
name = "P"
# ...
[dependencies]
P1 = { local = "some_path_to_P1", addr_subst = { "P1N" = "N" } }
P2 = { local = "some_path_to_P2"  }
```

With this renaming `N` refers to the `N` from `P2` and `P1N` will refer to `N`
coming from `P1`:

```move
module N::A {
    public fun x(): address { @P1N }
}
```

It is important to note that _renaming is not local_: once a named address `N`
has been renamed to `N2` in a package `P` all packages that import `P` will not
see `N` but only `N2` unless `N` is reintroduced from outside of `P`. This is
why rule (2) in the scoping rules at the start of this section specifies a
"dependency path in the package graph between `P` and the declaring
package of `N` with no renaming of `N`."

### Instantiation

Named addresses can be instantiated multiple times across the package graph as
long as it is always with the same value. It is an error if the same named
address (regardless of renaming) is instantiated with differing values across
the package graph.

A Move package can only be compiled if all named addresses resolve to a value.
This presents issues if the package wishes to expose an uninstantiated named
address. This is what the `[dev-addresses]` section solves. This section can
set values for named addresses, but cannot introduce any named addresses.
Additionally, only the `[dev-addresses]` in the root package are included in
`dev` mode. For example a root package with the following manifest would not compile
outside of `dev` mode since `named_addr` would be uninstantiated:

```toml
[package]
name = "ExamplePkg"
# ...
[addresses]
named_addr = "_"

[dev-addresses]
named_addr = "0xC0FFEE"
```

## Usage, Artifacts, and Data Structures

The Move package system comes with a command line option as part of the Move
CLI `move <flags> <command> <command_flags>`. Unless a
particular path is provided, all package commands will run in the current working
directory. The full list of commands and flags for the Move CLI can be found by
running `move --help`.

### Usage

A package can be compiled either through the Move CLI commands, or as a library
command in Rust with the function `compile_package`. This will create a
`CompiledPackage` that holds the compiled bytecode along with other compilation
artifacts (source maps, documentation, ABIs) in memory. This `CompiledPackage`
can be converted to an `OnDiskPackage` and vice versa -- the latter being the data of
the `CompiledPackage` laid out in the file system in the following format:

<FileTree>
  - a\_move\_package/
    - .../
    - build/
      - dependency\_name/
        - BuildInfo.yaml
        - bytecode\_modules/
          - module\_name.mv
          - \*.mv
        - source\_maps/
          - module\_name.mvsm
          - \*.mvsm
        - bytecode\_scripts/
          - script\_name.mv
          - \*.mv
        - abis/
          - script\_name.abi
          - \*.abi
          - module\_name/
            - function\_name.abi
            - \*.abi
        - sources/
          - module\_name.move
      - dependency\_name2 .../
</FileTree>

See the `move-package` crate for more information on these data structures and
how to use the Move package system as a Rust library.

## Using Bytecode for Dependencies

Move bytecode can be used as dependencies when the Move source code for those dependencies are not available locally. To use this feature, you will need co-locate the files in directories at the same level and then specify their paths in the corresponding `Move.toml` files.

## Requirements and limitations

Using local bytecode as dependencies requires bytecode files to be downloaded locally, and the actual address for each named address must be specified in either `Move.toml` or through `--named-addresses`.

Note, both `aptos move prove` and `aptos move test` commands, currently, do not support bytecode as dependencies.

## Recommended structure

We use an example to illustrate the development flow of using this feature. Suppose we want to compile the package `A`. The package layout is:

<FileTree>
  - A/
    - Move.toml
    - sources/
      - AModule.move
</FileTree>

`A.move` is defined below, depending on the modules `Bar` and `Foo`:

```move filename="A/AModule.move"
module A::AModule {
    use B::Bar;
    use C::Foo;
    public fun foo(): u64 {
        Bar::foo() + Foo::bar()
    }
}
```

Suppose the source of `Bar` and `Foo` are not available but the corresponding bytecode `Bar.mv` and `Foo.mv` are available locally. To use them as dependencies, we would:

Specify `Move.toml` for `Bar` and `Foo`. Note that named addresses are already instantiated with the actual address in the bytecode. In our example, the actual address for `C` is already bound to `0x3`. As a result, `[addresses]` must be specified `C` as `0x3`, as shown below:

```toml filename="workspace/C/Move.toml"
[package]
name = "Foo"
version = "0.0.0"

[addresses]
C = "0x3"
```

Place the bytecode file and the corresponding `Move.toml` file in the same directory with the bytecode in a `build` subdirectory. Note an empty `sources` directory is **required**. For instance, the layout of the folder `B` (for the package `Bar`) and `C` (for the package `Foo`) would resemble:

<FileTree>
  - workspace/
    - A/
      - Move.toml
      - sources/
        - AModule.move
    - B/
      - Move.toml
      - sources/
      - build/
        - Bar.mv
    - C/
      - Move.toml
      - sources/
      - build/
        - Foo/
          - bytecode\_modules/
            - Foo.mv
</FileTree>

Specify `[dependencies]` in the `Move.toml` of the target (first) package with the location of the dependent (secondary) packages. For instance, assuming all three package directories are at the same level, `Move.toml` of `A` would resemble:

```toml filename="workspace/A/Move.toml"
[package]
name = "A"
version = "0.0.0"

[addresses]
A = "0x2"

[dependencies]
Bar = { local = "../B" }
Foo = { local = "../C" }
```

Note that if both the bytecode and the source code of the same package exist in the search paths, the compiler will complain that the declaration is duplicated.

## Overriding the Standard Libraries

When working with third-party packages, you might encounter issues where different versions of the Move and Aptos standard library packages are referenced.

This can lead to package resolution failures.

```
"Error": "Move compilation failed:
  Unable to resolve packages for package 'C':
    While resolving dependency 'B' in package 'C':
      Unable to resolve package dependency 'B':
        While resolving dependency 'AptosFramework' in package 'B':
          Unable to resolve package dependency 'AptosFramework':
            Conflicting dependencies found: package 'AptosFramework' conflicts with 'AptosFramework'
```

To resolve this, you can override the standard library packages using a command-line option. This allows you to enforce a specific version of the standard libraries across your entire dependency tree.

You can apply the override to commands like `aptos move compile`, `aptos move run`, and others. Here is the syntax:

```
--override-std <network name>
```

Where `network_name` can be one of the following:

- devnet
- testnet
- mainnet

# References

> Learn about references in Move for borrowing values, memory safety, and efficient data access without ownership transfer.

Move has two types of references: immutable `&` and mutable `&mut`. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.

For more details on the rules of references, see [Structs and Resources](/build/smart-contracts/book/structs-and-resources)

## Reference Operators

Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation `e: T` for "expression `e`
has type `T`".

| Syntax      | Type                                                  | Description                                                    |
| ----------- | ----------------------------------------------------- | -------------------------------------------------------------- |
| `&e`        | `&T` where `e: T` and `T` is a non-reference type     | Create an immutable reference to `e`                           |
| `&mut e`    | `&mut T` where `e: T` and `T` is a non-reference type | Create a mutable reference to `e`.                             |
| `&e.f`      | `&T` where `e.f: T`                                   | Create an immutable reference to field `f` of struct `e`.      |
| `&mut e.f`  | `&mut T` where `e.f: T`                               | Create a mutable reference to field `f` of struct`e`.          |
| `freeze(e)` | `&T` where `e: &mut T`                                | Convert the mutable reference `e` into an immutable reference. |

The `&e.f` and `&mut e.f` operators can be used both to create a new reference into a struct or to
extend an existing reference:

```move
script {
  fun example() {
    let s = S { f: 10 };
    let f_ref1: &u64 = &s.f; // works
    let s_ref: &S = &s;
    let f_ref2: &u64 = &s_ref.f; // also works
  }
}
```

A reference expression with multiple fields works as long as both structs are in the same module:

```move
module 0x42::example {
  struct A { b: B }
  struct B { c : u64 }

  fun f(a: &A): &u64 {
    &a.b.c
  }
}
```

Finally, note that references to references are not allowed:

```move
script {
  fun example() {
    let x = 7;
    let y: &u64 = &x;
    let z: &&u64 = &y; // will not compile
  }
}
```

## Reading and Writing Through References

Both mutable and immutable references can be read to produce a copy of the referenced value.

Only mutable references can be written. A write `*x = v` discards the value previously stored in `x`
and updates it with `v`.

Both operations use the C-like `*` syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.

| Syntax     | Type                                | Description                         |
| ---------- | ----------------------------------- | ----------------------------------- |
| `*e`       | `T` where `e` is `&T` or `&mut T`   | Read the value pointed to by `e`    |
| `*e1 = e2` | `()` where `e1: &mut T` and `e2: T` | Update the value in `e1` with `e2`. |

In order for a reference to be read, the underlying type must have the
[`copy` ability](/build/smart-contracts/book/abilities) as reading the reference creates a new copy of the value. This rule
prevents the copying of resource values:

```move
module 0x42::coin {
  struct Coin {} // Note does not have copy

  fun copy_resource_via_ref_bad(c: Coin) {
      let c_ref = &c;
      let counterfeit: Coin = *c_ref; // not allowed!
      pay(c);
      pay(counterfeit);
  }
}
```

Dually: in order for a reference to be written to, the underlying type must have the
[`drop` ability](/build/smart-contracts/book/abilities) as writing to the reference will discard (or "drop") the old value.
This rule prevents the destruction of resource values:

```move
module 0x42::coin {
  struct Coin {} // Note does not have drop

  fun destroy_resource_via_ref_bad(ten_coins: Coin, c: Coin) {
      let ref = &mut ten_coins;
      *ref = c; // not allowed--would destroy 10 coins!
  }
}
```

## `freeze` inference

A mutable reference can be used in a context where an immutable reference is expected:

```move
script {
  fun example() {
    let x = 7;
    let y: &u64 = &mut x;
  }
}
```

This works because the under the hood, the compiler inserts `freeze` instructions where they are
needed. Here are a few more examples of `freeze` inference in action:

```move
module 0x42::example {
  fun takes_immut_returns_immut(x: &u64): &u64 { x }

  // freeze inference on return value
  fun takes_mut_returns_immut(x: &mut u64): &u64 { x }

  fun expression_examples() {
    let x = 0;
    let y = 0;
    takes_immut_returns_immut(&x); // no inference
    takes_immut_returns_immut(&mut x); // inferred freeze(&mut x)
    takes_mut_returns_immut(&mut x); // no inference

    assert!(&x == &mut y, 42); // inferred freeze(&mut y)
  }

  fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &u64 = &x;

    imm_ref = &x; // no inference
    imm_ref = &mut y; // inferred freeze(&mut y)
  }
}
```

### Subtyping

With this `freeze` inference, the Move type checker can view `&mut T` as a subtype of `&T`. As shown
above, this means that anywhere for any expression where a `&T` value is used, a `&mut T` value can
also be used. This terminology is used in error messages to concisely indicate that a `&mut T` was
needed where a `&T` was supplied. For example

```move
module 0x42::example {
  fun read_and_assign(store: &mut u64, new_value: &u64) {
    *store = *new_value
  }

  fun subtype_examples() {
    let x: &u64 = &0;
    let y: &mut u64 = &mut 1;

    x = &mut 1; // valid
    y = &2; // invalid!

    read_and_assign(y, x); // valid
    read_and_assign(x, y); // invalid!
  }
}
```

will yield the following error messages

```shellscript
error:

    ‚îå‚îÄ‚îÄ example.move:12:9 ‚îÄ‚îÄ‚îÄ
    ‚îÇ
 12 ‚îÇ         y = &2; // invalid!
    ‚îÇ         ^ Invalid assignment to local 'y'
    ¬∑
 12 ‚îÇ         y = &2; // invalid!
    ‚îÇ             -- The type: '&{integer}'
    ¬∑
  9 ‚îÇ         let y: &mut u64 = &mut 1;
    ‚îÇ                -------- Is not a subtype of: '&mut u64'
    ‚îÇ

error:

    ‚îå‚îÄ‚îÄ example.move:15:9 ‚îÄ‚îÄ‚îÄ
    ‚îÇ
 15 ‚îÇ         read_and_assign(x, y); // invalid!
    ‚îÇ         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of '0x42::example::read_and_assign'. Invalid argument for parameter 'store'
    ¬∑
  8 ‚îÇ         let x: &u64 = &0;
    ‚îÇ                ---- The type: '&u64'
    ¬∑
  3 ‚îÇ     fun read_and_assign(store: &mut u64, new_value: &u64) {
    ‚îÇ                                -------- Is not a subtype of: '&mut u64'
    ‚îÇ
```

The only other types currently that has subtyping are [tuples](/build/smart-contracts/book/tuples)

## Ownership

Both mutable and immutable references can always be copied and extended _even if there are existing
copies or extensions of the same reference_:

```move
script {
  fun reference_copies(s: &mut S) {
    let s_copy1 = s; // ok
    let s_extension = &mut s.f; // also ok
    let s_copy2 = s; // still ok
    // ...
  }
}
```

This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
[copies](/build/smart-contracts/book/variables#move-and-copy), but equally strict in ensuring unique ownership of mutable
references before writes.

### References Cannot Be Stored

References and tuples are the _only_ types that cannot be stored as a field value of structs, which
also means that they cannot exist in global storage. All references created during program execution
will be destroyed when a Move program terminates; they are entirely ephemeral. This invariant is
also true for values of types without the `store` [ability](/build/smart-contracts/book/abilities), but note that
references and tuples go a step further by never being allowed in structs in the first place.

This is another difference between Move and Rust, which allows references to be stored inside of
structs.

Currently, Move cannot support this because references cannot be
[serialized](https://en.wikipedia.org/wiki/Serialization), but _every Move value must be
serializable_. This requirement comes from Move's
[persistent global storage](/build/smart-contracts/book/global-storage-structure), which needs to serialize values to
persist them across program executions. Structs can be written to global storage, and thus they must
be serializable.

One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs _and_ ban those structs from existing in global storage. We could perhaps allow
references inside of structs that do not have the `store` [ability](/build/smart-contracts/book/abilities), but that would
not completely solve the problem: Move has a fairly complex system for tracking static reference
safety, and this aspect of the type system would also have to be extended to support storing
references inside of structs. In short, Move's type system (particularly the aspects around
reference safety) would have to expand to support stored references. But it is something we are
keeping an eye on as the language evolves.

# Signer

> Understand the signer type in Move for transaction authentication and authorization in Aptos smart contracts.

`signer` is a built-in Move resource type. A `signer` is a
[capability](https://en.wikipedia.org/wiki/Object-capability_model) that allows the holder to act on
behalf of a particular `address`. You can think of the native implementation as being:

```move
module 0x1::signer {
  struct signer has drop { a: address }
}
```

A `signer` is somewhat similar to a Unix [UID](https://en.wikipedia.org/wiki/User_identifier) in
that it represents a user authenticated by code _outside_ of Move (e.g., by checking a cryptographic
signature or password).

## Comparison to `address`

A Move program can create any `address` value without special permission using address literals:

```move
script {
  fun example() {
    let a1 = @0x1;
    let a2 = @0x2;
    // ... and so on for every other possible address
  }
}
```

However, `signer` values are special because they cannot be created via literals or
instructions--only by the Move VM. Before the VM runs a script with parameters of type `signer`, it
will automatically create `signer` values and pass them into the script:

```move
script {
    use std::signer;
    fun main(s: signer) {
        assert!(signer::address_of(&s) == @0x42, 0);
    }
}
```

This script will abort with code `0` if the script is sent from any address other than `0x42`.

A Move script can have an arbitrary number of `signer`s as long as the `signer`s are a prefix
to any other arguments. In other words, all of the `signer` arguments must come first:

```move
script {
    use std::signer;
    fun main(s1: signer, s2: signer, x: u64, y: u8) {
        // ...
    }
}
```

This is useful for implementing _multi-signer scripts_ that atomically act with the authority of
multiple parties. For example, an extension of the script above could perform an atomic currency
swap between `s1` and `s2`.

## `signer` Operators

The `std::signer` standard library module provides two utility functions over `signer` values:

| Function                                    | Description                                                    |
| ------------------------------------------- | -------------------------------------------------------------- |
| `signer::address_of(&signer): address`      | Return the `address` wrapped by this `&signer`.                |
| `signer::borrow_address(&signer): &address` | Return a reference to the `address` wrapped by this `&signer`. |

In addition, the `move_to<T>(&signer, T)` [global storage operator](/build/smart-contracts/book/global-storage-operators)
requires a `&signer` argument to publish a resource `T` under `signer.address`'s account. This
ensures that only an authenticated user can elect to publish a resource under their `address`.

## Ownership

Unlike simple scalar values, `signer` values are not copyable, meaning they cannot be copied from
any operation whether it be through an explicit [`copy`](/build/smart-contracts/book/variables#move-and-copy) instruction
or through a [dereference `*`](/build/smart-contracts/book/references#reading-and-writing-through-references).

# Libraries

> Explore the Move standard library with built-in functions, utilities, and common patterns for smart contract development.

Aptos provides multiple useful libraries for developers. The complete up-to-date
docs can be found [here](/move-reference).

# Structs and Resources

> Learn about structs and resources in Move programming language for Aptos smart contract development.

A _struct_ is a user-defined data structure containing typed fields. Structs can store any
non-reference type, including other structs.

We often refer to struct values as _resources_ if they cannot be copied and cannot be dropped. In
this case, resource values must have ownership transferred by the end of the function. This property
makes resources particularly well served for defining global storage schemas or for representing
important values (such as a token).

By default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be
dropped, and cannot be stored in global storage. This means that all values have to have ownership
transferred (linear) and the values must be dealt with by the end of the program's execution
(ephemeral). We can relax this behavior by giving the struct [abilities](/build/smart-contracts/book/abilities) which allow
values to be copied or dropped and also to be stored in global storage or to define global storage
schemas.

## Defining Structs

Structs must be defined inside a module:

```move
module 0x2::m {
    struct Foo { x: u64, y: bool }
    struct Bar {}
    struct Baz { foo: Foo, }
    //                   ^ note: it is fine to have a trailing comma
}
```

Structs cannot be recursive, so the following definition is invalid:

```move
module 0x2::m {
  struct Foo { x: Foo }
  //              ^ error! Foo cannot contain Foo
}
```

For positional structs which used numbered instead of named fields, see
the [positional structs](#positional-structs) section.

As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used with certain operations (that copy it, drop it, store it in global storage, or use it as
a storage schema), structs can be granted [abilities](/build/smart-contracts/book/abilities) by annotating them with
`has <ability>`:

```move
module 0x2::m {
  struct Foo has copy, drop { x: u64, y: bool }
}
```

For more details, see the [annotating structs](/build/smart-contracts/book/abilities#annotating-structs) section.

### Naming

Structs must start with a capital letter `A` to `Z`. After the first letter, struct names can
contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, or digits `0` to `9`.

```move
module 0x2::m {
  struct Foo {}
  struct BAR {}
  struct B_a_z_4_2 {}
}
```

This naming restriction of starting with `A` to `Z` is in place to give room for future language
features. It may or may not be removed later.

## Using Structs

### Creating Structs

Values of a struct type can be created (or "packed") by indicating the struct name, followed by
value for each field:

```move
module 0x2::m {
  struct Foo has drop { x: u64, y: bool }
  struct Baz has drop { foo: Foo }

  fun example() {
    let foo = Foo { x: 0, y: false };
    let baz = Baz { foo };
  }
}
```

If you initialize a struct field with a local variable whose name is the same as the field, you can
use the following shorthand:

```move
module 0x2::m {
  fun example() {
    let baz = Baz { foo: foo };
    // is equivalent to
    let baz = Baz { foo };
  }
}
```

This is sometimes called "field name punning".

### Destroying Structs via Pattern Matching

Struct values can be destroyed by binding or assigning them patterns.

```move
module 0x2::m {
  struct Foo { x: u64, y: bool }
  struct Bar { foo: Foo }
  struct Baz {}

  fun example_destroy_foo() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y: foo_y } = foo;
    //        ^ shorthand for `x: x`

    // two new bindings
    //   x: u64 = 3
    //   foo_y: bool = false
  }

  fun example_destroy_foo_wildcard() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y: _ } = foo;

    // only one new binding since y was bound to a wildcard
    //   x: u64 = 3
  }

  fun example_destroy_foo_assignment() {
    let x: u64;
    let y: bool;
    Foo { x, y } = Foo { x: 3, y: false };

    // mutating existing variables x & y
    //   x = 3, y = false
  }

  fun example_foo_ref() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y } = &foo;

    // two new bindings
    //   x: &u64
    //   y: &bool
  }

  fun example_foo_ref_mut() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y } = &mut foo;

    // two new bindings
    //   x: &mut u64
    //   y: &mut bool
  }

  fun example_destroy_bar() {
    let bar = Bar { foo: Foo { x: 3, y: false } };
    let Bar { foo: Foo { x, y } } = bar;
    //             ^ nested pattern

    // two new bindings
    //   x: u64 = 3
    //   y: bool = false
  }

  fun example_destroy_baz() {
    let baz = Baz {};
    let Baz {} = baz;
  }
}
```

### Borrowing Structs and Fields

The `&` and `&mut` operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., `: &Foo`) to demonstrate the type of operations.

```move
module 0x2::m {
  fun example() {
    let foo = Foo { x: 3, y: true };
    let foo_ref: &Foo = &foo;
    let y: bool = foo_ref.y;  // reading a field via a reference to the struct
    let x_ref: &u64 = &foo.x;

    let x_ref_mut: &mut u64 = &mut foo.x;
    *x_ref_mut = 42;  // modifying a field via a mutable reference
  }
}
```

It is possible to borrow inner fields of nested structs:

```move
module 0x2::m {
  fun example() {
    let foo = Foo { x: 3, y: true };
    let bar = Bar { foo };

    let x_ref = &bar.foo.x;
  }
}
```

You can also borrow a field via a reference to a struct:

```move
module 0x2::m {
  fun example() {
    let foo = Foo { x: 3, y: true };
    let foo_ref = &foo;
    let x_ref = &foo_ref.x;
    // this has the same effect as let x_ref = &foo.x
  }
}
```

### Reading and Writing Fields

If a field is copyable, you can read and copy a field's value by dereferencing the borrowed field:

```move
module 0x2::m {
  fun example() {
    let foo = Foo { x: 3, y: true };
    let bar = Bar { foo: copy foo };
    let x: u64 = *&foo.x;
    let y: bool = *&foo.y;
    let foo2: Foo = *&bar.foo;
  }
}
```

The dot operator can be used to read and copy any copyable field of a struct without explicit
borrowing and dereferencing:

```move
module 0x2::m {
  fun example() {
    let foo = Foo { x: 3, y: true };
    let x = foo.x;  // x == 3
    let y = foo.y;  // y == true

    let bar = Bar { foo };
    let foo2: Foo = *&bar.foo; // `Foo` must be copyable
    let foo3: Foo = bar.foo;   // same as the statement above
  }
}
```

Dot operators can be chained to access nested fields:

```move
module 0x2::m {
  fun example() {
    let baz = Baz { foo: Foo { x: 3, y: true } };
    let x = baz.foo.x; // x = 3;
  }
}
```

Furthermore, the dot syntax can be used to modify fields.

```move
module 0x2::m {
  fun example() {
    let foo = Foo { x: 3, y: true };
    foo.x = 42;     // foo = Foo { x: 42, y: true }
    foo.y = !foo.y; // foo = Foo { x: 42, y: false }
    let bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }
    bar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }
    bar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }
  }
}
```

The dot syntax also works via a reference to a struct:

```move
module 0x2::m {
  fun example() {
    let foo = Foo { x: 3, y: true };
    let foo_ref = &mut foo;
    foo_ref.x = foo_ref.x + 1;
  }
}
```

## Privileged Struct Operations

Most struct operations on a struct type `T` can only be performed inside the module that declares
`T`:

- Struct types can only be created ("packed"), destroyed ("unpacked") inside the module that defines
  the struct.
- The fields of a struct are only accessible inside the module that defines the struct.

Following these rules, if you want to modify your struct outside the module, you will need to
provide public APIs for them. The end of the chapter contains some examples of this.

However, struct _types_ are always visible to another module or script:

```move
// m.move
module 0x2::m {
  struct Foo has drop { x: u64 }

  public fun new_foo(): Foo {
    Foo { x: 42 }
  }
}
```

```move
// n.move
module 0x2::n {
  use 0x2::m;

  struct Wrapper has drop {
    foo: m::Foo
  }

  fun f1(foo: m::Foo) {
    let x = foo.x;
    //      ^ error! cannot access fields of `foo` here
  }

  fun f2() {
    let foo_wrapper = Wrapper { foo: m::new_foo() };
  }
}
```

Note that structs do not have visibility modifiers (e.g., `public` or `private`).

## Ownership

As mentioned above in [Defining Structs](#defining-structs), structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world resources like money, as you do not want money to be duplicated or get lost in
circulation.

```move
module 0x2::m {
  struct Foo { x: u64 }

  public fun copying_resource() {
    let foo = Foo { x: 100 };
    let foo_copy = copy foo; // error! 'copy'-ing requires the 'copy' ability
    let foo_ref = &foo;
    let another_copy = *foo_ref // error! dereference requires the 'copy' ability
  }

  public fun destroying_resource1() {
    let foo = Foo { x: 100 };

    // error! when the function returns, foo still contains a value.
    // This destruction requires the 'drop' ability
  }

  public fun destroying_resource2(f: &mut Foo) {
    *f = Foo { x: 100 } // error!
                        // destroying the old value via a write requires the 'drop' ability
  }
}
```

To fix the second example (`fun destroying_resource1`), you would need to manually "unpack" the
resource:

```move
module 0x2::m {
  struct Foo { x: u64 }

  public fun destroying_resource1_fixed() {
    let foo = Foo { x: 100 };
    let Foo { x: _ } = foo;
  }
}
```

Recall that you are only able to deconstruct a resource within the module in which it is defined.
This can be leveraged to enforce certain invariants in a system, for example, conservation of money.

If on the other hand, your struct does not represent something valuable, you can add the abilities
`copy` and `drop` to get a struct value that might feel more familiar from other programming
languages:

```move
module 0x2::m {
  struct Foo has copy, drop { x: u64 }

  public fun run() {
    let foo = Foo { x: 100 };
    let foo_copy = copy foo;
    // ^ this code copies foo, whereas `let x = foo` or
    // `let x = move foo` both move foo

    let x = foo.x;            // x = 100
    let x_copy = foo_copy.x;  // x = 100

    // both foo and foo_copy are implicitly discarded when the function returns
  }
}
```

## Positional Structs

_Since language version 2.0_

A struct can be declared to have _positional fields_, fields which are not named
but numbered. Positional structs behave similar to regular structs,
except providing a different syntax which may be more suitable for use cases with
only a few fields.

Fields of positional structs are assigned in the order they appear. In the below
example, field `0` is of type `u64` and field `1` of type `u8`:

```move
module 0x2::m {
  struct Pair(u64, u8);
}
```

Abilities for positional structs are declared _after_ and not before the field list,

```move
module 0x2::m {
  struct Pair(u64, u8) has copy, drop;
}
```

For pure type tags, often used for phantom types in Move code, the list of arguments
can be also completely omitted:

```move
module 0x2::m {
  struct TypeTag has copy, drop;
}
```

Values of positional structs are created and deconstructed as shown below:
using `PositionalStructs(arguments)`:

```move
module 0x2::m {
  fun work() {
    let value = Pair(1, true);
    let Pair(number, boolean) = value;
    assert!(number == 1 && boolean == true);
  }
}
```

Fields of positional structs can be accessed using the position as a field selector. For example, in the above code example, `value.0` and `value.1` can be used to access the two fields without deconstructing the `value`.
`positional_struct.0`.

## Partial Patterns

_Since language version 2.0_

Patterns can use the `..` notation to match any remaining, non-listed fields in structs or variants with named fields, and omitted fields at either the beginning or end of a struct or variant with positional fields. Here are
some examples:

```move
module 0x2::m {
  struct Foo{ x: u8, y: u16, z: u32 }
  struct Bar(u8, u16, u32);

  fun foo_get_x(self: &Foo): u16 {
    let Foo{y, ..} = self;
    x
  }

  fun bar_get_0(self: &Foo): u8 {
    let Bar(x, ..) = self;
    x
  }

  fun bar_get_2(self: &Foo): u52 {
    // For positional structs, one can also put the
    // .. at the beginning.
    let Bar(.., z) = self;
    z
  }
}
```

Notice that partial patterns can currently not be used as the left-hand side of assignment.
While one can use `let Bar(x, ..) = v`, we do not yet support `let x; Bar(x, ..) = v`.

## Storing Resources in Global Storage

Structs with the `key` ability can be saved directly in
[persistent global storage](/build/smart-contracts/book/global-storage-operators). All values stored within those `key`
structs must have the `store` ability. See the [ability](/build/smart-contracts/book/abilities) and
[global storage](/build/smart-contracts/book/global-storage-operators) chapters for more detail.

## Examples

Here are two short examples of how you might use structs to represent valuable data (in the case of
`Coin`) or more classical data (in the case of `Point` and `Circle`).

### Example 1: Coin

{/* <!-- TODO link to access control for mint --> */}

```move
module 0x2::m {
  // We do not want the Coin to be copied because that would be duplicating this "money",
  // so we do not give the struct the 'copy' ability.
  // Similarly, we do not want programmers to destroy coins, so we do not give the struct the
  // 'drop' ability.
  // However, we *want* users of the modules to be able to store this coin in persistent global
  // storage, so we grant the struct the 'store' ability. This struct will only be inside of
  // other resources inside of global storage, so we do not give the struct the 'key' ability.
  struct Coin has store {
    value: u64,
  }

  public fun mint(value: u64): Coin {
    // You would want to gate this function with some form of access control to prevent
    // anyone using this module from minting an infinite amount of coins.
    Coin { value }
  }

  public fun withdraw(coin: &mut Coin, amount: u64): Coin {
    assert!(coin.value >= amount, 1000);
    coin.value = coin.value - amount;
    Coin { value: amount }
  }

  public fun deposit(coin: &mut Coin, other: Coin) {
    let Coin { value } = other;
    coin.value = coin.value + value;
  }

  public fun split(coin: Coin, amount: u64): (Coin, Coin) {
    let other = withdraw(&mut coin, amount);
    (coin, other)
  }

  public fun merge(coin1: Coin, coin2: Coin): Coin {
    deposit(&mut coin1, coin2);
    coin1
  }

  public fun destroy_zero(coin: Coin) {
    let Coin { value } = coin;
    assert!(value == 0, 1001);
  }
}
```

### Example 2: Geometry

```move
module 0x2::point {
  struct Point has copy, drop, store {
    x: u64,
    y: u64,
  }

  public fun new(x: u64, y: u64): Point {
    Point {
      x, y
    }
  }

  public fun x(p: &Point): u64 {
    p.x
  }

  public fun y(p: &Point): u64 {
    p.y
  }

  fun abs_sub(a: u64, b: u64): u64 {
    if (a < b) {
      b - a
    }
    else {
      a - b
    }
  }

  public fun dist_squared(p1: &Point, p2: &Point): u64 {
    let dx = abs_sub(p1.x, p2.x);
    let dy = abs_sub(p1.y, p2.y);
    dx*dx + dy*dy
  }
}
```

```move
module 0x2::circle {
  use 0x2::point::{Self, Point};

  struct Circle has copy, drop, store {
    center: Point,
    radius: u64,
  }

  public fun new(center: Point, radius: u64): Circle {
    Circle { center, radius }
  }

  public fun overlaps(c1: &Circle, c2: &Circle): bool {
    let dist_squared_value = point::dist_squared(&c1.center, &c2.center);
    let r1 = c1.radius;
    let r2 = c2.radius;
    dist_squared_value <= r1*r1 + 2*r1*r2 + r2*r2
  }
}
```

# Table of Contents

> Learn about summary in Move programming language for Aptos smart contract development.

## Getting Started

- [Modules and Scripts](/build/smart-contracts/book/modules-and-scripts)
- [Move Tutorial](/build/smart-contracts/book/move-tutorial)

## Language Release Notes

- [Move 2](/build/smart-contracts/book/move-2)

## Primitive Types

- [Integers](/build/smart-contracts/book/integers)
- [Bool](/build/smart-contracts/book/bool)
- [Address](/build/smart-contracts/book/address)
- [Vector](/build/smart-contracts/book/vector)
- [Signer](/build/smart-contracts/book/signer)
- [References](/build/smart-contracts/book/references)
- [Tuples and Unit](/build/smart-contracts/book/tuples)

## Basic Concepts

- [Local Variables and Scopes](/build/smart-contracts/book/variables)
- [Equality](/build/smart-contracts/book/equality)
- [Abort and Assert](/build/smart-contracts/book/abort-and-assert)
- [Conditionals](/build/smart-contracts/book/conditionals)
- [While, For, and Loop](/build/smart-contracts/book/loops)
- [Functions](/build/smart-contracts/book/functions)
- [Structs and Resources](/build/smart-contracts/book/structs-and-resources)
- [Enum Types](/build/smart-contracts/book/enums)
- [Constants](/build/smart-contracts/book/constants)
- [Generics](/build/smart-contracts/book/generics)
- [Type Abilities](/build/smart-contracts/book/abilities)
- [Uses and Aliases](/build/smart-contracts/book/uses)
- [Friends](/build/smart-contracts/book/friends)
- [Packages](/build/smart-contracts/book/packages)
- [Package Upgrades](/build/smart-contracts/book/package-upgrades)
- [Unit Tests](/build/smart-contracts/book/unit-testing)

## Global Storage

- [Global Storage Structure](/build/smart-contracts/book/global-storage-structure)
- [Global Storage Operators](/build/smart-contracts/book/global-storage-operators)

## Reference

- [Standard Library](/build/smart-contracts/book/standard-library)
- [Coding Conventions](/build/smart-contracts/book/coding-conventions)

# Tuples and Unit

> Understand tuple types in Move for grouping multiple values and function return patterns in smart contract development.

Move does not fully support tuples as one might expect coming from another language with them as a
[first-class value](https://en.wikipedia.org/wiki/First-class_citizen). However, in order to support multiple return values, Move has tuple-like
expressions. These expressions do not result in a concrete value at runtime (there are no tuples in
the bytecode), and as a result they are very limited: they can only appear in expressions (usually
in the return position for a function); they cannot be bound to local variables; they cannot be
stored in structs; and tuple types cannot be used to instantiate generics.

Similarly, [unit `()`](https://en.wikipedia.org/wiki/Unit_type) is a type created by the Move source language in order to be expression based.
The unit value `()` does not result in any runtime value. We can consider unit`()` to be an empty
tuple, and any restrictions that apply to tuples also apply to unit.

It might feel weird to have tuples in the language at all given these restrictions. But one of the
most common use cases for tuples in other languages is for functions to allow functions to return
multiple values. Some languages work around this by forcing the users to write structs that contain
the multiple return values. However, in Move, you cannot put references inside of
[structs](/build/smart-contracts/book/structs-and-resources). This required Move to support multiple return values. These
multiple return values are all pushed on the stack at the bytecode level. At the source level, these
multiple return values are represented using tuples.

## Literals

Tuples are created by a comma separated list of expressions inside of parentheses.

| Syntax          | Type                                                                         | Description                                                  |
| --------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `()`            | `(): ()`                                                                     | Unit, the empty tuple, or the tuple of arity 0               |
| `(e1, ..., en)` | `(e1, ..., en): (T1, ..., Tn)` where `e_i: Ti` s.t. `0 < i <= n` and `n > 0` | A `n`-tuple, a tuple of arity `n`, a tuple with `n` elements |

Note that `(e)` does not have type `(e): (t)`, in other words there is no tuple with one element. If
there is only a single element inside the parentheses, the parentheses are only used for
disambiguation and do not carry any other special meaning.

Sometimes, tuples with two elements are called "pairs" and tuples with three elements are called
"triples."

### Examples

```move
module 0x42::example {
  // all 3 of these functions are equivalent

  // when no return type is provided, it is assumed to be `()`
  fun returns_unit_1() { }

  // there is an implicit () value in empty expression blocks
  fun returns_unit_2(): () { }

  // explicit version of `returns_unit_1` and `returns_unit_2`
  fun returns_unit_3(): () { () }


  fun returns_3_values(): (u64, bool, address) {
    (0, false, @0x42)
  }
  fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {
    (x, 0, 1, b"foobar")
  }
}
```

## Operations

The only operation that can be done on tuples currently is destructuring.

### Destructuring

For tuples of any size, they can be destructured in either a `let` binding or in an assignment.

For example:

```move
module 0x42::example {
  // all 3 of these functions are equivalent
  fun returns_unit() {}
  fun returns_2_values(): (bool, bool) { (true, false) }
  fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) { (x, 0, 1, b"foobar") }

  fun examples(cond: bool) {
    let () = ();
    let (x, y): (u8, u64) = (0, 1);
    let (a, b, c, d) = (@0x0, 0, false, b"");

    () = ();
    (x, y) = if (cond) (1, 2) else (3, 4);
    (a, b, c, d) = (@0x1, 1, true, b"1");
  }

  fun examples_with_function_calls() {
    let () = returns_unit();
    let (x, y): (bool, bool) = returns_2_values();
    let (a, b, c, d) = returns_4_values(&0);

    () = returns_unit();
    (x, y) = returns_2_values();
    (a, b, c, d) = returns_4_values(&1);
  }
}
```

For more details, see [Move Variables](/build/smart-contracts/book/variables).

## Subtyping

Along with references, tuples are the only other type that have [subtyping](https://en.wikipedia.org/wiki/Subtyping) in Move. Tuples have
subtyping only in the sense that they subtype with references (in a covariant way).

For example:

```move
script {
  fun example() {
    let x: &u64 = &0;
    let y: &mut u64 = &mut 1;

    // (&u64, &mut u64) is a subtype of (&u64, &u64)
    // since &mut u64 is a subtype of &u64
    let (a, b): (&u64, &u64) = (x, y);

    // (&mut u64, &mut u64) is a subtype of (&u64, &u64)
    // since &mut u64 is a subtype of &u64
    let (c, d): (&u64, &u64) = (y, y);

    // error! (&u64, &mut u64) is NOT a subtype of (&mut u64, &mut u64)
    // since &u64 is NOT a subtype of &mut u64
    let (e, f): (&mut u64, &mut u64) = (x, y);
  }
}
```

## Ownership

As mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored
into local variables because of this (but it is likely that this feature will come soon). As such,
tuples can only be moved currently, as copying them would require putting them into a local variable
first.

# Unit Tests

> Learn about unit testing in Move programming language for Aptos smart contract development.

Unit testing for Move adds three new annotations to the Move source language:

- `#[test]`
- `#[test_only]`, and
- `#[expected_failure]`.

They respectively mark a function as a test, mark a module or module member (`use`, function, or struct) as code to be included for testing only, and mark that a test is expected to fail. These annotations can be placed on a function with any visibility. Whenever a module or module member is annotated as `#[test_only]` or `#[test]`, it will not be included in the compiled bytecode unless it is compiled for testing.

## Testing Annotations: Their Meaning and Usage

Both the `#[test]` and `#[expected_failure]` annotations can be used either with or without arguments.

Without arguments, the `#[test]` annotation can only be placed on a function with no parameters. This annotation simply marks this function as a test to be run by the unit testing harness.

```move
module 0x42::example {
  #[test] // OK
  fun this_is_a_test() { /* ... */ }

  #[test] // Will fail to compile since the test takes an argument
  fun this_is_not_correct(arg: signer) { /* ... */ }
}
```

### Expected Failure

A test can also be annotated as an `#[expected_failure]`. This
annotation marks that the test is expected to raise an error.

You can ensure that a test is aborting with a specific abort `<code>`
by annotating it with `#[expected_failure(abort_code = <code>)]`,
corresponding to the parameter to an `abort` statement (or
failing `assert!` macro).

Instead of an `abort_code`, an `expected_failure` may specify program
execution errors, such as `arithmetic_error`, `major_status`,
`vector_error`, and `out_of_gas`. For more specificity, a
`minor_status` may optionally be specified.

If the error is expected from a specific location, that may also be specified:
`#[expected_failure(abort_code = <code>, location = <loc>)]`.
If the test then fails with the right error but in a different module, the test will also fail.
Note that `<loc>` can be `Self`(in the current module) or a qualified name, e.g. `vector::std`.

Only functions that have the `#[test]` annotation can also be annotated as an #`[expected_failure]`.

```move
module 0x42::example {
  #[test]
  #[expected_failure]
  public fun this_test_will_abort_and_pass() { abort 1 }

  #[test]
  #[expected_failure]
  public fun test_will_error_and_pass() { 1/0; }

  #[test]
  #[expected_failure(abort_code = 0, location = Self)]
  public fun test_will_error_and_fail() { 1/0; }

  #[test, expected_failure] // Can have multiple in one attribute. This test will pass.
  public fun this_other_test_will_abort_and_pass() { abort 1 }

  #[test]
  #[expected_failure(vector_error, minor_status = 1, location = Self)]
  fun borrow_out_of_range() { /* ... */ }
  #[test]
  #[expected_failure(abort_code = 26113, location = extensions::table)]
  fun test_destroy_fails() { /* ... */ }
}
```

### Test parameters

With arguments, a test annotation takes the form `#[test(<param_name_1> = <address>, ..., <param_name_n> = <address>)]`. If a function is annotated in such a manner, the function's parameters must be a permutation of the parameters `<param_name_1>, ..., <param_name_n>`, i.e., the order of these parameters as they occur in the function and their order in the test annotation do not have to be the same, but they must be able to be matched up with each other by name.

Only parameters with a type of `signer` are supported as test parameters. If a parameter other than `signer` is supplied, the test will result in an error when run.

```move
module 0x42::example {
  #[test(arg = @0xC0FFEE)] // OK
  fun this_is_correct_now(arg: signer) { /* ... */ }

  #[test(wrong_arg_name = @0xC0FFEE)] // Not correct: arg name doesn't match
  fun this_is_incorrect(arg: signer) { /* ... */ }

  #[test(a = @0xC0FFEE, b = @0xCAFE)] // OK. We support multiple signer arguments, but you must always provide a value for that argument
  fun this_works(a: signer, b: signer) { /* ... */ }

  // somewhere a named address is declared
  #[test_only] // test-only named addresses are supported
  address TEST_NAMED_ADDR = @0x1;
  ...
  #[test(arg = @TEST_NAMED_ADDR)] // Named addresses are supported!
  fun this_is_correct_now(arg: signer) { /* ... */ }
}
```

### Arbitrary code to support tests

A module and any of its members can be declared as test only. In such a case the item will only be included in the compiled Move bytecode when compiled in test mode. Additionally, when compiled outside of test mode, any non-test `use`s of a `#[test_only]` module will raise an error during compilation.

```move
#[test_only] // test only attributes can be attached to modules
module 0x42::abc { /*... */ }

module 0x42::other {
  #[test_only] // test only attributes can be attached to named addresses
  address ADDR = @0x1;

  #[test_only] // .. to uses
  use 0x1::some_other_module;

  #[test_only] // .. to structs
  struct SomeStruct { /* ... */ }

  #[test_only] // .. and functions. Can only be called from test code, but not a test
  fun test_only_function(/* ... */) { /* ... */ }
}
```

## Running Unit Tests

Unit tests for a Move package can be run with the `aptos move test` command. See [package](/build/smart-contracts/book/packages) for more info.

When running tests, every test will either `PASS`, `FAIL`, or `TIMEOUT`. If a test case fails, the location of the failure along with the function name that caused the failure will be reported if possible. You can see an example of this below.

A test will be marked as timing out if it exceeds the maximum number of instructions that can be executed for any single test. This bound can be changed using the options below, and its default value is set to 100000 instructions. Additionally, while the result of a test is always deterministic, tests are run in parallel by default, so the ordering of test results in a test run is non-deterministic unless running with only one thread (see `OPTIONS` below).

There are also a number of options that can be passed to the unit testing binary to fine-tune testing and to help debug failing tests. These can be found using the help flag:

```shellscript filename="Terminal"
$ aptos move test -h
```

## Example

A simple module using some of the unit testing features is shown in the following example:

First create an empty package inside an empty directory:

```shellscript filename="Terminal"
$ aptos move init --name TestExample
```

Next add the following to the `Move.toml`:

```toml
[dependencies]
MoveStdlib = { git = "https://github.com/aptos-labs/aptos-framework.git", subdir="aptos-move/framework/move-stdlib", rev = "main", addr_subst = { "std" = "0x1" } }
```

Next add the following module under the `sources` directory:

```move
// filename: sources/my_module.move
module 0x1::my_module {

  struct MyCoin has key { value: u64 }

  public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {
    assert!(coin.value > 0, 0);
    coin
  }

  public fun has_coin(addr: address): bool {
    exists<MyCoin>(addr)
  }

  #[test]
  fun make_sure_non_zero_coin_passes() {
    let coin = MyCoin { value: 1 };
    let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
  }

  #[test]
  // Or #[expected_failure] if we don't care about the abort code
  #[expected_failure(abort_code = 0, location = Self)]
  fun make_sure_zero_coin_fails() {
    let coin = MyCoin { value: 0 };
    let MyCoin { value: _ } = make_sure_non_zero_coin(coin);
  }

  #[test_only] // test only helper function
  fun publish_coin(account: &signer) {
    move_to(account, MyCoin { value: 1 })
  }

  #[test(a = @0x1, b = @0x2)]
  fun test_has_coin(a: signer, b: signer) {
    publish_coin(&a);
    publish_coin(&b);
    assert!(has_coin(@0x1), 0);
    assert!(has_coin(@0x2), 1);
    assert!(!has_coin(@0x3), 1);
  }
}
```

### Running Tests

You can then run these tests with the `aptos move test` command:

```shellscript filename="Terminal"
$ aptos move test
BUILDING MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
Test result: OK. Total tests: 3; passed: 3; failed: 0
```

### Using Test Flags

#### `-f <str>` or `--filter <str>`

This will only run tests whose fully qualified name contains `<str>`. For example if we wanted to only run tests with `"zero_coin"` in their name:

```shellscript filename="Terminal"
$ aptos move test -f zero_coin
CACHED MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
Test result: OK. Total tests: 2; passed: 2; failed: 0
```

#### `--coverage`

This will compute code being covered by test cases and generate coverage summary.

```shellscript filename="Terminal"
$ aptos move test --coverage
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING TestExample
Running Move unit tests
[ PASS    ] 0x1::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x1::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x1::my_module::test_has_coin
Test result: OK. Total tests: 3; passed: 3; failed: 0
+-------------------------+
| Move Coverage Summary   |
+-------------------------+
Module 0000000000000000000000000000000000000000000000000000000000000001::my_module
>>> % Module coverage: 100.00
+-------------------------+
| % Move Coverage: 100.00  |
+-------------------------+
Please use `aptos move coverage -h` for more detailed source or bytecode test coverage of this package
```

Then by running `aptos move coverage`, we can get more detailed coverage information. These can be found using the help flag:

```shellscript filename="Terminal"
$ aptos move coverage -h
```

# Uses and Aliases

> Learn about uses in Move programming language for Aptos smart contract development.

The `use` syntax can be used to create aliases to members in other modules. `use` can be used to
create aliases that last either for the entire module, or for a given expression block scope.

## Syntax

There are several different syntax cases for `use`. Starting with the most simple, we have the
following for creating aliases to other modules

```move
use <address>::<module name>;
use <address>::<module name> as <module alias name>;
```

For example

```move
script {
  use std::vector;
  use std::vector as V;
}
```

`use std::vector;` introduces an alias `vector` for `std::vector`. This means that anywhere you
would want to use the module name `std::vector` (assuming this `use` is in scope), you could use
`vector` instead. `use std::vector;` is equivalent to `use std::vector as vector;`

Similarly `use std::vector as V;` would let you use `V` instead of `std::vector`

```move
module 0x42::example {
  use std::vector;
  use std::vector as V;

  fun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {
    let v1 = std::vector::empty();
    let v2 = vector::empty();
    let v3 = V::empty();
    (v1, v2, v3)
  }
}
```

If you want to import a specific module member (such as a function, struct, or constant). You can
use the following syntax.

```move
use <address>::<module name>::<module member>;
use <address>::<module name>::<module member> as <member alias>;
```

For example

```move
script {
  use std::vector::empty;
  use std::vector::empty as empty_vec;
}
```

This would let you use the function `std::vector::empty` without full qualification. Instead, you
could use `empty` and `empty_vec` respectively. Again, `use std::vector::empty;` is equivalent to
`use std::vector::empty as empty;`

```move
module 0x42::example {
  use std::vector::empty;
  use std::vector::empty as empty_vec;

  fun new_vecs(): (vector<u8>, vector<u8>, vector<u8>) {
    let v1 = std::vector::empty();
    let v2 = empty();
    let v3 = empty_vec();
    (v1, v2, v3)
  }
}
```

If you want to add aliases for multiple module members at once, you can do so with the following
syntax

```move
use <address>::<module name>::{<module member>, <module member> as <member alias> ... };
```

For example

```move
module 0x42::example {
  use std::vector::{push_back, length as len, pop_back};

  fun swap_last_two<T>(v: &mut vector<T>) {
    assert!(len(v) >= 2, 42);
    let last = pop_back(v);
    let second_to_last = pop_back(v);
    push_back(v, last);
    push_back(v, second_to_last)
  }
}
```

If you need to add an alias to the Module itself in addition to module members, you can do that in a
single `use` using `Self`. `Self` is a member of sorts that refers to the module.

```move
script {
  use std::vector::{Self, empty};
}
```

For clarity, all the following are equivalent:

```move
script {
  use std::vector;
  use std::vector as vector;
  use std::vector::Self;
  use std::vector::Self as vector;
  use std::vector::{Self};
  use std::vector::{Self as vector};
}
```

If needed, you can have as many aliases for any item as you like

```move
module 0x42::example {
  use std::vector::{
    Self,
    Self as V,
    length,
    length as len,
  };

  fun pop_twice<T>(v: &mut vector<T>): (T, T) {
    // all options available given the `use` above
    assert!(vector::length(v) > 1, 42);
    assert!(V::length(v) > 1, 42);
    assert!(length(v) > 1, 42);
    assert!(len(v) > 1, 42);

    (vector::pop_back(v), vector::pop_back(v))
  }
}
```

## Inside a `module`

Inside a `module` all `use` declarations are usable regardless of the order of declaration.

```move
module 0x42::example {
  use std::vector;

  fun example(): vector<u8> {
    let v = empty();
    vector::push_back(&mut v, 0);
    vector::push_back(&mut v, 10);
    v
  }

  use std::vector::empty;
}
```

The aliases declared by `use` in the module are usable within that module.

Additionally, the aliases introduced cannot conflict with other module members. See
[Uniqueness](#uniqueness) for more details

## Inside an expression

You can add `use` declarations to the beginning of any expression block

```move
module 0x42::example {

  fun example(): vector<u8> {
    use std::vector::{empty, push_back};

    let v = empty();
    push_back(&mut v, 0);
    push_back(&mut v, 10);
    v
  }
}
```

As with `let`, the aliases introduced by `use` in an expression block are removed at the end of that
block.

```move
module 0x42::example {

  fun example(): vector<u8> {
    let result = {
      use std::vector::{empty, push_back};
      let v = empty();
      push_back(&mut v, 0);
      push_back(&mut v, 10);
      v
    };
    result
  }
}
```

Attempting to use the alias after the block ends will result in an error

```move
module 0x42::example {
  fun example(): vector<u8> {
    let result = {
      use std::vector::{empty, push_back};
      let v = empty();
      push_back(&mut v, 0);
      push_back(&mut v, 10);
      v
    };
    let v2 = empty(); // ERROR!
//           ^^^^^ unbound function 'empty'
    result
  }
}
```

Any `use` must be the first item in the block. If the `use` comes after any expression or `let`, it
will result in a parsing error

```move
script {
  fun example() {
    {
      let x = 0;
      use std::vector; // ERROR!
      let v = vector::empty();
    }
  }
}

```

## Naming rules

Aliases must follow the same rules as other module members. This means that aliases to structs or
constants must start with `A` to `Z`

```move
address 0x42 {
  module data {
    struct S {}
    const FLAG: bool = false;
    fun foo() {}
  }
  module example {
    use 0x42::data::{
      S as s, // ERROR!
      FLAG as fLAG, // ERROR!
      foo as FOO,  // valid
      foo as bar, // valid
    };
  }
}
```

## Uniqueness

Inside a given scope, all aliases introduced by `use` declarations must be unique.

For a module, this means aliases introduced by `use` cannot overlap

```move
module 0x42::example {
  use std::vector::{empty as foo, length as foo}; // ERROR!
  //                                        ^^^ duplicate 'foo'

  use std::vector::empty as bar;
  use std::vector::length as bar; // ERROR!
  //                         ^^^ duplicate 'bar'
}
```

And, they cannot overlap with any of the module's other members

```move
address 0x42 {
  module data {
    struct S {}
  }
  module example {
    use 0x42::data::S;

    struct S { value: u64 } // ERROR!
    //     ^ conflicts with alias 'S' above
  }
}
```

Inside an expression block, they cannot overlap with each other, but they can
[shadow](#shadowing) other aliases or names from an outer scope

## Shadowing

`use` aliases inside of an expression block can shadow names (module members or aliases) from the
outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;

```move
module 0x42::example {

  struct WrappedVector { vec: vector<u64> }

  fun empty(): WrappedVector {
    WrappedVector { vec: std::vector::empty() }
  }

  fun example1(): (WrappedVector, WrappedVector) {
    let vec = {
      use std::vector::{empty, push_back};
      // 'empty' now refers to std::vector::empty

      let v = empty();
      push_back(&mut v, 0);
      push_back(&mut v, 1);
      push_back(&mut v, 10);
      v
    };
    // 'empty' now refers to Self::empty

    (empty(), WrappedVector { vec })
  }

  fun example2(): (WrappedVector, WrappedVector) {
    use std::vector::{empty, push_back};
    let w: WrappedVector = {
      use 0x42::example::empty;
      empty()
    };
    push_back(&mut w.vec, 0);
    push_back(&mut w.vec, 1);
    push_back(&mut w.vec, 10);

    let vec = empty();
    push_back(&mut vec, 0);
    push_back(&mut vec, 1);
    push_back(&mut vec, 10);

    (w, WrappedVector { vec })
  }
}
```

## Unused Use or Alias

An unused `use` will result in an error

```move
module 0x42::example {
  use std::vector::{empty, push_back}; // ERROR!
  //                       ^^^^^^^^^ unused alias 'push_back'

  fun example(): vector<u8> {
    empty()
  }
}
```

# Local Variables and Scope

> Learn about variables in Move programming language for Aptos smart contract development.

Local variables in Move are lexically (statically) scoped. New variables are introduced with the
keyword `let`, which will shadow any previous local with the same name. Locals are mutable and can
be updated both directly and via a mutable reference.

## Declaring Local Variables

### `let` bindings

Move programs use `let` to bind variable names to values:

```move
script {
  fun example() {
    let x = 1;
    let y = x + x;
  }
}
```

`let` can also be used without binding a value to the local.

```move
script {
  fun example() {
    let x;
  }
}
```

The local can then be assigned a value later.

```move
script {
  fun example() {
    let x;
    if (cond) {
      x = 1
    } else {
      x = 0
    }
  }
}
```

This can be very helpful when trying to extract a value from a loop when a default value cannot be
provided.

```move
script {
  fun example() {
    let x;
    let cond = true;
    let i = 0;
    loop {
      (x, cond) = foo(i);
      if (!cond) break;
      i = i + 1;
    }
  }
}
```

### Variables must be assigned before use

Move's type system prevents a local variable from being used before it has been assigned.

```move
script {
  fun example() {
    let x;
    x + x; // ERROR!
  }
}
```

```move
script {
  fun example() {
    let x;
    if (cond) x = 0;
    x + x; // ERROR!
  }
}
```

```move
script {
  fun example() {
    let x;
    while (cond) x = 0;
    x + x; // ERROR!
  }
}
```

### Valid variable names

Variable names can contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, and digits `0`
to `9`. Variable names must start with either an underscore `_` or a letter `a` through `z`. They
_cannot_ start with uppercase letters.

```move
script {
  fun example() {
    // all valid
    let x = e;
    let _x = e;
    let _A = e;
    let x0 = e;
    let xA = e;
    let foobar_123 = e;

    // all invalid
    let X = e; // ERROR!
    let Foo = e; // ERROR!
  }
}
```

### Type annotations

The type of local variable can almost always be inferred by Move's type system. However, Move
allows explicit type annotations that can be useful for readability, clarity, or debuggability. The
syntax for adding a type annotation is:

```move
script {
  fun example() {
    let x: T = e; // "Variable x of type T is initialized to expression e"
  }
}
```

Some examples of explicit type annotations:

```move
module 0x42::example {

  struct S { f: u64, g: u64 }

  fun annotated() {
    let u: u8 = 0;
    let b: vector<u8> = b"hello";
    let a: address = @0x0;
    let (x, y): (&u64, &mut u64) = (&0, &mut 1);
    let S { f, g: f2 }: S = S { f: 0, g: 1 };
  }
}
```

Note that the type annotations must always be to the right of the pattern:

```move
script {
  fun example() {
    let (x: &u64, y: &mut u64) = (&0, &mut 1); // ERROR! should be let (x, y): ... =
  }
}
```

### When annotations are necessary

In some cases, a local type annotation is required if the type system cannot infer the type. This
commonly occurs when the type argument for a generic type cannot be inferred. For example:

```move
script {
  fun example() {
    let _v1 = vector::empty(); // ERROR!
    //        ^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation
    let v2: vector<u64> = vector::empty(); // no error
  }
}
```

In a rarer case, the type system might not be able to infer a type for divergent code (where all the
following code is unreachable). Both `return` and [`abort`](/build/smart-contracts/book/abort-and-assert) are expressions
and can have any type. A [`loop`](/build/smart-contracts/book/loops) has type `()` if it has a `break`, but if there is no
break out of the `loop`, it could have any type. If these types cannot be inferred, a type
annotation is required. For example, this code:

```move
script {
  fun example() {
    let a: u8 = return ();
    let b: bool = abort 0;
    let c: signer = loop ();

    let x = return (); // ERROR!
    //  ^ Could not infer this type. Try adding an annotation
    let y = abort 0; // ERROR!
    //  ^ Could not infer this type. Try adding an annotation
    let z = loop (); // ERROR!
    //  ^ Could not infer this type. Try adding an annotation
  }
}
```

Adding type annotations to this code will expose other errors about dead code or unused local
variables, but the example is still helpful for understanding this problem.

### Multiple declarations with tuples

`let` can introduce more than one local at a time using tuples. The locals declared inside the
parenthesis are initialized to the corresponding values from the tuple.

```move
script {
  fun example() {
    let () = ();
    let (x0, x1) = (0, 1);
    let (y0, y1, y2) = (0, 1, 2);
    let (z0, z1, z2, z3) = (0, 1, 2, 3);
  }
}
```

The type of the expression must match the arity of the tuple pattern exactly.

```move
script {
  fun example() {
    let (x, y) = (0, 1, 2); // ERROR!
    let (x, y, z, q) = (0, 1, 2); // ERROR!
  }
}
```

You cannot declare more than one local with the same name in a single `let`.

```move
script {
  fun example() {
    let (x, x) = 0; // ERROR!
  }
}
```

### Multiple declarations with structs

`let` can also introduce more than one local at a time when destructuring (or matching against) a
struct. In this form, the `let` creates a set of local variables that are initialized to the values
of the fields from a struct. The syntax looks like this:

```move
script {
  fun example() {
    struct T { f1: u64, f2: u64 }
  }
}
```

```move
script {
  fun example() {
    let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
    // local1: u64
    // local2: u64
  }
}
```

Here is a more complicated example:

```move
module 0x42::example {
  struct X { f: u64 }
  struct Y { x1: X, x2: X }

  fun new_x(): X {
    X { f: 1 }
  }

  fun example() {
    let Y { x1: X { f }, x2 } = Y { x1: new_x(), x2: new_x() };
    assert!(f + x2.f == 2, 42);

    let Y { x1: X { f: f1 }, x2: X { f: f2 } } = Y { x1: new_x(), x2: new_x() };
    assert!(f1 + f2 == 2, 42);
  }
}
```

Fields of structs can serve double duty, identifying the field to bind _and_ the name of the
variable. This is sometimes referred to as punning.

```move
script {
  fun example() {
    let X { f } = e;
  }
}
```

is equivalent to:

```move
script {
  fun example() {
    let X { f: f } = e;
  }
}
```

As shown with tuples, you cannot declare more than one local with the same name in a single `let`.

```move
script {
  fun example() {
    let Y { x1: x, x2: x } = e; // ERROR!
  }
}
```

### Destructuring against references

In the examples above for structs, the bound value in the let was moved, destroying the struct value
and binding its fields.

```move
script {
  fun example() {
    struct T { f1: u64, f2: u64 }
  }
}
```

```move
script {
  fun example() {
    let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
    // local1: u64
    // local2: u64
  }
}
```

In this scenario the struct value `T { f1: 1, f2: 2 }` no longer exists after the `let`.

If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For
example:

```move
script {
  fun example() {
    let t = T { f1: 1, f2: 2 };
    let T { f1: local1, f2: local2 } = &t;
    // local1: &u64
    // local2: &u64
  }
}
```

And similarly with mutable references:

```move
script {
  fun example() {
    let t = T { f1: 1, f2: 2 };
    let T { f1: local1, f2: local2 } = &mut t;
    // local1: &mut u64
    // local2: &mut u64
  }
}
```

This behavior can also work with nested structs.

```move
module 0x42::example {
  struct X { f: u64 }
  struct Y { x1: X, x2: X }

  fun new_x(): X {
    X { f: 1 }
  }

  fun example() {
    let y = Y { x1: new_x(), x2: new_x() };

    let Y { x1: X { f }, x2 } = &y;
    assert!(*f + x2.f == 2, 42);

    let Y { x1: X { f: f1 }, x2: X { f: f2 } } = &mut y;
    *f1 = *f1 + 1;
    *f2 = *f2 + 1;
    assert!(*f1 + *f2 == 4, 42);
  }
}
```

### Ignoring Values

In `let` bindings, it is often helpful to ignore some values. Local variables that start with `_`
will be ignored and not introduce a new variable

```move
module 0x42::example {
  fun three(): (u64, u64, u64) {
    (0, 1, 2)
  }

  fun example() {
    let (x1, _, z1) = three();
    let (x2, _y, z2) = three();
    assert!(x1 + z1 == x2 + z2, 42);
  }
}
```

This can be necessary at times as the compiler will error on unused local variables

```move
module 0x42::example {
  fun example() {
    let (x1, y, z1) = three(); // ERROR!
    //       ^ unused local 'y'
  }
}
```

### General `let` grammar

All the different structures in `let` can be combined! With that we arrive at this general
grammar for `let` statements:

> _let-binding_ ‚Üí **let** _pattern-or-list_ _type-annotation_<sub>_opt_</sub> _initializer_<sub>_opt_</sub>

> _pattern-or-list_ ‚Üí _pattern_ | **(** _pattern-list_ **)**

> _pattern-list_ ‚Üí _pattern_ **,**<sub>_opt_</sub> | _pattern_ **,** _pattern-list_

> _type-annotation_ ‚Üí **:** _type_

> _initializer_ ‚Üí **=** _expression_

The general term for the item that introduces the bindings is a _pattern_. The pattern serves to
both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as
follows:

> _pattern_ ‚Üí _local-variable_ | _struct-type_ **\{** _field-binding-list_ **}**

> _field-binding-list_ ‚Üí _field-binding_ **,**<sub>_opt_</sub> | _field-binding_ **,** _field-binding-list_

> _field-binding_ ‚Üí _field_ | _field_ **:** _pattern_

A few concrete examples with this grammar applied:

```move
script {
  fun example() {
    let (x, y): (u64, u64) = (0, 1);
    //       ^                           local-variable
    //       ^                           pattern
    //          ^                        local-variable
    //          ^                        pattern
    //          ^                        pattern-list
    //       ^^^^                        pattern-list
    //      ^^^^^^                       pattern-or-list
    //            ^^^^^^^^^^^^           type-annotation
    //                         ^^^^^^^^  initializer
    //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
    //      ^^^                                    struct-type
    //            ^                                field
    //            ^                                field-binding
    //               ^                             field
    //                  ^                          local-variable
    //                  ^                          pattern
    //               ^^^^                          field-binding
    //            ^^^^^^^                          field-binding-list
    //      ^^^^^^^^^^^^^^^                        pattern
    //      ^^^^^^^^^^^^^^^                        pattern-or-list
    //                      ^^^^^^^^^^^^^^^^^^^^   initializer
    //  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding
  }
}
```

## Mutations

### Assignments

After the local is introduced (either by `let` or as a function parameter), the local can be
modified via an assignment:

```move
script {
  fun example(e: u8) {
    let x = 0;
    x = e
  }
}
```

Unlike `let` bindings, assignments are expressions. In some languages, assignments return the value
that was assigned, but in Move, the type of any assignment is always `()`.

```move

script {
  fun example(e: u8) {
    let x = 0;
    (x = e) == ()
  }
}
```

Practically, assignments being expressions means that they can be used without adding a new
expression block with braces (`{`...`}`).

```move
script {
  fun example(e: u8) {
    let x = 0;
    if (cond) x = 1 else x = 2;
  }
}
```

The assignment uses the same pattern syntax scheme as `let` bindings:

```move
module 0x42::example {
    struct X { f: u64 }

    fun new_x(): X {
        X { f: 1 }
    }

    // This example will complain about unused variables and assignments.
    fun example() {
       let (x, _, z) = (0, 1, 3);
       let (x, y, f, g);

       (X { f }, X { f: x }) = (new_x(), new_x());
       assert!(f + x == 2, 42);

       (x, y, z, f, _, g) = (0, 0, 0, 0, 0, 0);
    }
}
```

Note that a local variable can only have one type, so the type of the local cannot change between
assignments.

```move
script {
  fun example() {
    let x;
    x = 0;
    x = false; // ERROR!
  }
}
```

### Mutating through a reference

In addition to directly modifying a local with assignment, a local can be modified via a mutable
reference `&mut`.

```move
script {
  fun example() {
    let x = 0;
    let r = &mut x;
    *r = 1;
    assert!(x == 1, 42);
  }
}
```

This is particularly useful if either:

(1) You want to modify different variables depending on some condition.

```move
script {
  fun example() {
    let x = 0;
    let y = 1;
    let r = if (cond) {
      &mut x
    } else {
      &mut y
    };
    *r = *r + 1;
  }
}
```

(2) You want another function to modify your local value.

```move
script {
  fun example() {
    let x = 0;
    modify_ref(&mut x);
  }
}
```

This sort of modification is how you modify structs and vectors!

```move
script {
  use 0x1::vector;

  fun example() {
    let v = vector::empty();
    vector::push_back(&mut v, 100);
    assert!(*vector::borrow(&v, 0) == 100, 42);
  }
}
```

For more details, see [Move references](/build/smart-contracts/book/references).

### Compound Assignments

_Since language version 2.1_

Move also supports compound assignment operators. These are like an assignment to a variable,
or a mutation through a reference, except that the assigned location must already have a value,
which is read and operated on before being stored back into the location.
Currently these are only applicable to numeric values.

| Syntax | Description                                                  |
| ------ | ------------------------------------------------------------ |
| `+=`   | Performs addition and updates the left-hand value            |
| `-=`   | Performs subtraction and updates the left-hand value         |
| `*=`   | Performs multiplication and updates the left-hand value      |
| `%=`   | Performs modular division and updates the left-hand value    |
| `/=`   | Performs truncating division and updates the left-hand value |
| `&=`   | Performs bitwise and updates the left-hand value             |
| `\|=`  | Performs bitwise or and updates the left-hand value          |
| `^=`   | Performs bitwise xor and updates the left-hand value         |
| `<<=`  | Performs shift left and updates the left-hand value          |
| `>>=`  | Performs shift right and updates the left-hand value         |

For `e1 += e2`, the **modifying operand** `e2` is evaluated first, followed by the **assigned operand** `e1`.
The result of performing `+` on the operand values is then stored in the left-hand side location.
The assigned operand is only evaluated once. Similarly for all other operations listed in the table above.

```move
module 0x42::example {
  struct S { f: u64 }

  fun example() {
    let x = 41;
    x += 1;
    assert!(x == 42);

    let y = 41;
    let p = &mut y;
    *p += 1;
    assert!(*p == 42);

    let z = S { f: 41 };
    z.f += 1;
    assert!(z.f == 42);
  }
}
```

## Scopes

Any local declared with `let` is available for any subsequent expression, _within that scope_.
Scopes are declared with expression blocks, `{`...`}`.

Locals cannot be used outside the declared scope.

```move
script {
  fun example() {
    let x = 0;
    {
      let y = 1;
    };
    x + y // ERROR!
    //  ^ unbound local 'y'
  }
}
```

But, locals from an outer scope _can_ be used in a nested scope.

```move
script {
  fun example() {
    {
      let x = 0;
      {
        let y = x + 1; // valid
      }
    }
  }
}
```

Locals can be mutated in any scope where they are accessible. That mutation survives with the local,
regardless of the scope that performed the mutation.

```move
script {
  fun example() {
    let x = 0;
    x = x + 1;
    assert!(x == 1, 42);
    {
      x = x + 1;
      assert!(x == 2, 42);
    };
    assert!(x == 2, 42);
  }
}
```

### Expression Blocks

An expression block is a series of statements separated by semicolons (`;`). The resulting value of
an expression block is the value of the last expression in the block.

```move
script {
  fun example() {
    { let x = 1; let y = 1; x + y }
  }
}
```

In this example, the result of the block is `x + y`.

A statement can be either a `let` declaration or an expression. Remember that assignments (`x = e`)
are expressions of type `()`.

```move
script {
  fun example() {
    { let x; let y = 1; x = 1; x + y }
  }
}
```

Function calls are another common expression of type `()`. Function calls that modify data are
commonly used as statements.

```move
script {
  fun example() {
    { let v = vector::empty(); vector::push_back(&mut v, 1); v }
  }
}
```

This is not just limited to `()` types---any expression can be used as a statement in a sequence!

```move
script {
  fun example() {
    {
      let x = 0;
      x + 1; // value is discarded
      x + 2; // value is discarded
      b"hello"; // value is discarded
    }
  }
}
```

But! If the expression contains a resource (a value without the `drop` [ability](/build/smart-contracts/book/abilities)),
you will get an error. This is because Move's type system guarantees that any value that is dropped
has the `drop` [ability](/build/smart-contracts/book/abilities). (Ownership must be transferred or the value must be
explicitly destroyed within its declaring module.)

```move
script {
  fun example() {
    {
      let x = 0;
      Coin { value: x }; // ERROR!
      //  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability
      x
    }
  }
}
```

If a final expression is not present in a block---that is, if there is a trailing semicolon `;`,
there is an implicit [unit `()` value](https://en.wikipedia.org/wiki/Unit_type). Similarly, if the expression block is empty, there is an
implicit unit `()` value.

```move
script {
  fun example() {
    // Both are equivalent
    { x = x + 1; 1 / x; };
    { x = x + 1; 1 / x; () };
  }
}
```

```move
script {
  fun example() {
    // Both are equivalent
    {}
    { () }
  }
}
```

An expression block is itself an expression and can be used anyplace an expression is used. (Note:
The body of a function is also an expression block, but the function body cannot be replaced by
another expression.)

```move
script {
  fun example() {
    let my_vector: vector<vector<u8>> = {
      let v = vector::empty();
      vector::push_back(&mut v, b"hello");
      vector::push_back(&mut v, b"goodbye");
      v
    };
  }
}
```

(The type annotation is not needed in this example and only added for clarity.)

### Shadowing

If a `let` introduces a local variable with a name already in scope, that previous variable can no
longer be accessed for the rest of this scope. This is called _shadowing_.

```move
script {
  fun example() {
    let x = 0;
    assert!(x == 0, 42);

    let x = 1; // x is shadowed
    assert!(x == 1, 42);
  }
}
```

When a local is shadowed, it does not need to retain the same type as before.

```move
script {
  fun example() {
    let x = 0;
    assert!(x == 0, 42);

    let x = b"hello"; // x is shadowed
    assert!(x == b"hello", 42);
  }
}
```

After a local is shadowed, the value stored in the local still exists, but will no longer be
accessible. This is important to keep in mind with values of types without the
[`drop` ability](/build/smart-contracts/book/abilities), as ownership of the value must be transferred by the end of the
function.

```move
module 0x42::example {
  struct Coin has store { value: u64 }

  fun unused_resource(): Coin {
    let x = Coin { value: 0 }; // ERROR!
    //  ^ This local still contains a value without the `drop` ability
    x.value = 1;
    let x = Coin { value: 10 };
    x
    // ^ Invalid return
  }
}
```

When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is
gone once that scope ends.

```move
script {
  fun example() {
    let x = 0;
    {
      let x = 1;
      assert!(x == 1, 42);
    };
    assert!(x == 0, 42);
  }
}

```

Remember, locals can change type when they are shadowed.

```move
script {
  fun example() {
    let x = 0;
    {
      let x = b"hello";
      assert!(x = b"hello", 42);
    };
    assert!(x == 0, 42);
  }
}
```

## Move and Copy

All local variables in Move can be used in two ways, either by `move` or `copy`. If one or the other
is not specified, the Move compiler is able to infer whether a `copy` or a `move` should be used.
This means that in all the examples above, a `move` or a `copy` would be inserted by the
compiler. A local variable cannot be used without the use of `move` or `copy`.

`copy` will likely feel the most familiar coming from other programming languages, as it creates a
new copy of the value inside the variable to use in that expression. With `copy`, the local
variable can be used more than once.

```move
script {
  fun example() {
    let x = 0;
    let y = copy x + 1;
    let z = copy x + 2;
  }
}
```

Any value with the `copy` [ability](/build/smart-contracts/book/abilities) can be copied in this way.

`move` takes the value out of the local variable _without_ copying the data. After a `move` occurs,
the local variable is unavailable.

```move
script {
  fun example() {
    let x = 1;
    let y = move x + 1;
    //      ------ Local was moved here
    let z = move x + 2; // Error!
    //      ^^^^^^ Invalid usage of local 'x'
    y + z;
  }
}
```

### Safety

Move's type system will prevent a value from being used after it is moved. This is the same safety
check described in [`let` declaration](#let-bindings) that prevents local variables from being used
before it is assigned a value.

{/* For more information, see TODO future section on ownership and move semantics. */}

### Inference

As mentioned above, the Move compiler will infer a `copy` or `move` if one is not indicated. The
algorithm for doing so is quite simple:

- Any value with the `copy` [ability](/build/smart-contracts/book/abilities) is given a `copy`.
- Any reference (both mutable `&mut` and immutable `&`) is given a `copy`.
  - Except under special circumstances where it is made a `move` for predictable borrow checker
    errors.
- Any other value is given a `move`.
- If the compiler can prove that the source value with copy ability is not used after the
  assignment, then a move may be used instead of a copy for performance, but this will be invisible
  to the programmer (except in possible decreased time or gas cost).

For example:

```move
module 0x42::example {
  struct Foo {
    f: u64
  }

  struct Coin has copy {
    value: u64
  }

  fun example() {
    let s = b"hello";
    let foo = Foo { f: 0 };
    let coin = Coin { value: 0 };

    let s2 = s; // copy
    let foo2 = foo; // move
    let coin2 = coin; // copy

    let x = 0;
    let b = false;
    let addr = @0x42;
    let x_ref = &x;
    let coin_ref = &mut coin2;

    let x2 = x; // copy
    let b2 = b; // copy
    let addr2 = @0x42; // copy
    let x_ref2 = x_ref; // copy
    let coin_ref2 = coin_ref; // copy
  }
}
```

# Vector

> Master vector operations in Move for dynamic arrays, collections, and list manipulation in smart contracts.

`vector<T>` is the only primitive collection type provided by Move. A `vector<T>` is a homogeneous
collection of `T`'s that can grow or shrink by pushing/popping values off the "end".

A `vector<T>` can be instantiated with any type `T`. For example, `vector<u64>`, `vector<address>`,
`vector<0x42::MyModule::MyResource>`, and `vector<vector<u8>>` are all valid vector types.

## Literals

### General `vector` Literals

Vectors of any type can be created with `vector` literals.

| Syntax                | Type                                                                          | Description                                |
| --------------------- | ----------------------------------------------------------------------------- | ------------------------------------------ |
| `vector[]`            | `vector[]: vector<T>` where `T` is any single, non-reference type             | An empty vector                            |
| `vector[e1, ..., en]` | `vector[e1, ..., en]: vector<T>` where `e_i: T` s.t. `0 < i <= n` and `n > 0` | A vector with `n` elements (of length `n`) |

In these cases, the type of the `vector` is inferred, either from the element type or from the
vector's usage. If the type cannot be inferred, or simply for added clarity, the type can be
specified explicitly:

```move
vector<T>[]: vector<T>
vector<T>[e1, ..., en]: vector<T>
```

#### Example Vector Literals

```move
script {
  fun example() {
    (vector[]: vector<bool>);
    (vector[0u8, 1u8, 2u8]: vector<u8>);
    (vector<u128>[]: vector<u128>);
    (vector<address>[@0x42, @0x100]: vector<address>);
  }
}
```

### `vector<u8>` literals

A common use-case for vectors in Move is to represent "byte arrays", which are represented with
`vector<u8>`. These values are often used for cryptographic purposes, such as a public key or a hash
result. These values are so common that specific syntax is provided to make the values more
readable, as opposed to having to use `vector[]` where each individual `u8` value is specified in
numeric form.

There are currently two supported types of `vector<u8>` literals, _byte strings_ and _hex strings_.

#### Byte Strings

Byte strings are quoted string literals prefixed by a `b`, e.g. `b"Hello!\n"`.

These are ASCII encoded strings that allow for escape sequences. Currently, the supported escape
sequences are:

| Escape Sequence | Description                                    |
| --------------- | ---------------------------------------------- |
| `\n`            | New line (or Line feed)                        |
| `\r`            | Carriage return                                |
| `\t`            | Tab                                            |
| `\\`            | Backslash                                      |
| `\0`            | Null                                           |
| `\"`            | Quote                                          |
| `\xHH`          | Hex escape, inserts the hex byte sequence `HH` |

#### Hex Strings

Hex strings are quoted string literals prefixed by a `x`, e.g. `x"48656C6C6F210A"`.

Each byte pair, ranging from `00` to `FF`, is interpreted as hex encoded `u8` value. So each byte
pair corresponds to a single entry in the resulting `vector<u8>`.

#### Example String Literals

```move
script {
  fun byte_and_hex_strings() {
    assert!(b"" == x"", 0);
    assert!(b"Hello!\n" == x"48656C6C6F210A", 1);
    assert!(b"\x48\x65\x6C\x6C\x6F\x21\x0A" == x"48656C6C6F210A", 2);
    assert!(
        b"\"Hello\tworld!\"\n \r \\Null=\0" ==
            x"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00",
        3
    );
  }
}
```

## Operations

`vector` provides several operations via the `std::vector` module in the Move standard
library, as shown below. More operations may be added over time.
Up-to-date document on `vector` can be found [here](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/move-stdlib/doc/vector.md).

| Function                                                                              | Description                                                                                                                                                        | Aborts?                                                  |
| ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------- |
| `vector::empty<T>(): vector<T>`                                                       | Create an empty vector that can store values of type `T`                                                                                                           | Never                                                    |
| `vector::is_empty<T>(self: &vector<T>): bool`                                         | Return `true` if the vector `self` has no elements and `false` otherwise.                                                                                          | Never                                                    |
| `vector::singleton<T>(t: T): vector<T>`                                               | Create a vector of size 1 containing `t`                                                                                                                           | Never                                                    |
| `vector::length<T>(self: &vector<T>): u64`                                            | Return the length of the vector `self`                                                                                                                             | Never                                                    |
| `vector::push_back<T>(self: &mut vector<T>, t: T)`                                    | Add `t` to the end of `self`                                                                                                                                       | Never                                                    |
| `vector::pop_back<T>(self: &mut vector<T>): T`                                        | Remove and return the last element in `self`                                                                                                                       | If `self` is empty                                       |
| `vector::borrow<T>(self: &vector<T>, i: u64): &T`                                     | Return an immutable reference to the element at index `i`                                                                                                          | If `i` is not in bounds                                  |
| `vector::borrow_mut<T>(self: &mut vector<T>, i: u64): &mut T`                         | Return a mutable reference to the element at index `i`                                                                                                             | If `i` is not in bounds                                  |
| `vector::destroy_empty<T>(self: vector<T>)`                                           | Delete `self`                                                                                                                                                      | If `self` is not empty                                   |
| `vector::append<T>(self: &mut vector<T>, other: vector<T>)`                           | Add the elements in `other` to the end of `self`                                                                                                                   | Never                                                    |
| `vector::reverse_append<T>(self: &mut vector<T>, other: vector<T>)`                   | Pushes all of the elements of the `other` vector into the `self` vector, in the reverse order as they occurred in `other`                                          | Never                                                    |
| `vector::contains<T>(self: &vector<T>, e: &T): bool`                                  | Return true if `e` is in the vector `self`. Otherwise, returns `false`                                                                                             | Never                                                    |
| `vector::swap<T>(self: &mut vector<T>, i: u64, j: u64)`                               | Swaps the elements at the `i`th and `j`th indices in the vector `self`                                                                                             | If `i` or `j` is out of bounds                           |
| `vector::reverse<T>(self: &mut vector<T>)`                                            | Reverses the order of the elements in the vector `self` in place                                                                                                   | Never                                                    |
| `vector::reverse_slice<T>(self: &mut vector<T>, l: u64, r: u64)`                      | Reverses the order of the elements `[l, r)` in the vector `self` in place                                                                                          | If `l > r` or if `l` or `r` is out of bounds             |
| `vector::index_of<T>(self: &vector<T>, e: &T): (bool, u64)`                           | Return `(true, i)` if `e` is in the vector `self` at index `i`. Otherwise, returns `(false, 0)`                                                                    | Never                                                    |
| `vector::insert<T>(self: &mut vector<T>, i: u64, e: T)`                               | Insert a new element `e` at position `0 <= i <= length`, using `O(length - i)` time                                                                                | If `i` is out of bounds                                  |
| `vector::remove<T>(self: &mut vector<T>, i: u64): T`                                  | Remove the `i`th element of the vector `self`, shifting all subsequent elements. This is O(n) and preserves ordering of elements in the vector                     | If `i` is out of bounds                                  |
| `vector::swap_remove<T>(self: &mut vector<T>, i: u64): T`                             | Swap the `i`th element of the vector `self` with the last element and then pop the element, This is O(1), but does not preserve ordering of elements in the vector | If `i` is out of bounds                                  |
| `vector::trim<T>(self: &mut vector<T>, new_len: u64): vector<T>`                      | Trim the vector `self` to the smaller size `new_len` and return the evicted elements in order                                                                      | If `new_len > self.length()`                             |
| `vector::trim_reverse<T>(self: &mut vector<T>, new_len: u64): vector<T>`              | Trim the vector `self` to the smaller size `new_len` and return the evicted elements in the reverse order                                                          | If `new_len > self.length()`                             |
| `vector::rotate<T>(self: &mut vector<T>, rot: u64): u64`                              | `rotate(&mut [1, 2, 3, 4, 5], 2) -> [3, 4, 5, 1, 2]` in place, returns the split point i.e., `3` in this example                                                   | If `rot <= self.length()` does not hold                  |
| `vector::rotate_slice<T>(self: &mut vector<T>, left: u64, rot: u64, right: u64): u64` | rotate a slice `[left, right)` with `left <= rot <= right` in place, returns the split point                                                                       | If `left <= rot <= right <= self.length()` does not hold |

Example:

```move
script {
  use std::vector;

  fun example() {
    let v = vector::empty<u64>();
    vector::push_back(&mut v, 5);
    vector::push_back(&mut v, 6);

    assert!(*vector::borrow(&v, 0) == 5, 42);
    assert!(*vector::borrow(&v, 1) == 6, 42);
    assert!(vector::pop_back(&mut v) == 6, 42);
    assert!(vector::pop_back(&mut v) == 5, 42);
  }
}
```

## Index Notation for Vectors

_Since language version 2.0_

Index notation using square brackets (`[]`) is available for vector operations, simplifying syntax
and making programs easier to understand. The index notation is simply syntactic sugar which
is reduced to existing operations by the compiler;  the named operations are also still supported.

The table below gives an overview of index notations for vectors:

| Indexing Syntax   | Vector Operation                           |
| ----------------- | ------------------------------------------ |
| `&v[i]`           | `vector::borrow(&v, i)`                    |
| `&mut v[i]`       | `vector::borrow_mut(&mut v, i)`            |
| `v[i]`            | `*vector::borrow(&v, i)`                   |
| `v[i] = x`        | `*vector::borrow_mut(&mut v, i) = x`       |
| `&v[i].field`     | `&vector::borrow(&v, i).field`             |
| `&mut v[i].field` | `&mut vector::borrow_mut(&mut v, i).field` |
| `v[i].field`      | `vector::borrow(&v, i).field`              |
| `v[i].field = x`  | `vector::borrow_mut(&mut v, i).field = x`  |

As an example, here is a bubble sort algorithm for vectors using index notation:

```move
fun bubble_sort(v: vector<u64>) {
  use std::vector;
  let n = vector::length(&v);
  let i = 0;

  while (i < n) {
    let j = 0;
    while (j < n - i - 1) {
      if (v[j] > v[j + 1]) {
        let t = v[j];
        v[j] = v[j + 1];
        v[j + 1] = t;
      };
      j = j + 1;
    };
    i = i + 1;
  };
}
```

## Destroying and copying vectors

Some behaviors of `vector<T>` depend on the abilities of the element type, `T`. For example, vectors
containing elements that do not have `drop` cannot be implicitly discarded like `v` in the example
above--they must be explicitly destroyed with `vector::destroy_empty`.

Note that `vector::destroy_empty` will abort at runtime unless `vec` contains zero elements:

```move
script {
  fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
  }
}
```

But no error would occur for dropping a vector that contains elements with `drop`:

```move
script {
  fun destroy_droppable_vector<T: drop>(vec: vector<T>) {
    // valid!
    // nothing needs to be done explicitly to destroy the vector
  }
}
```

Similarly, vectors cannot be copied unless the element type has `copy`. In other words, a
`vector<T>` has `copy` if and only if `T` has `copy`.

For more details see the sections on [type abilities](/build/smart-contracts/book/abilities) and [generics](/build/smart-contracts/book/generics).

## Ownership

As mentioned [above](#destroying-and-copying-vectors), `vector` values can be copied only if the
elements can be copied.

# Move On Aptos Compiler

> Learn about compiler_v2 for Move smart contract development on Aptos blockchain.

The Move on Aptos compiler (codename 'compiler v2') translates Move source code into Move bytecode. It unifies the architectures of the Move compiler and the Move Prover, enabling faster innovation in the Move language. It also offers new tools for defining code optimizations which can be leveraged to generate more gas efficient code for Move programs.

The Move on Aptos compiler supports Move 2, the latest revision of the Move language. Head over to the [release page in the book](/build/smart-contracts/book/move-2) to learn more about the new features in Move 2. Starting at Aptos CLI v6.0.0, this language version and the Move on Aptos compiler are the default. Note that Move 2 is generally backwards compatible with Move 1.

## Move on Aptos Release State

Move on Aptos is in production and is now the default compiler, with Move 2 being the default language version.

## Reporting an Issue

If you run into issues, please use [this link to create a github issue][bug]. If you are able to provide a small piece of Move code which reproduces the issue, debugging and fixing it will be easier for us.

[bug]: https://github.com/aptos-labs/aptos-core/issues/new?title=[compiler-v2]%20%3CPLEASE%20NAME%20IT%3E&body=%3CPLEASE%20DESCRIBE%20IT%3E&labels=compiler-v2&projects=aptos-labs/16

## Using Move on Aptos Compiler

Ensure to have installed the latest version of the Aptos CLI:

```shellscript filename="Terminal"
aptos update aptos # on supported OS
brew upgrade aptos # on MacOS
```

Move on Aptos compiler and Move 2 are now the default, requiring no changes to your usage. Examples:

```shellscript filename="Terminal"
aptos move compile
aptos move test
aptos move prove
```

# Compiling (Move)

> Learn about compiling for Move smart contract development on Aptos blockchain.

import { Aside, FileTree } from '@astrojs/starlight/components';

<Aside type="note">
  Ensure that your [CLI](/build/cli) is up to date before compiling.
</Aside>

## `aptos move compile`

Once you have a package set up, you can compile your Move code by doing:

```shellscript filename="Terminal"
aptos move compile
```

If run successfully, you should receive a Terminal output like so

```shellscript filename="Terminal"
{
  "Result": [
    "<PUBLISHING_ADDRESS>::<MODULE_NAME>"
  ]
}
```

<Aside type="note">
  You may need to add named addresses, especially for examples.  For example, with the Hello Blockchain Move example, you will need to add the `hello_blockchain` named address:

  ```shellscript filename="Terminal"
  aptos move compile --named-addresses hello_blockchain=default
  ```
</Aside>

## Unpacking Build

Compiled Move packages contain a folder structure that resembles the one below.

<FileTree>
  - build/
    - package\_name/
      - bytecode\_modules/
        - dependencies/
        - module\_name.mv
      - source\_maps/
        - dependencies/
        - module\_name.mvsm
      - sources/
        - dependencies/
        - module\_name.move
      - BuildInfo.yaml
  - scripts/
  - sources/
    - module\_name.move
  - tests/
  - Move.toml
</FileTree>

### `bytecode_modules`

The bytecode modules folder contains the compiled Move bytecode for your module(s) (such as `module_name.mv`).
To learn more about the bytecode and its security features, see [why move?](/build/smart-contracts/why-move)

### `source_maps`

The source maps folder contains source maps (such as `module_name.mvsm`) which allow
users to map the compiled bytecode back to the source code and relevant dependencies.

# Confidential Asset (CA)

> Learn about confidential asset for Move smart contract development on Aptos blockchain.

import { ThemedImage } from '~/components/ThemedImage';

import { Aside } from '@astrojs/starlight/components';

The Confidential Asset Standard (also known as "Confidential Asset" or "CA") is a privacy-focused protocol for managing Fungible Assets (FA).
It allows users to perform transactions with hidden FA amounts while keeping sender and recipient addresses publicly visible.

This standard allows any FA to be wrapped into a corresponding Confidential Asset, ensuring compatibility with existing tokens.
It supports 64-bit transfers, and balances of up to 128 bits.

Operations on Confidential Asset balances (confidential balances), require zero-knowledge proofs (ZKPs) to verify transaction correctness
without revealing hidden amounts and other sensitive data.

<Aside type="note">
  Interacting directly with Confidential Asset's smart contracts is highly complex.
  Developers are encouraged to create external services to manage tasks like generating ZKPs, recovering keys, and decrypting balances.
  To assist with this, we've developed a TypeScript SDK, with full documentation available [here](/build/sdks/ts-sdk/confidential-asset).
</Aside>

<Aside type="note">
  This documentation explains the contract's operations and offers insights into the protocol core processes.
  Cryptographic and mathematical details are explained superficially.
</Aside>

## Confidential Asset Store

For every confidential asset a user registers, they generate a unique keypair:

- An encryption key (EK) stored on-chain.
- A decryption key (DK) kept securely by the user.

These keys are standalone and should not be confused with the user's Aptos account keys.

Each confidential balance is split into two parts:

- `pending_balance` - accumulates all incoming transactions.
- `actual_balance` - used exclusively for outgoing transactions.

Both balances are encrypted with the same user's EK, ensuring underlying amounts remain private.

<Aside type="note">
  This separation protects against "front-running" attacks.
  Specifically, if there was a single balance, an attacker could revert a user's transaction by sending a small payment,
  altering the balance and, consequently, invalidating the user's ZKP.
</Aside>

The confidential balance and its associated encryption key are stored in the `ConfidentialAssetStore` resource.
The `ConfidentialAssetStore` is instantiated for each confidential asset the user has and managed by the `confidential_asset` module:

```move filename="confidential_asset.move"
struct ConfidentialAssetStore has key {
    pending_balance: confidential_balance::CompressedConfidentialBalance,
    actual_balance: confidential_balance::CompressedConfidentialBalance,
    ek: twisted_elgamal::CompressedPubkey,
    // ...
}
```

## Confidential Balance

Confidential balances handle token amounts by splitting them into smaller units called chunks.
Each chunk represents a portion of the total amount and is encrypted individually using the user‚Äôs EK.
This design ensures efficient management of balances.

### Chunks

The pending balance consists of four chunks that hold all incoming transfers.
It can handle up to 2^16 64-bit transfers before requiring a rollover to the actual balance.
During this accumulation, the pending balance chunks can grow up to 32 bits each.

The actual balance consists of eight chunks, supporting 128-bit values.
After any operation the actual balance should be [normalized](#normaliztion) back to 16-bit chunks to maintain efficient decryption.

The `ConfidentialBalance` struct from the `confidential_balance` module is used to represent both the pending and actual balances:

```move filename="confidential_asset.move"
struct ConfidentialBalance has drop {
    chunks: vector<twisted_elgamal::Ciphertext>,
}
```

### Encryption and Decryption

Encryption involves:

- Splitting the total amount into 16-bit chunks.
- Applying the user's EK to encrypt each chunk individually.

Decryption involves:

- Applying the user‚Äôs DK to decrypt each chunk.
- Solving a discrete logarithm (DL) problem for each chunk to recover the original values.
- Combining the recovered values to reconstruct the total amount.

### Normalization

Normalization ensures chunks are always reduced to manageable sizes (16 bits).
Without normalization, chunks can grow too large, making the decryption process (solving DL) significantly slower or even impractical.
This mechanism is automatically applied to the actual balance after each operation,
ensuring that users can always decrypt their balances, even as balances grow through multiple transactions.
Only after a rollover, users are required to normalize the actual balance [manually](#normalization).

### Homomorphic Encryption

The protocol utilizes Homomorphic encryption, allowing arithmetic operations on confidential balances without their decryption.
This capability is essential for updating the receiver's pending balance during transfers and for rollovers,
where the user's pending balance is added to the actual one.

## Architecture

The diagram below shows the relationship between Confidential Asset modules:

<ThemedImage
  alt="CA Modules Relationship"
  sources={{
light: '~/images/ca-diagram-light.png',
dark: '~/images/ca-diagram-dark.png',
}}
/>

Users interact with the `confidential_asset` module to perform operations on their confidential balances.
The `confidential_asset` module calls the `confidential_balance` module to manage the confidential balances and the `confidential_proof` module to verify ZKPs.
Under the hood, the `confidential_balance` module uses the `twisted_elgamal` module for operations on chunks.

## Entry functions

### Register

```move filename="confidential_asset.move"
public entry fun register(sender: &signer, token: Object<Metadata>, ek: vector<u8>)
```

```move filename="confidential_asset.move"
#[view]
public fun has_confidential_asset_store(user: address, token: Object<Metadata>): bool
```

Users must register a `ConfidentialAssetStore` for each token they intend to transact with.
As part of this process, users are required to generate a keypair (EK and DK) on their end.

When a `ConfidentialAssetStore` is first registered, the confidential balance is set to zero,
represented as zero ciphertexts for both the `pending_balance` and `actual_balance`.

You can also check if a user has a `ConfidentialAssetStore` for a specific token using the `has_confidential_asset_store` function.

<Aside type="note">
  Although it is recommended to generate a unique keypair for each token to enhance security,
  it's not restricted to reuse the same encryption key across multiple tokens if preferred.
</Aside>

<Aside type="caution">
  This operation is expensive as it initializes a new storage and storage fees far exceed execution fees.
  However, users call it only once per token.
</Aside>

```move filename="register_example.move"
#[test_only]
module confidential_asset_example::register_example {
    /// ...

    fun register(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (_bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek = twisted_elgamal::pubkey_to_bytes(&bob_ek);

        confidential_asset::register(bob, token, bob_ek);

        print(&utf8(b"Bob's pending balance is zero:"));
        print(&confidential_asset::pending_balance(bob_addr, token));

        print(&utf8(b"Bob's actual balance is zero:"));
        print(&confidential_asset::actual_balance(bob_addr, token));

        print(&utf8(b"Bob's encryption key is set:"));
        print(&confidential_asset::encryption_key(bob_addr, token));
    }
}
```

### Deposit

```move filename="confidential_asset.move"
public entry fun deposit(sender: &signer, token: Object<Metadata>, amount: u64)
```

```move filename="confidential_asset.move"
public entry fun deposit_to(sender: &signer, token: Object<Metadata>, to: address, amount: u64)
```

The `deposit` and `deposit_to` functions bring tokens into the protocol, transferring the passed amount
from primary FA store of the sender to the pending balance of the recipient.

The amount in this function is publicly visible, as adding new tokens to the protocol requires a normal transfer.
However, tokens within the protocol become obfuscated through confidential transfers, ensuring privacy in subsequent transactions.

<Aside type="note">
  If you want to have a hidden amount from the beginning, use the `confidential_transfer` function instead.
</Aside>

```move filename="deposit_example.move"
#[test_only]
module confidential_asset_example::deposit_example {
    /// ...

    fun deposit(bob: &signer, alice: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);
        let alice_addr = signer::address_of(alice);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (alice_dk, alice_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek = twisted_elgamal::pubkey_to_bytes(&bob_ek);
        let alice_ek = twisted_elgamal::pubkey_to_bytes(&alice_ek);

        confidential_asset::register(bob, token, bob_ek);
        confidential_asset::register(alice, token, alice_ek);

        print(&utf8(b"Bob's FA balance before the deposit is 500:"));
        print(&primary_fungible_store::balance(bob_addr, token));

        assert!(primary_fungible_store::balance(bob_addr, token) == 500);

        let bob_amount = 100;
        let alice_amount = 200;

        // The balance is not hidden yet, because we explicitly pass the amount to the function.
        confidential_asset::deposit(bob, token, bob_amount);
        confidential_asset::deposit_to(bob, token, alice_addr, alice_amount);

        print(&utf8(b"Bob's FA balance after the deposit is 200:"));
        print(&primary_fungible_store::balance(bob_addr, token));

        assert!(primary_fungible_store::balance(bob_addr, token) == 200);

        print(&utf8(b"Bob's pending balance is not zero:"));
        print(&confidential_asset::pending_balance(bob_addr, token));

        // In real world, we would not be able to see the someone else's balance as it requires
        // the knowledge of the decryption key.
        // The balance decryption requires solving the discrete logarithm problem,
        // so we just check if the passed amount is correct for simplicity.
        assert!(confidential_asset::verify_pending_balance(bob_addr, token, &bob_dk, bob_amount));

        print(&utf8(b"Alice's pending balance is not zero:"));
        print(&confidential_asset::pending_balance(alice_addr, token));

        assert!(confidential_asset::verify_pending_balance(alice_addr, token, &alice_dk, alice_amount));
    }
}

```

### Rollover Pending Balance

```move filename="confidential_asset.move"
public entry fun rollover_pending_balance(sender: &signer, token: Object<Metadata>)
```

The `rollover_pending_balance` function adds the pending balance to the actual one, resetting the pending balance to zero.
It works with no additional proofs as this function utilizes properties of the [Homomorphic encryption](#homomorphic-encryption) used in the protocol.

<Aside type="note">
  You cannot spend money from the pending balance directly. It must be rolled over to the actual balance first.
</Aside>

<Aside type="caution">
  The actual balance must be [normalized](#normalization) before performing a rollover.
  If it is not normalized, you can use the [`normalize`](#normalize) function to do so.
</Aside>

<Aside type="caution">
  Calling the `rollover_pending_balance` function in a separate transaction is crucial for preventing "front-running" attacks.
</Aside>

```move filename="rollover_example.move"
#[test_only]
module confidential_asset_example::rollover_example {
    /// ...

    fun rollover(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek = twisted_elgamal::pubkey_to_bytes(&bob_ek);

        let bob_amount = 100;

        confidential_asset::register(bob, token, bob_ek);
        confidential_asset::deposit(bob, token, bob_amount);

        print(&utf8(b"Bob's pending balance is NOT zero:"));
        print(&confidential_asset::pending_balance(bob_addr, token));

        print(&utf8(b"Bob's actual balance is zero:"));
        print(&confidential_asset::actual_balance(bob_addr, token));

        assert!(confidential_asset::verify_pending_balance(bob_addr, token, &bob_dk, bob_amount));
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_dk, 0));

        // No explicit normalization is required, as the actual balance is already normalized.
        assert!(confidential_asset::is_normalized(bob_addr, token));

        confidential_asset::rollover_pending_balance(bob, token);

        print(&utf8(b"Bob's pending balance is zero:"));
        print(&confidential_asset::pending_balance(bob_addr, token));

        print(&utf8(b"Bob's actual balance is NOT zero:"));
        print(&confidential_asset::actual_balance(bob_addr, token));

        assert!(confidential_asset::verify_pending_balance(bob_addr, token, &bob_dk, 0));
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_dk, (bob_amount as u128)));
    }
}
```

### Confidential Transfer

```move filename="confidential_asset.move"
public entry fun confidential_transfer(
    sender: &signer,
    token: Object<Metadata>,
    to: address,
    new_balance: vector<u8>,
    sender_amount: vector<u8>,
    recipient_amount: vector<u8>,
    auditor_eks: vector<u8>,
    auditor_amounts: vector<u8>,
    zkrp_new_balance: vector<u8>,
    zkrp_transfer_amount: vector<u8>,
    sigma_proof: vector<u8>)
```

The `confidential_transfer` function transfers tokens from the sender's actual balance to the recipient's
pending balance. The sender encrypts the transferred amount using the recipient's encryption key, enabling the recipient's
confidential balance to be updated [homomorphically](#homomorphic-encryption).

To ensure transparency, the sender could also encrypt the transferred amount using the auditors' EKs,
allowing the auditors to decrypt the transferred amount on their end.

<Aside type="caution">
  If the global auditor is set, it must be included in the `auditor_eks` list as the FIRST element (see the example below).
</Aside>

<Aside type="note">
  Once a user has participated in at least one transfer, their balance becomes "hidden".
  This means that neither the transferred amount nor the updated balances of the sender and recipient are visible to external observers.
</Aside>

```move filename="transfer_example.move"
#[test_only]
module confidential_asset_example::transfer_example {
    /// ...

    fun transfer(bob: &signer, alice: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);
        let alice_addr = signer::address_of(alice);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (alice_dk, alice_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        // Note: If the asset-specific auditor is set, we need to include it in the `auditor_eks` vector as the FIRST element.
        //
        // let asset_auditor_ek = confidential_asset::get_auditor(token);
        // let auditor_eks = vector[];
        // if (asset_auditor_ek.is_some()) {
        //     auditor_eks.push_back(asset_auditor_ek.extract());
        // };

        let (_, auditor_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let auditor_eks = vector[auditor_ek];

        let bob_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_ek);
        let alice_ek_bytes = twisted_elgamal::pubkey_to_bytes(&alice_ek);

        confidential_asset::register(bob, token, bob_ek_bytes);
        confidential_asset::register(alice, token, alice_ek_bytes);

        // Bob's current balance is 300, and he wants to transfer 50 to Alice, whose balance is zero.
        let bob_current_amount = 300;
        let bob_new_amount = 250;
        let transfer_amount = 50;
        let alice_current_amount = 0;
        let alice_new_amount = 50;

        confidential_asset::deposit(bob, token, bob_current_amount);
        confidential_asset::rollover_pending_balance(bob, token);

        print(&utf8(b"Bob's actual balance is 300"));
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_dk, (bob_current_amount as u128)));

        print(&utf8(b"Alice's pending balance is zero"));
        assert!(confidential_asset::verify_pending_balance(alice_addr, token, &alice_dk, alice_current_amount));

        let current_balance = confidential_balance::decompress_balance(
            &confidential_asset::actual_balance(bob_addr, token)
        );

        let (
            proof,
            // New balance is the balance after the transfer encrypted with the sender's encryption key.
            // It will be set as the new actual balance for the sender.
            new_balance,
            // Transfer amount encrypted with the sender's encryption key.
            // Used for indexing purposes only.
            sender_amount,
            // Transfer amount encrypted with the recipient's encryption key.
            // It will be Homomorphically added to the recipient's pending balance.
            recipient_amount,
            // Transfer amount encrypted with the auditors' encryption keys.
            // It won't be stored on-chain, but an auditor can decrypt the transfer amount with its dk.
            auditor_amounts
        ) = confidential_proof::prove_transfer(
            &bob_dk,
            &bob_ek,
            &alice_ek,
            transfer_amount,
            bob_new_amount,
            &current_balance,
            &auditor_eks,
        );

        let (
            sigma_proof,
            zkrp_new_balance,
            zkrp_transfer_amount
        ) = confidential_proof::serialize_transfer_proof(&proof);

        confidential_asset::confidential_transfer(
            bob,
            token,
            alice_addr,
            confidential_balance::balance_to_bytes(&new_balance),
            confidential_balance::balance_to_bytes(&sender_amount),
            confidential_balance::balance_to_bytes(&recipient_amount),
            confidential_asset::serialize_auditor_eks(&auditor_eks),
            confidential_asset::serialize_auditor_amounts(&auditor_amounts),
            zkrp_new_balance,
            zkrp_transfer_amount,
            sigma_proof
        );

        print(&utf8(b"Bob's actual balance is 250"));
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_dk, bob_new_amount));

        print(&utf8(b"Alice's pending balance is 50"));
        assert!(confidential_asset::verify_pending_balance(alice_addr, token, &alice_dk, alice_new_amount));
    }
}
```

### Withdraw

```move filename="confidential_asset.move"
public entry fun withdraw(
    sender: &signer,
    token: Object<Metadata>,
    amount: u64,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<u8>,
    sigma_proof: vector<u8>)
```

```move filename="confidential_asset.move"
public entry fun withdraw_to(
    sender: &signer,
    token: Object<Metadata>,
    to: address,
    amount: u64,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<u8>,
    sigma_proof: vector<u8>)
```

The `withdraw` and `withdraw_to` allow a user to withdraw tokens from the protocol,
transferring the passed amount from the actual balance of the sender to the primary FA store of the recipient.
This function enables users to release tokens while not revealing their remaining balances.

<Aside type="caution">
  Attempting to withdraw more tokens than available will cause an error.
</Aside>

```move filename="withdraw_example.move"
#[test_only]
module confidential_asset_example::withdraw_example {
    /// ...

    fun withdraw(bob: &signer, alice: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);
        let alice_addr = signer::address_of(alice);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (_alice_dk, alice_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_ek);
        let alice_ek_bytes = twisted_elgamal::pubkey_to_bytes(&alice_ek);

        confidential_asset::register(bob, token, bob_ek_bytes);
        confidential_asset::register(alice, token, alice_ek_bytes);

        let bob_current_amount = 500;
        let bob_new_amount = 450;
        let transfer_amount = 50;

        // Bob withdraws all available tokens
        confidential_asset::deposit(bob, token, (bob_current_amount as u64));
        confidential_asset::rollover_pending_balance(bob, token);

        print(&utf8(b"Alice's FA balance before the withdrawal is zero:"));
        print(&primary_fungible_store::balance(alice_addr, token));

        assert!(primary_fungible_store::balance(alice_addr, token) == 0);

        print(&utf8(b"Bob's actual balance before the withdrawal is 500"));
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_dk, bob_current_amount));

        let current_balance = confidential_balance::decompress_balance(
            &confidential_asset::actual_balance(bob_addr, token)
        );

        let (proof, new_balance) = confidential_proof::prove_withdrawal(
            &bob_dk,
            &bob_ek,
            transfer_amount,
            bob_new_amount,
            &current_balance
        );

        let new_balance = confidential_balance::balance_to_bytes(&new_balance);
        let (sigma_proof, zkrp_new_balance) = confidential_proof::serialize_withdrawal_proof(&proof);

        confidential_asset::withdraw_to(
            bob,
            token,
            alice_addr,
            transfer_amount,
            new_balance,
            zkrp_new_balance,
            sigma_proof
        );

        print(&utf8(b"Alice's FA balance after the withdrawal is 50:"));
        print(&primary_fungible_store::balance(alice_addr, token));

        assert!(primary_fungible_store::balance(alice_addr, token) == 50);

        print(&utf8(b"Bob's actual balance after the withdrawal is 450"));
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_dk, bob_new_amount));
    }
}
```

### Rotate Encryption Key

```move filename="confidential_asset.move"
public entry fun rotate_encryption_key(
    sender: &signer,
    token: Object<Metadata>,
    new_ek: vector<u8>,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<u8>,
    sigma_proof: vector<u8>)
```

```move filename="confidential_asset.move"
public entry fun rotate_encryption_key_and_unfreeze(
    sender: &signer,
    token: Object<Metadata>,
    new_ek: vector<u8>,
    new_confidential_balance: vector<u8>,
    zkrp_new_balance: vector<u8>,
    rotate_proof: vector<u8>)
```

```move filename="confidential_asset.move"
public entry fun rollover_pending_balance_and_freeze(sender: &signer, token: Object<Metadata>)
```

The `rotate_encryption_key` function modifies the user's EK and re-encrypts the actual balance with the new EK.
This function checks that the pending balance is zero before proceeding, guaranteeing that the user does not lose funds during the rotation.

To facilitate the rotation process:

- The pending balance must first be rolled over and frozen by calling `rollover_pending_balance_and_freeze`.
  This prevents new transactions from being processed during the key rotation.
- Then the EK can be rotated and unfrozen using `rotate_encryption_key_and_unfreeze`.

<Aside type="caution">
  Calling `rotate_encryption_key` with a non-zero pending balance will cause an error.
</Aside>

```move filename="rotate_example.move"
#[test_only]
module confidential_asset_example::rotate_example {
    /// ...

    fun rotate(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_current_dk, bob_current_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (bob_new_dk, bob_new_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_current_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_current_ek);
        let bob_new_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_new_ek);

        let bob_amount = 100;

        confidential_asset::register(bob, token, bob_current_ek_bytes);
        confidential_asset::deposit(bob, token, (bob_amount as u64));

        // We need to rollover the pending balance and freeze the token to prevent any new deposits being come.
        confidential_asset::rollover_pending_balance_and_freeze(bob, token);

        print(&utf8(b"Bob's encryption key before the rotation:"));
        print(&confidential_asset::encryption_key(bob_addr, token));

        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_current_dk, bob_amount));

        let current_balance = confidential_balance::decompress_balance(
            &confidential_asset::actual_balance(bob_addr, token)
        );

        let (proof, new_balance) = confidential_proof::prove_rotation(
            &bob_current_dk,
            &bob_new_dk,
            &bob_current_ek,
            &bob_new_ek,
            bob_amount,
            &current_balance
        );

        let (
            sigma_proof,
            zkrp_new_balance
        ) = confidential_proof::serialize_rotation_proof(&proof);

        // After rotating the encryption key, we unfreeze the token to allow new deposits.
        confidential_asset::rotate_encryption_key_and_unfreeze(
            bob,
            token,
            bob_new_ek_bytes,
            confidential_balance::balance_to_bytes(&new_balance),
            zkrp_new_balance,
            sigma_proof
        );

        print(&utf8(b"Bob's encryption key after the rotation:"));
        print(&confidential_asset::encryption_key(bob_addr, token));

        // Note that here we use the new decryption key to verify the actual balance.
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_new_dk, bob_amount));
    }
}
```

### Normalize

```move filename="confidential_asset.move"
public entry fun normalize(
    sender: &signer,
    token: Object<Metadata>,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<u8>,
    sigma_proof: vector<u8>)
```

```move filename="confidential_asset.move"
public fun is_normalized(user: address, token: Object<Metadata>): bool
```

The `normalize` function ensures that the actual balance is reduced to 16-bit chunks for [efficient decryption](#normalization).
This is necessary only before the `rollover_pending_balance` operation, which requires the actual balance to be normalized beforehand.

All other functions, such as `withdraw` or `confidential_transfer`, handle normalization implicitly, making manual normalization unnecessary in those cases.

<Aside type="note">
  All functions except `rollover_pending_balance` perform implicit normalization.
</Aside>

<Aside type="caution">
  Calling a `rollover_pending_balance` when the actual balance is already normalized will cause an error.
  You can check if the actual balance is normalized using the `is_normalized` function.
</Aside>

```move filename="normalize_example.move"
#[test_only]
module confidential_asset_example::normalize_example {
    /// ...

    fun normalize(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_ek);

        let bob_amount = 500;

        confidential_asset::register(bob, token, bob_ek_bytes);
        confidential_asset::deposit(bob, token, (bob_amount as u64));

        // The rollover function is the only function that requires the actual balance to be normalized
        // beforehand and leaves it unnormalized after execution, no matter what the pending balance was.
        confidential_asset::rollover_pending_balance(bob, token);

        assert!(!confidential_asset::is_normalized(bob_addr, token));

        confidential_asset::deposit(bob, token, (bob_amount as u64));

        // Before performing a second rollover, the actual balance must be normalized.
        // You will get an error if you try to rollover an unnormalized balance:
        // confidential_asset::rollover_pending_balance(bob, token);

        let current_balance = confidential_balance::decompress_balance(
            &confidential_asset::actual_balance(bob_addr, token)
        );

        let (
            proof,
            new_balance
        ) = confidential_proof::prove_normalization(
            &bob_dk,
            &bob_ek,
            bob_amount,
            &current_balance
        );

        let (sigma_proof, zkrp_new_balance) = confidential_proof::serialize_normalization_proof(&proof);

        confidential_asset::normalize(
            bob,
            token,
            confidential_balance::balance_to_bytes(&new_balance),
            zkrp_new_balance,
            sigma_proof
        );

        assert!(confidential_asset::is_normalized(bob_addr, token));
        assert!(confidential_asset::verify_actual_balance(bob_addr, token, &bob_dk, bob_amount));

        // A rollover can be performed once the balance is normalized.
        // Note that functions like `withdraw` and `confidential_transfer` do not require the actual balance
        // to be normalized beforehand, as zk-proofs guarantee that the actual balance is normalized after
        // their execution.
        confidential_asset::rollover_pending_balance(bob, token);
    }
}
```

## Useful Resources

- [Confidential Asset SDK](/build/sdks/ts-sdk/confidential-asset)

# Create Package (Move)

> Learn about create package for Move smart contract development on Aptos blockchain.

import { Aside, FileTree, Steps } from '@astrojs/starlight/components';

import { RemoteCodeblock } from '~/components/RemoteCodeblock';

<Aside type="note">
  We recommend installing the Aptos CLI before beginning.
  If you haven't already installed the Aptos CLI, see the [CLI section](/build/cli)
</Aside>

<Steps>
  1. aptos move init

     In a new project directory, initialize a Move package by running:

     ```shellscript filename="Terminal"
     aptos move init --name <PROJECT_NAME>
     ```

     You should now have a Move project that looks like so:

     <FileTree>
       - scripts/
       - sources/
       - tests/
       - Move.toml
     </FileTree>

     <Aside type="note">
       You can also create a Move package from a [template](/build/cli/start-from-template).
     </Aside>

  2. Update Move.toml

     In `Move.toml`, fill in the following key information:

     1. `name`: name of your package
     2. `version`: package version (default is `"0.0.0"`)
     3. `addresses`: Describes which address the module will be deployed to.  These are named addresses that can be used as aliases.  In the below example, we will use `hello_blockchain` as the named address.
     4. `dependencies`: You will likely want to use `AptosFramework` and other [Third Party Dependencies](/build/smart-contracts/third-party-dependencies)

     Below is an example

     ```toml filename="Move.toml"
     [package]
     name = "Examples"
     version = "0.0.0"

     [addresses]
     hello_blockchain = "_"

     [dependencies.AptosFramework]
     git = "https://github.com/aptos-labs/aptos-framework.git"
     rev = "mainnet"
     subdir = "aptos-framework"
     ```

  3. Add to sources directory

     Add your code in the `sources` directory. Here we have a `hello_blockchain.move` example.

     <RemoteCodeblock permalink="https://github.com/aptos-labs/aptos-core/blob/afd3706c17bcccfb39a9d6059aecbfa648ed295d/aptos-move/move-examples/hello_blockchain/sources/hello_blockchain.move#L1-L64" />
</Steps>

# Cryptography

> Learn about cryptography for Move smart contract development on Aptos blockchain.

import { Aside } from '@astrojs/starlight/components';

Cryptography plays an integral role in ensuring the security, integrity, confidentiality, and immutability of data in blockchain systems. The Aptos adapter for Move provides developers with an array of cryptographic primitives to cater to this need. This document delves into the cryptographic functionalities offered by Move on Aptos and elucidates the principles that drive their design.

## Cryptographic primitives

Move, through the Aptos adapter, encompasses several fundamental cryptographic tools:

1. [Cryptographic Hash Functions](#cryptographic-hash-functions) ‚Äì Algorithms that produce a fixed-size output (hash) from variable-sized input data. Supported functions include SHA2-256, SHA3-256, Keccak256, and Blake2b-256.
2. [Digital Signature Verification](#digital-signature-verification) ‚Äì Algorithms for signing a message to ensure its integrity, authenticate its sender, ensure non-repudiation, or any combination thereof. Supported signature schemes include Ed25519, ECDSA, and BLS.
3. [Elliptic Curve Arithmetic](#elliptic-curve-arithmetic) ‚Äì Elliptic curves are one of the building blocks of advanced cryptographic primitives, such as digital signatures, public-key encryption or verifiable secret sharing. Supported curves include Ristretto255, BN254 and BLS12-381.
4. [Zero-Knowledge Proofs (ZKP)](#building-powerful-cryptographic-applications) ‚Äì These cryptographic techniques enable a party to prove that a relation $R(x; w)$ is satisfied on a public statement $x$ without leaking the secret witness $w$ that makes it hold. Currently, we support Groth16 ZKP verification and Bulletproofs ZK range proof verification.

Three fundamental principles guide the design and integration of the Aptos cryptographic extensions into Move:

1. **Economic Gas Usage** ‚Äì Striving to minimize gas costs for Move developers by implementing key primitives as [Move native functions](/build/smart-contracts/book/functions#native-functions). For example, see the module for [BLS signatures over BLS12-381 elliptic curves](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move).
2. **Type-Safe APIs** ‚Äì Ensuring that APIs are resistant to common mistakes, type-safety enhances code reliability and promotes an efficient development process. For an example, see the [Ed25519 signature module](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move).
3. **Empowerment of Developers** ‚Äì In instances where native functions are unavailable, we empower developers to build their own cryptographic primitives on top of abstract cryptographic building blocks such as _finite fields_ and _Abelian groups_. Refer to the [`aptos_std::crypto_algebra`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move) module for more insights.

Continue reading to delve a bit deeper and uncover some of the intricacies behind these extensions, as well as the range of applications they empower. For the most comprehensive understanding of this subject, refer to the [cryptography Move modules code](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/framework/aptos-stdlib/sources/cryptography).

## Cryptographic hash functions

Developers can now use more cryptographic hash functions in Move via the [`aptos_std::aptos_hash`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/hash.move) module:

| Hash function | Hash size (bits) | Cost for hashing 1KiB (in internal gas units) | Collision-resistance security (bits) |
| ------------- | ---------------- | --------------------------------------------- | ------------------------------------ |
| Keccak256     | 256              | 1,001,600                                     | 128                                  |
| SHA2-256      | 256              | 1,084,000                                     | 128                                  |
| SHA2-512      | 512              | 1,293,600                                     | 256                                  |
| SHA3-256      | 256              | 1,001,600                                     | 128                                  |
| SHA3-512      | 512              | 1,114,000                                     | 256                                  |
| RIPEMD160     | 160              | 1,084,000                                     | 80 (**weak**)                        |
| Blake2b-256   | 256              | 342,200                                       | 128                                  |

All hash functions have the same security properties (e.g., one-wayness, collision resistance, etc.), but their security levels are different.

<Aside type="caution">
  RIPEMD160 should be avoided as a collision-resistant function due to its 80-bit security level. It is mainly supported for backward-compatibility reasons: e.g., Bitcoin address derivation relies on RIPEMD160.
</Aside>

Some of these functions can be used for interoperability with other chains (e.g., verifying Ethereum Merkle proofs via [`aptos_std::aptos_hash::keccak256`](https://github.com/aptos-labs/aptos-core/blob/137acee4c6dddb1c86398dce25b041d78a3028d3/aptos-move/framework/aptos-stdlib/sources/hash.move#L35)).
Others, have lower gas costs, such as [`aptos_std::aptos_hash::blake2b_256`](https://github.com/aptos-labs/aptos-core/blob/137acee4c6dddb1c86398dce25b041d78a3028d3/aptos-move/framework/aptos-stdlib/sources/hash.move#L69).
In general, a wider variety of hash functions give developers additional freedom in terms of both security and interoperability with other off-chain cryptographic systems.

## Digital signature verification

Developers can now use a _type-safe_ API for verifying many kinds of digital signatures in Move:

| Signature scheme                                                                                                                                           | Curve         | Sig. size (bytes) | PK size (bytes) | Malleability | Assumptions | Pros          | Cons                |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ----------------- | --------------- | ------------ | ----------- | ------------- | ------------------- |
| [ECDSA](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/secp256k1.move)                          | secp256k1     | 64                | 64              | Yes          | GGM         | Wide adoption | Security proof      |
| [Ed25519](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move)                          | Edwards 25519 | 64                | 32              | No           | DLA, ROM    | Fast          | Subtleties          |
| [MultiEd25519](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/multi_ed25519.move)               | Edwards 25519 | $4 + t \cdot 64$  | $n \cdot 32$    | No           | DLA, ROM    | Easy-to-adopt | Large sig. size     |
| [MinPK BLS](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move)                       | BLS12-381     | 96                | 48              | No           | CDH, ROM    | Versatile     | Slower verification |
| [MinSig BLS](https://github.com/aptos-labs/aptos-core/blob/7d4fb98c6604c67e526a96f55668e7add7aaebf6/aptos-move/move-examples/drand/sources/drand.move#L57) | BLS12-381     | 48                | 96              | No           | CDH, ROM    | Versatile     | Slower verification |

<Aside type="note">
  - CDH stands for the _"Computational Diffie-Hellman Assumption"_
  - DLA stands for the _"Discrete Log Assumption"_
  - GGM stands for the _"Generic Group Model"_
  - ROM stands for the _"Random Oracle Model"_
</Aside>

The digital signature modules above can be used to build smart contract-based wallets, secure claiming mechanisms for airdrops, or any digital-signature-based access-control mechanism for dapps.

The right choice of a signature scheme in your dapp could depend on many factors:

1. **Backwards-compatibility**
   - If your dapp's user base predominantly uses a particular signing mechanism, it would be prudent to support that mechanism for ease of transition and adoption.
     - Example: If users mainly sign using Ed25519, it becomes a logical choice.
2. **Ease-of-implementation**
   - While theoretically sound, complex protocols may be challenging to implement in practice.
     - Example: Even though $t$-out-of-$n$ threshold protocols for Ed25519 exist, their intricacy on the signer's side might push developers toward MultiEd25519 due to its more straightforward signing implementation.
3. **Efficiency**
   - Depending on the dapp's requirements, you might prioritize one aspect of efficiency over another.
     - Signature size vs. public key size: Some applications might prioritize a smaller signature footprint, while others might emphasize a compact PK.
     - Signing time vs. verification time: For certain dapps, the signing speed might be more crucial, while for others, rapid signature verification could be the priority.
4. **Security analysis**
   - It is essential to consider the underlying assumptions and potential vulnerabilities of a signature scheme.
     - Example: ECDSA's security is proven under strong assumptions such as the Generic Group Model (GGM).
     - Malleability concerns: Some signature schemes are susceptible to malleability, where a valid signature, $\sigma$, can be mauled into a different yet still valid signature, $\sigma$, for the same message $m$.
5. **Versatility**
   - The adaptability and flexibility of signature schemes are important to consider, so you may properly accommodate the cryptographic needs of your dapp.
     - Example: $t$-out-of-$n$ threshold BLS signatures are very simple to implement.

<Aside type="caution">
  Despite its careful, principled design[^ed25519], Ed25519 has known implementation subtleties. For example, different implementations could easily disagree on the validity of signatures, especially when batch verification is employed[^devalence]$^,$[^eddsa].
</Aside>

<Aside type="note">
  Our [`aptos_std::bls12381`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move) module for [MinPK BLS](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05#name-variants) supports verification of individual signatures, **multi**-signatures, **aggregate** signatures and **threshold** signatures.
</Aside>

## Elliptic curve arithmetic

While the [hash function](#cryptographic-hash-functions) and [digital signature](#digital-signature-verification) modules should provide enough functionality for most applications, some applications will require more powerful cryptography.
Normally, developers of such applications would have to wait until their desired cryptographic functionality is implemented efficiently as a [Move native function](/build/smart-contracts/book/functions#native-functions) in the [Aptos Move framework](/network/blockchain/move).
Instead, we expose basic building blocks that developers can use to implement their own cryptographic primitives directly in the Move language and do so **efficiently**.

Specifically, we currently expose low-level arithmetic operations on two popular elliptic curve groups and their associated finite fields:

1. Ristretto255, via [`aptos_std::ristretto255`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move)
2. BLS12-381, via [`aptos_std::crypto_algebra`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move)
   and the marker types in [`aptos_std::bls12381_algebra`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381_algebra.move)
3. BN254, similarly via `aptos_std::crypto_algebra` and the marker types in [`aptos_std::bls12381_algebra`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/bn254_algebra.move)

These modules support low-level operations such as:

- scalar multiplication of elliptic curve points
- multi-scalar multiplications (MSMs)
- pairings
- scalar addition, multiplication, inversion
- hashing to a scalar or to a point
- and many more

Examples of powerful applications that can be built on top include:

1. **Validity rollups** ‚Äì See the [`groth16` zkSNARK verifier example](#groth16-zksnark-verifier).
2. **Randomness-based games** ‚Äì See the [`drand` verifier example](#verifying-randomness-from-the-drand-beacon).
3. **Privacy-preserving applications** ‚Äì See the [`veiled_coin` example](#veiled-coins).

### Ristretto255 arithmetic

The [`aptos_std::ristretto255`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move) module provides support for elliptic curve arithmetic on the popular [Ristretto255 curve](https://ristretto.group/).
One of the main advantages of Ristretto255 is that it is a prime order group (unlike the Edwards 25519 curve), which obviates small-subgroup attacks on higher-level cryptosystems built on top of it.
Furthermore, Ristretto255 serialization is canonical and deserialization only accepts canonical encodings, which obviates malleability issues in higher-level protocols.

This module has proven useful for implementing several cryptographic primitives:

1. **Zero-knowledge $\Sigma$-protocols** ‚Äì See the [`veiled_coin` example](#veiled-coins).
2. **ElGamal** encryption ‚Äì See [`aptos_std::ristretto255_elgamal`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move)
3. **Pedersen** commitments ‚Äì See [`aptos_std::ristretto255_pedersen`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_pedersen.move)
4. **Bulletproofs** ZK range proofs[^bulletproofs] ‚Äì See [`aptos_std::ristretto255_bulletproofs`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_bulletproofs.move)

Need ideas for a cryptosystem to build on top of `ristretto255`?
A popular primitive that you could easily build would be the [schnorrkel](https://github.com/w3f/schnorrkel) signature scheme, which is a hardened version of Schnorr signatures over Ristretto255 groups.

### Generic elliptic curve arithmetic

What is better than one curve? More curves!

The [`aptos_std::crypto_algebra`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move) provides elliptic curve arithmetic operations for **any** supported elliptic curve, including pairing-friendly curves.
As a consequence, Move developers can implement a cryptosystem generically over **any** curve that is or will be supported in the future.
Compared to fixing a particular curve in the code (e.g., by implementing against the [Ristretto255 module](#ristretto255-arithmetic)), this approach provides more flexibility and lowers development time when migrating to a different curve.

Although currently the `crypto_algebra` module only supports arithmetic over BN254 and BLS12-381 curves (via the marker types declared in [`aptos_std::bls12381_algebra`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381_algebra.move) and in [`aptos_std::bn254_algebra`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/sources/cryptography/bn254_algebra.move)), more curves will be supported into the future (e.g., Ristretto255, BLS12-377, BW6-761, secp256k1, secp256r1).

As an example, a Move developer can implement the popular Boneh-Lynn-Shacham (BLS) signature scheme generically over **any** curve by using [type arguments](/build/smart-contracts/book/functions#type-parameters) for the curve type in their implementation:

```rust
use std::option;
use aptos_std::crypto_algebra::{eq, pairing, one, deserialize, hash_to};

/// Example of a BLS signature verification function that works over any pairing-friendly
/// group triple `Gr1`, `Gr2`, `GrT` where signatures are in `Gr1` and PKs in `Gr2`.
/// Points are serialized using the format in `FormatG1` and `FormatG2` and the hashing
/// method is `HashMethod`.
///
/// WARNING: This example is type-unsafe and probably not a great fit for production code.
public fun bls_verify_sig<Gr1, Gr2, GrT, FormatG1, FormatG2, HashMethod>(
    dst:        vector<u8>,
    signature:  vector<u8>,
    message:    vector<u8>,
    public_key: vector<u8>): bool
{
    let sig  = option::extract(&mut deserialize<Gr1, FormatG1>(&signature));
    let pk   = option::extract(&mut deserialize<Gr2, FormatG2>(&public_key));
    let hash = hash_to<Gr1, HashMethod>(&dst, &message);

    // Checks if $e(H(m), pk) = e(sig, g_2)$, where $g_2$ generates $\mathbb{G}_2$
    eq(
        &pairing<Gr1, Gr2, GrT>(&hash, &pk),
        &pairing<Gr1, Gr2, GrT>(&sig, &one<Gr2>())
    )
}
```

Using the `bls_verify_sig` _generic_ function from above, developers can verify BLS signatures over **any** of the supported (pairing-friendly) curves.
For example, one can verify [MinSig BLS](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05#name-variants) signatures over BLS12-381 curves by calling the function above with the right BLS12-381 marker types as its type arguments:

```rust
use aptos_std::bls12381_algebra::{
    G1, G2, Gt, FormatG1Compr, FormatG2Compr, HashG1XmdSha256SswuRo
};

// Aborts with code 1 if the MinSig BLS signature over the BLS12-381 curve fails to verify.
assert(
    bls_verify_sig<G1, G2, Gt, FormatG1Compr, FormatG2Compr, HashG1XmdSha256SswuRo>(
        dst, signature, message, public_key
    ),
    1
);
```

For more use cases of the `crypto_algebra` module, check out some Move examples:

1. [Verifying Groth16 zkSNARK proofs](#groth16-zksnark-verifier) over **any** curve
2. [Verifying randomness from the `drand` beacon](#verifying-randomness-from-the-drand-beacon)

## Building powerful cryptographic applications

### Veiled coins

The [`veiled_coin` example](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-experimental/sources/veiled_coin/) demonstrates how to use [the Ristretto255 modules from above](#ristretto255-arithmetic) to add a reasonable layer of confidentiality to coin balances and transactions.

Specifically, users can **veil** their balance, keeping it hidden from everyone, including validators.
Furthermore, a user can send a **veiled transaction** that hides the transaction amount from everybody, including validators.
An important caveat is that veiled transactions do **not** hide the identities of the sender or the recipient.

<Aside type="danger">
  This module is educational. It is **not** production-ready. Using it could lead to loss of funds.
</Aside>

### Groth16 zkSNARK verifier

The [`groth16` example](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/move-examples/groth16_example/sources/groth16.move) demonstrates how to verify Groth16 zkSNARK proofs[^groth16], which are the shortest, fastest-to-verify, general-purpose zero-knowledge proofs.
Importantly, as explained [above](#generic-elliptic-curve-arithmetic), this implementation is _generic_ over **any** curve, making it very easy for Move developers to use it with their favorite (supported) curves.

If you need help converting your `snarkjs` Groth16 VK, proof and public inputs to the expected format for the Move verifier above, you can use [this community tool](https://github.com/zjma/snarkjs-to-aptos).

<Aside type="note">
  This code has not been audited by a third-party organization. If using it in a production system, proceed at your own risk.
</Aside>

### Verifying randomness from the `drand` beacon

The [`drand` example](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/drand/sources) shows how to verify public randomness from the [drand](https://drand.love) randomness beacon.
This randomness can be used in games or any other chance-based smart contract.
We give a simple example of a lottery implemented on top of `drand` randomness in [`lottery.move`](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/drand/sources/lottery.move).

<Aside type="note">
  This code has not been audited by a third-party organization. If using it in a production system, proceed at your own risk.
</Aside>

Another application that can be built on top of `drand` is time-lock encryption[^tlock], which allows users to encrypt information such that it can only be decrypted in a future block.
We do not currently have an implementation but the reader is encouraged to write one!

[^bulletproofs]: _bulletproofs:_ **Bulletproofs: Short Proofs for Confidential Transactions and More**; by B. B√ºnz and J. Bootle and D. Boneh and A. Poelstra and P. Wuille and G. Maxwell; in 2018 IEEE Symposium on Security and Privacy

[^devalence]: _devalence:_ **It‚Äôs 255:19AM. Do you know what your validation criteria are?**, by Henry de Valence, [https://hdevalence.ca/blog/2020-10-04-its-25519am](https://hdevalence.ca/blog/2020-10-04-its-25519am)

[^ed25519]: _ed25519:_ **Ed25519: high-speed high-security signatures**, by Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, Bo-Yin Yang, [https://ed25519.cr.yp.to/](https://ed25519.cr.yp.to/)

[^eddsa]: _eddsa:_ **Taming the Many EdDSAs**, by Konstantinos Chalkias, Fran√ßois Garillot, Valeria Nikolaenko, in SSR 2020, [https://dl.acm.org/doi/abs/10.1007/978-3-030-64357-7\_4](https://dl.acm.org/doi/abs/10.1007/978-3-030-64357-7_4)

[^groth16]: _groth16:_ **On the Size of Pairing-Based Non-interactive Arguments**; by Groth, Jens; in EUROCRYPT 2016

[^tlock]: _tlock:_ **tlock: Practical Timelock Encryption from Threshold BLS**; by Nicolas Gailly and Kelsey Melissaris and Yolan Romailler; [https://eprint.iacr.org/2023/189](https://eprint.iacr.org/2023/189)

# Debugging Move

> Learn about debugging for Move smart contract development on Aptos blockchain.

Move was designed to be simple and safe, but like with all programming languages,
bugs can still occur. This guide will help you debug your Move code and figure out
what went wrong.

Please feel free to contribute with additional tooling and information that can
help others in the community.

## Debugging with the Aptos CLI

### Simulation on transaction submission

You can use the Aptos CLI to simulate entry functions prior to executing them.

Normally, a transaction will fail in simulation if it won't work on-chain. For example:

```shellscript name="Terminal"
aptos move run --function-id 0x1::aptos_account::transfer --args address:0x1 u64:1000000000000000000
{
  "Error": "Simulation failed with status: Move abort in 0x1::coin: EINSUFFICIENT_BALANCE(0x10006): Not enough coins to complete transaction"
}
```

The same applies to Move scripts as well. For example:

```shellscript name="Terminal"
 aptos move run-script --script-path <script_path> ...
```

### Local Simulation

Additionally, for some situations, local simulation, may give additional information and
[print out any debug statements you have in your code](/build/cli/working-with-move-contracts#printing-debugging-information).

```shellscript name="Terminal"
aptos move run --function-id 0x1::aptos_account::transferred --args address:0x1 u64:1000000000000000000 --local

Simulating transaction locally...
{
  "Result": {
    "transaction_hash": "0x4115316915d409ba4106632c82d4b09220035ffdbd0b86bbe29a586d03d06318",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "78077fe8db589e1a3407170cf8af3bd60a8c95737918c15dd6f49dcbecc7900a",
    "success": false,
    "version": 56634003,
    "vm_status": "status FUNCTION_RESOLUTION_FAILURE of type Verification with message Function 0x1::aptos_account::transferred does not exist"
  }
}
```

### Gas Profiling and Tracing

Adding the gas profile will additionally add the ability to trace how much gas is
used in computation:

```shellscript name="Terminal"
aptos move run --function-id 0x1::aptos_account::transferred --args address:0x1 u64:1000000000000000000 --profile-gas

Simulating transaction locally using the gas profiler...
Gas report saved to gas-profiling/txn-a90ca655-0x1-aptos_account-transferred.
{
  "Result": {
    "transaction_hash": "0xa90ca6550dcdd7f514f4cdcdee7dc1fbee17082fcf68f3db3e5755a93b89bcfc",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "78077fe8db589e1a3407170cf8af3bd60a8c95737918c15dd6f49dcbecc7900a",
    "success": false,
    "version": 56651618,
    "vm_status": "status FUNCTION_RESOLUTION_FAILURE of type Verification with message Function 0x1::aptos_account::transferred does not exist"
  }
}
```

And this will generate a gas report viewable in HTML format:

```shellscript name="Terminal"
open  gas-profiling/txn-a90ca655-0x1-aptos_account-transferred/index.html
```

## Evaluating performance

```shellscript name="Terminal"
aptos move run --function-id 0x1::aptos_account::transfer --args address:0x1 u64:1 --benchmark

Benchmarking transaction locally...
Running time (cold code cache): 22.144458ms
Running time (warm code cache): 669.5¬µs
{
  "Result": {
    "transaction_hash": "0x7cdf37ff4d798b3ac3f1e860a40428853e381598a511b9291f2a49e5ff6262a0",
    "gas_used": 11,
    "gas_unit_price": 100,
    "sender": "78077fe8db589e1a3407170cf8af3bd60a8c95737918c15dd6f49dcbecc7900a",
    "success": true,
    "version": 56679764,
    "vm_status": "status EXECUTED of type Execution"
  }
}
```

# Object Code Deployment

> Learn about deployment for Move smart contract development on Aptos blockchain.

import { Steps } from '@astrojs/starlight/components';

This document goes through how you can deploy code to [Objects](/build/smart-contracts/objects). This is the recommended way to deploy code to the blockchain, as this reduces deployment complexity,
and safely manages access control policies for the code owner. Note that in this context, code refers to [packages](/build/smart-contracts/book/packages).

Deploying code to objects will guarantee the following:

- Each deployment publishes to a new address.
- Only the **owner of the code object** can upgrade and freeze the code.

This means you can transfer the object to a new owner, and they will have full ownership of the code. You are granting them the rights to upgrade and freeze the code.
There is no need to manage seeds, or deploy to a new address on each deployment. Object code deployment greatly simplifies the deployment process.

## Instructions

Below are the instructions on how to compile, deploy and upgrade code to objects.

<Steps>
  1. Compile code

     Make sure `<named_address>` is left as a placeholder `_`. This is needed as the CLI command will override the address. `<named_address>` value represents the owner of the code, or the owner of the object to deploy the code to.
     Here is an example as `<named_address>` with the value `my_address`.

     ```toml filename="Move.toml"
     [addresses]
     my_address = "_"
     ```

     Compile your move code running the below command.

     - Replace `<named_address>` with the named address.
     - Replace `<your_address>` with the address of your account.

     ```shellscript filename="Terminal"
     aptos move compile --named-addresses <named_address>=<your_address>
     ```

  2. Deploy code to an object

     Deploy the compiled code to an object via the command:

     - Replace `<named_address>` with the named address.

     ```shellscript filename="Terminal"
     aptos move deploy-object --address-name <named_address>
     ```

     **An example can be found below:**

     ```shellscript filename="Terminal"
     aptos move deploy-object --address-name my_address
     ```

     This will ask if you want to publish the code under the specified object address.

     **Example output:**

     ```shellscript filename="Terminal"
     Do you want to publish this package at object address 0x8d6eb306bcf6c61dbaa0dbf8daa8252e121b63e95991afcab3b12d3be7f001ab [yes/no] >
     ```

     **Congrats, you have deployed your code to a new object with a unique address!**

     Take note of the object address as you will need it later for upgrades.

  3. Transfer and upgrade code in an existing package

     First, you may want to transfer the object from the deployer account to an admin account. The admin account will have rights to upgrade the code.

     Here's how you can do it via CLI, here your `deployer_account` should be the current owner of the object.

     ```shellscript
     aptos move run --function-id 0x1::object::transfer --type-args 0x1::object::ObjectCore --args address:<object_address> address:<new_owner_address> --profile <deployer_account_profile>
     ```

     Here's how you can do it via the typescript SDK:

     ```typescript
     const transaction = await aptos.transaction.build.simple({
       sender: deployerAccount.accountAddress,
       data: {
     	  function: "0x1::object::transfer",
           typeArguments: [`0x1::object::ObjectCore`],
     	  functionArguments: [object_address, new_owner_address],
       },
     });
     ```

     Now you can upgrade the code with the designated admin account, as shown below.

     If you wish to upgrade the code in the object deployed, run the following:

     - Replace `<named_address>` with the existing named address.
     - Replace `<code_object_addr>` with the address of the object hosting the code.

     Note: the value for the account name should now be the object address, as the package containing the module(s) is now deployed to that address.

     ```shellscript filename="Terminal"
     aptos move upgrade-object --address-name <named_address> --object-address <code_object_addr>
     ```

     Example of the command above:

     ```shellscript filename="Terminal"
     aptos move upgrade-object --address-name my_address --object-address 0x8d6eb306bcf6c61dbaa0dbf8daa8252e121b63e95991afcab3b12d3be7f001ab
     ```

     This will ask if you want to upgrade the existing code deployed at the object address.

     **Example output:**

     ```shellscript filename="Terminal"
     Do you want to upgrade the package 'MyPackage' at object address 0x8d6eb306bcf6c61dbaa0dbf8daa8252e121b63e95991afcab3b12d3be7f001ab [yes/no]
     ```

     **Congrats, you have upgraded your code in the existing object!**
</Steps>

# Aptos Digital Asset Standard

> Learn about digital asset for Move smart contract development on Aptos blockchain.

import { ThemedImage } from '~/components/ThemedImage';

import { GraphQLEditor } from '~/components/react/GraphQLEditor';

import { Aside } from '@astrojs/starlight/components';

The Digital Asset (DA) standard is a modern Non-Fungible Token (NFT) standard for Aptos. NFTs represent unique assets on-chain, and are stored in collections. These NFTs can be customized to later be transferred, soulbound, burned, mutated, or customized via your own smart contracts.

This standard replaces the legacy [Aptos Token Standard](/build/smart-contracts/aptos-token). The most important improvements to note are:

| **Improvement**         | **Description**                                                                                                |
| ----------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Token Extension**     | Tokens can be easily extended since they are implemented using Move [Objects](/build/smart-contracts/objects). |
| **Direct NFT Transfer** | You can now directly transfer NFTs without the recipient ‚Äúopting-in‚Äù on-chain.                                 |
| **NFT Composability**   | NFTs can own other NFTs for easy composability.                                                                |

If you want a simple way to mint NFTs without the ability to customize or extend their functionality, you can use the `aptos_token` module which implements the DA standard (see the section on how to use it below).

<Aside type="note">
  Note that all Digital Asset modules are deployed at the reserved address `0x4`.
</Aside>

## Using the Digital Asset Standard

This standard is implemented with two Objects:

1. `Collection`s - A set of NFTs with a name and a bit of context for the group.
2. `Token`s - Digital assets which represent unique assets. These are often used to represent NFTs and usually use a `uri` link to point to more info about the asset (ex. a link to an image, video, etc.).

<ThemedImage
  alt="Digital Asset token and collection relationship"
  sources={{
light: '~/images/digital-asset-light.svg',
dark: '~/images/digital-asset-dark.svg',
}}
/>

All `Token`s are required to have a reference to a parent `Collection`, but the parent `Collection` does **not** own the `Token`. Newly minted `Token`s are usually owned by the creator. From there, they can be transferred to other accounts.

## Collections

| **Field**       | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Description** | An optional string smaller than 2048 characters (modifiable with a `MutatorRef`).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **Name**        | A required string to identify the `Collection`. The name must be unique within each account. That means a single creator account cannot create more than one `Collection` with the same name.                                                                                                                                                                                                                                                                                                                                                                                                  |
| **Royalty**     | An optional [`Royalty`](/move-reference/mainnet/aptos-token-objects/royalty#Royalty) struct indicating what % of the sale price goes to the creator of the `Collection`. This can be changed with a `MutatorRef` generated by the [Royalty module](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/royalty.move). The Royalty module is an extension for the DA standard. See example usage in [`aptos_token.move`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/aptos_token.move). |
| **URI length**  | An optional string that is smaller than 512 characters which links to relevant content for the `Collection` (modifiable with a `MutatorRef`).                                                                                                                                                                                                                                                                                                                                                                                                                                                  |

### Creating a `Collection`

There are two ways to create a `Collection` depending on whether you want there to be a maximum supply of `Token`s it can hold.

#### Fixed Maximum Supply

To make a `Collection` with a fixed supply you can use `collection::create_fixed_collection` like so:

```move filename="example.move"
use aptos_token_objects::collection;
use std::option::{Self, Option};
use aptos_framework::string;

public entry fun create_collection(creator: &signer) {
    let max_supply = 1000;
    let royalty = option::none();

    // Maximum supply cannot be changed after collection creation
    collection::create_fixed_collection(
        creator,
        string::utf8(b"My Collection Description"),
        max_supply,
        string::utf8(b"My Collection"),
        royalty,
        string::utf8(b"https://mycollection.com"),
    );
}
```

#### Unlimited Supply

To create a `Collection` with unlimited supply you can use `collection::create_unlimited_collection`:

```move filename="example.move"
use std::option::{Self, Option};
use aptos_framework::string;

public entry fun create_collection(creator: &signer) {
    let royalty = option::none();

    collection::create_unlimited_collection(
        creator,
        string::utf8(b"My Collection Description"),
        string::utf8(b"My Collection"),
        royalty,
        string::utf8(b"https://mycollection.com"),
    );
}
```

<Aside type="caution">
  A `Collection`'s maximum supply cannot be changed after creation.
</Aside>

### Customizing a `Collection`

Since each `Collection` is a [Move Object](/build/smart-contracts/objects), you can customize it by generating permissions called `Ref`s. Each `Ref` allows you to modify an aspect of the Object later on. Beyond the normal [Object Refs](/build/smart-contracts/object/creating-objects), `Collection`s can also get a `MutatorRef` by calling `get_mutator_ref` like so:

```move filename="example.move"
use std::option::{Self, Option};
use aptos_framework::string;

public entry fun create_collection(creator: &signer) {
    let royalty = option::none();
    let collection_constructor_ref = &collection::create_unlimited_collection(
        creator,
        string::utf8(b"My Collection Description"),
        string::utf8(b"My Collection"),
        royalty,
        string::utf8(b"https://mycollection.com"),
    );
    let mutator_ref = collection::get_mutator_ref(collection_constructor_ref);
    // Store the mutator ref somewhere safe
}
```

<Aside type="caution">
  Refs **must** be generated at creation time of an Object. The `ConstructorRef` used to generate other `Ref`s expires as soon as the transaction to create the Object is finished.
</Aside>

You can further customize your `Collection` by adding more resources or functionalities via smart contract. For example, a `Collection` can track when it was created in order to limit when `Token`s can be minted like so:

```move filename="example.move"
use std::option::{Self, Option};
use aptos_framework::string;

struct MyCollectionMetadata has key {
    creation_timestamp_secs: u64,
}

public entry fun create_collection(creator: &signer) {
    let royalty = option::none();
    // Constructor ref is a non-storable struct returned when creating a new object.
    // It can generate an object signer to add resources to the collection object.
    let collection_constructor_ref = &collection::create_unlimited_collection(
creator,
        string::utf8(b"My Collection Description"),
        string::utf8(b"My Collection"),
        royalty,
        string::utf8(b"https://mycollection.com"),
    );
    // Constructor ref can be exchanged for signer to add resources to the collection object.
    let collection_signer = &object::generate_signer(collection_constructor_ref);
    move_to(collection_signer, MyCollectionMetadata { creation_timestamp_secs: timestamp::now_seconds() } })
}
```

## Tokens

| **Field**       | **Description**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Description** | An optional string smaller than 2048 characters (modifiable with a `MutatorRef`).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **Name**        | A required string to identify the `Token` that is unique within each `Collection`. This means a single `Collection` account cannot have more than one `Token` with the same name.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **Royalty**     | An optional [`Royalty`](/move-reference/mainnet/aptos-token-objects/royalty#Royalty) struct indicating what % of the sale price goes to the creator of the `Collection`. This can be changed with a `MutatorRef` generated by the [Royalty module](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/royalty.move) (an extension for the DA standard. See example usage in [`aptos_token.move`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/aptos_token.move)). Usually royalty is set on collections, but setting it on `Token`s allows the individual `Token` to have a custom royalty amount. |
| **URI length**  | An optional string that is smaller than 512 characters which links to relevant content for the `Collection` (modifiable with a `MutatorRef`).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

### Creating Tokens

There are a few ways to create a `Token`:

1. Named tokens. These use the name of the `Token` to generate a named Object. This makes it easy to find the address for the token if you know the token and `Collection` name, but named Objects are not deletable. Trying to delete the a named token will only delete the data, not the Object itself.

```move filename="example.move"
use aptos_token_objects::token;
use std::option::{Self, Option};

public entry fun mint_token(creator: &signer) {
    let royalty = option::none();
    token::create_named_token(
        creator,
        "Collection Name",
        "Description",
        "Token Name",
        royalty,
        "https://mycollection.com/my-named-token.jpeg",
    );
}
```

<Aside type="note">
  You can derive the address for named tokens by:

  1. Concatenating the creator address, collection name and token name.
  2. Doing a sha256 hash of that new string.
</Aside>

2. ‚ÄúUnnamed‚Äù tokens. These create unnamed _Objects_ (which **are** deletable) but still have a `Token` name. Because the Object address is not deterministic, you must use an Indexer to find the address for them.

```move filename="example.move"
use aptos_token_objects::token;
use std::option::{Self, Option};
use aptos_framework::string;

public entry fun mint_token(creator: &signer) {
    let royalty = option::none();
    token::create(
        creator,
        string::utf8(b"Collection Name"),
        string::utf8(b"Description"),
        string::utf8(b"Token Name"),
        royalty,
        string::utf8(b"https://mycollection.com/my-named-token.jpeg"),
    );
}
```

### Finding Unnamed Token Addresses via Indexer

You can find the addresses of your recently created ‚Äúunnamed‚Äù `Token`s by using the [Aptos Indexer](/build/indexer/indexer-api) with queries like the following:

1. Looking up the collection id by using your account address and the name of the `Collection`.

<GraphQLEditor
  query={`query GetCollectionIdByName(
  $creatorAddress: String!
  $collectionName: String!
) {
  current_collections_v2(
    where: {
      creator_address: { _eq: $creatorAddress }
      collection_name: { _eq: $collectionName }
    }
  ) {
    collection_name
    collection_id
  }
}`}
  variables={`{
  "creatorAddress": "0x8726af08ea897c35c8137601ce1789992dacdd0eb0b724531a4e7dea035d950f",
  "collectionName": "Horse Emojis"
}`}
/>

2. Then look up the address (`token_data_id`) of the `Token` by using the `collection_id` (from above) and the name of the token:

<GraphQLEditor
  query={`query GetTokenID($collection_id: String!, $token_name: String!) {
  current_token_datas_v2(
    where: {
      collection_id: { _eq: $collection_id }
      token_name: { _eq: $token_name }
    }
  ) {
    token_name
    description
    token_data_id
  }
}`}
  variables={`{
  "collection_id": "0x158dc6481aec80004d0f21a8994757e3c8203fc37b0f508be2a5364ad99e649e",
  "token_name": "Horse Emojis #127"
}`}
/>

<Aside type="note">
  In general, using unnamed tokens give you the most flexibility because the Object can be deleted later, but named tokens simplify looking up addresses.
</Aside>

### Using Tokens

#### Transfer Tokens

Transferring a `Token` can be done by calling [`object::transfer`](/move-reference/mainnet/aptos-framework/object#transfer).

```move filename="example.move"
public entry fun transfer<T: key>(owner: &signer, object: object::Object<T>, to: address)
```

#### Burning Tokens

Burning / deleting a `Token` requires storing a `BurnRef` with `token::generate_burn_ref`, then calling `token::burn`.

```move filename="example.move"
module 0x42::example {
  use std::option;
  use aptos_token_objects::token::{Self, BurnRef, Token};
  use std::string::utf8;
  use aptos_framework::object::{Self, Object};

  struct CustomData has key, drop {
    burn_ref: BurnRef,
  }

  public entry fun mint_token(creator: &signer) {
    let token_constructor_ref = &token::create(
      creator,
      utf8(b"My Collection"),
      utf8(b"My named Token description"),
      utf8(b"My named token"),
      option::none(),
      utf8(b"https://mycollection.com/my-named-token.jpeg"),
    );

    let token_signer = &object::generate_signer(token_constructor_ref);

    let burn_ref = token::generate_burn_ref(token_constructor_ref);

    // Store the burn ref somewhere safe
    move_to(token_signer, CustomData {
      burn_ref,
    });
  }

  public entry fun burn_token(token: Object<Token>) acquires CustomData {
    let token_address = object::object_address(&token);
    // Remove all custom data from the token object.
    // Retrieve the burn ref from storage
    let CustomData { burn_ref } = move_from<CustomData>(token_address);
    // Burn the token
    token::burn(burn_ref);
  }
}
```

<Aside type="caution">
  If any custom resources were moved onto the Token, those must be removed / deleted first before`token::burn` can delete the Token. For named tokens which cannot be deleted, `token::burn` will For named Tokens `token::burn` will remove all Token content instead.
</Aside>

#### Modifying Tokens After Creation

Mutating a `Token`‚Äôs `URI` or `description` requires a `MutatorRef` (which must be generated when creating the `Token`, then stored for later).

```move filename="example.move"
module 0x42::example {
  use std::option;
  use aptos_token_objects::token::{Self, MutatorRef, Token};
  use std::string::utf8;
  use aptos_framework::object::{Self, Object};

  struct CustomData has key, drop {
    mutator_ref: MutatorRef,
  }

  public entry fun mint_token(creator: &signer) {
    // Constructor ref is a non-storable struct returned when creating a new object.
    // It can be exchanged for signer to add resources to the token object.
    let token_constructor_ref = &token::create(
      creator,
      utf8(b"My Collection"),
      utf8(b"My named Token description"),
      utf8(b"My named Token"),
      option::none(),
      utf8(b"https://mycollection.com/my-named-token.jpeg"),
    );

    let token_signer = &object::generate_signer(token_constructor_ref);

    let mutator_ref = token::generate_mutator_ref(token_constructor_ref);

    // Store the mutator ref somewhere safe
    move_to(token_signer, CustomData {
      mutator_ref,
    });
  }

  public entry fun mutate_token(token: Object<Token>) acquires CustomData {
    let token_address = object::object_address(&token);
    // Retrieve the mutator ref from storage
    let CustomData { mutator_ref } = move_from<CustomData>(token_address);
    // Change token description
    token::set_description(&mutator_ref, utf8(b"This is my named Token description"));
  }
}
```

<Aside type="caution">
  Changing the royalty requires generating a _separate_ `MutatorRef` from the [Royalty module](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/royalty.move).
</Aside>

#### Extending Tokens

`Token`s can be extended either by adding additional resources (since they are an Object) or using `Ref`s to modify the Object.

## Aptos Token

For NFT creators who want to avoid writing their own logic for how your NFT should work, you can use the [`aptos_token`](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/aptos_token.move) module to mint an NFT. This module is already deployed at `0x4` and allows you to:

1. Mint a `Token` you can transfer with royalties.
2. Mint a soulbound `Token`.
3. Manage the resources your NFT has.

See the `aptos_token` [reference docs](/move-reference/mainnet/aptos-token-objects/aptos_token) for all the helper functions you can use.

<Aside type="caution">
  The main drawback of using the `aptos_token` module is that the Tokens are not extensible (the `mint` function does not return a `ConstructorRef`).
</Aside>

### Minting with `aptos_token`

Minting a `Token` using `aptos_token` requires the same parameters as any token that implements the DA standard. In addition though, the `aptos_token` module allows you to specify a property map of key/value pairs for any other properties your specific NFT may require.

You can mint your `Token` by calling `aptos_token::mint` like so:

```move filename="example.move"
public entry fun mint(
    creator: &signer,
    collection: String,
    description: String,
    name: String,
    uri: String,
    property_keys: vector<String>,
    property_types: vector<String>,
    property_values: vector<vector<u8>>,
) acquires AptosCollection, AptosToken
```

#### Soulbound Tokens

To mint a soul bound `Token`, you can call [`aptos_token::mint_soul_bound`](/move-reference/mainnet/aptos-token-objects/aptos_token#mint_soul_bound) instead:

```move filename="example.move"
public entry fun mint_soul_bound(
    creator: &signer,
    collection: String,
    description: String,
    name: String,
    uri: String,
    property_keys: vector<String>,
    property_types: vector<String>,
    property_values: vector<vector<u8>>,
    soul_bound_to: address,
) acquires AptosCollection
```

<Aside type="caution">
  In the near future, a new module `TokenMinter` will be released to replace `aptos_token`. You can follow the status of that proposal [here](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-72.md).
</Aside>

## Examples and Useful Links

- [Digital Asset Examples](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/token_objects)
- [Digital Asset Marketplace Example](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/marketplace)
- [Source code](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/token.move)
- [`aptos_token` source code](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token-objects/sources/aptos_token.move)

# Aptos Error Codes

> Learn about error codes for Move smart contract development on Aptos blockchain.

This page catalogs common errors encountered in the Aptos blockchain and
explains how to resolve them wherever possible. As with all software, the code
itself is the source of truth for error handling and will always contain entries
not found here. Instead, this matrix aims to help you address those errors most
typically found, misunderstood, or both.

For the sources of these errors, see:

- [vm\_status.rs](https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/vm_status.rs)
- [error.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/move-stdlib/sources/error.move)
- [account.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/account/account.move)
- [coin.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/coin.move)
- [token.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/sources/token.move)
- [token\_transfers.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-token/sources/token_transfers.move)

Help us update this list by sending pull requests containing the errors you
encounter. If you don't know how to resolve the error, as described int the
_Action_ column, simply leave it blank.

## Frequent Errors

### INSUFFICIENT\_BALANCE\_FOR\_TRANSACTION\_FEE

This means that the highest possible gas used for the transaction is greater than
the balance of APT in the transaction sender's (or fee payer's) account.  To resolve,
please submit with a lower max gas amount, and try again.

For example, if the max gas amount is 1000 gas units, and the gas unit price is `100` octas, the total
APT required in the account would be `0.00100000` APT (`1000 * 100 / 100000000`).  The default is often `200000` gas units which
would end up requiring `0.20000000` APT.  If you are having issues with this, please
reach out to your wallet provider.

### OUT\_OF\_GAS

This means that the transaction used more gas than the sender specified as the max
gas amount for the transaction, and aborted as a result.  To resolve, please
try to increase the max gas amount, and submit the transaction again.

### SEQUENCE\_NUMBER\_TOO\_OLD

This means that the transaction's sequence number in the sender's account has already
been used and committed to the blockchain.  In order to submit a new transaction
to the blockchain, please try and submit it again with a new sequence number.

### SEQUENCE\_NUMBER\_TOO\_NEW

This only occurs in simulation, but means that the sequence number being submitted
is greater than the next sequence number for the account.  Please reduce the
sequence number and try again.

## Move Virtual Machine (VM)

{/* TODO improve formatting on table */}

| Error                                                           |                                                                                                                                                                                                                                                                            Meaning                                                                                                                                                                                                                                                                            | Possible Resolution                                                                                                                                   |
| --------------------------------------------------------------- | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| LOOKUP\_FAILED                                                  |                                                                                                                                                                                                                                            A function that is being called isn't present on the network being used                                                                                                                                                                                                                                            | Check that your dependencies on-chain have the same version                                                                                           |
| UNKNOWN\_VALIDATION\_STATUS                                     |                                                                                                                                                                                                                                                          We don't want the default value to be valid.                                                                                                                                                                                                                                                         | N/A                                                                                                                                                   |
| INVALID\_SIGNATURE                                              |                                                                                                                                                                                                                                                              The transaction has a bad signature.                                                                                                                                                                                                                                                             | Submit a new transaction with a new signature                                                                                                         |
| INVALID\_AUTH\_KEY                                              |                                                                                                                                                                                                                                                                Bad account authentication key.                                                                                                                                                                                                                                                                | Submit a new transaction with a new signature, check that the account matches the authentication key and hasn't been rotated                          |
| SEQUENCE\_NUMBER\_TOO\_OLD                                      |                                                                                                                                                                                                                                                                  Sequence number is too old.                                                                                                                                                                                                                                                                  | Submit a new transaction with a newer sequence number from the account                                                                                |
| SEQUENCE\_NUMBER\_TOO\_NEW                                      |                                                                                                                                                                                                                                                                  Sequence number is too new.                                                                                                                                                                                                                                                                  | Submit a new transaction with a new signature                                                                                                         |
| INSUFFICIENT\_BALANCE\_FOR\_TRANSACTION\_FEE                    |                                                                                                                                                                                                       Insufficient balance to pay for max\_gas specified in the transaction. Balance needs to be above max\_gas\_amount \* gas\_unit\_price to proceed.                                                                                                                                                                                                       | Fund the account with more APT to pay for the gas fee                                                                                                 |
| TRANSACTION\_EXPIRED                                            |                                                                                                                                                                                                                                                                  The transaction has expired.                                                                                                                                                                                                                                                                 | Submit a new transaction with an expiration time further in the future                                                                                |
| SENDING\_ACCOUNT\_DOES\_NOT\_EXIST                              |                                                                                                                                                                                                                                                              The sending account does not exist.                                                                                                                                                                                                                                                              | Create the account prior to sending the transaction again                                                                                             |
| REJECTED\_WRITE\_SET                                            |                                                                                                                                                                                                                                   This write set transaction was rejected because it did not meet the requirements for one.                                                                                                                                                                                                                                   | N/A                                                                                                                                                   |
| INVALID\_WRITE\_SET                                             |                                                                                                                                                                                                                                               This write set transaction cannot be applied to the current state.                                                                                                                                                                                                                                              | N/A                                                                                                                                                   |
| EXCEEDED\_MAX\_TRANSACTION\_SIZE                                |                                                                                                                                                                                                                                                Length of program field in raw transaction exceeded max length.                                                                                                                                                                                                                                                | The transaction is too large for a single transaction; if this is a package publish, try to break it into multiple packages                           |
| UNKNOWN\_SCRIPT                                                 |                                                                                                                                                                                                                                                        This script is not in our allowlist of scripts.                                                                                                                                                                                                                                                        | N/A                                                                                                                                                   |
| UNKNOWN\_MODULE                                                 |                                                                                                                                                                                                                                                         Transaction is trying to publish a new module.                                                                                                                                                                                                                                                        | N/A                                                                                                                                                   |
| MAX\_GAS\_UNITS\_EXCEEDS\_MAX\_GAS\_UNITS\_BOUND                |                                                                                                                                                                                                                                          Max gas units submitted with transaction exceeds max gas units bound in VM.                                                                                                                                                                                                                                          | Decrease the max gas amount in the transaction below the maximum value in the gas schedule                                                            |
| MAX\_GAS\_UNITS\_BELOW\_MIN\_TRANSACTION\_GAS\_UNITS            |                                                                                                                                                                                                                              Max gas units submitted with transaction not enough to cover the intrinsic cost of the transaction.                                                                                                                                                                                                                              | Increase the max gas amount above the minimum value in the gas schedule                                                                               |
| GAS\_UNIT\_PRICE\_BELOW\_MIN\_BOUND                             |                                                                                                                                                                                                                                      Gas unit price submitted with transaction is below minimum gas price set in the VM.                                                                                                                                                                                                                                      | Increase the gas unit price below the minimum gas unit price in the gas schedule                                                                      |
| GAS\_UNIT\_PRICE\_ABOVE\_MAX\_BOUND                             |                                                                                                                                                                                                                                  Gas unit price submitted with the transaction is above the maximum gas price set in the VM.                                                                                                                                                                                                                                  | Decrease the gas unit price below the maximum gas unit price in the gas schedule                                                                      |
| INVALID\_GAS\_SPECIFIER                                         |                                                                                                                                                                                                                     Gas specifier submitted is either malformed (not a valid identifier), or does not refer to an accepted gas specifier.                                                                                                                                                                                                                     | N/A                                                                                                                                                   |
| SENDING\_ACCOUNT\_FROZEN                                        |                                                                                                                                                                                                                                                                 The sending account is frozen.                                                                                                                                                                                                                                                                | N/A                                                                                                                                                   |
| UNABLE\_TO\_DESERIALIZE\_ACCOUNT                                |                                                                                                                                                                                                                                                            Unable to deserialize the account blob.                                                                                                                                                                                                                                                            | N/A                                                                                                                                                   |
| CURRENCY\_INFO\_DOES\_NOT\_EXIST                                |                                                                                                                                                                                                                                                           The currency info was unable to be found.                                                                                                                                                                                                                                                           | N/A                                                                                                                                                   |
| INVALID\_MODULE\_PUBLISHER                                      |                                                                                                                                                                                                                                                The account sender doesn't have permissions to publish modules.                                                                                                                                                                                                                                                | N/A                                                                                                                                                   |
| NO\_ACCOUNT\_ROLE                                               |                                                                                                                                                                                                                                                                The sending account has no role.                                                                                                                                                                                                                                                               | N/A                                                                                                                                                   |
| BAD\_CHAIN\_ID                                                  |                                                                                                                                                                                                                                             The transaction's chain\_id does not match the one published on-chain.                                                                                                                                                                                                                                            | Verify that your chain ID matches the chain ID for your network                                                                                       |
| SEQUENCE\_NUMBER\_TOO\_BIG                                      |                                                                                                                                                                                                                                     The sequence number is too large and would overflow if the transaction were executed.                                                                                                                                                                                                                                     | N/A                                                                                                                                                   |
| BAD\_TRANSACTION\_FEE\_CURRENCY                                 |                                                                                                                                                                                                                                                The gas currency is not registered as a TransactionFee currency.                                                                                                                                                                                                                                               | N/A                                                                                                                                                   |
| FEATURE\_UNDER\_GATING                                          |                                                                                                                                                                                                                                    The feature requested is intended for a future Aptos version instead of the current one.                                                                                                                                                                                                                                   | N/A                                                                                                                                                   |
| SECONDARY\_KEYS\_ADDRESSES\_COUNT\_MISMATCH                     |                                                                                                                                                                                                                            The number of secondary signer addresses is different from the number of secondary public keys provided.                                                                                                                                                                                                                           | Verify the multi-agent or multi-ed25519 secondary signer addresses match the secondary public keys                                                    |
| SIGNERS\_CONTAIN\_DUPLICATES                                    |                                                                                                                                                                                                                                    There are duplicates among signers, including the sender and all the secondary signers.                                                                                                                                                                                                                                    | Remove any duplicate signers                                                                                                                          |
| SEQUENCE\_NONCE\_INVALID                                        |                                                                                                                                                                                                                                     The sequence nonce in the transaction is invalid (too new, too old, or already used).                                                                                                                                                                                                                                     | N/A                                                                                                                                                   |
| CHAIN\_ACCOUNT\_INFO\_DOES\_NOT\_EXIST                          |                                                                                                                                                                                                                                             There was an error when accessing chain-specific account information.                                                                                                                                                                                                                                             | N/A                                                                                                                                                   |
| MODULE\_ADDRESS\_DOES\_NOT\_MATCH\_SENDER                       |                                                                                                                                                                                                                                         the module publisher is not the account that will eventually hold the module.                                                                                                                                                                                                                                         | Confirm the module address in the move contract matches the sender of the transaction                                                                 |
| ZERO\_SIZED\_STRUCT                                             |                                                                                                                                                                                                                                                            Reported when a struct has zero fields.                                                                                                                                                                                                                                                            | N/A                                                                                                                                                   |
| DUPLICATE\_MODULE\_NAME                                         |                                                                                                                                                                                                                                       The sender is trying to publish two modules with the same name in one transaction.                                                                                                                                                                                                                                      | Confirm every module has a unique name                                                                                                                |
| BACKWARD\_INCOMPATIBLE\_MODULE\_UPDATE                          |                                                                                                                                                                                                                                         The sender is trying to publish a module that breaks the compatibility checks.                                                                                                                                                                                                                                        | Confirm your new modules being published don't break backwards compatibility                                                                          |
| CYCLIC\_MODULE\_DEPENDENCY                                      |                                                                                                                                                                                                                                     The updated module introduces a cyclic dependency (i.e., A uses B and B also uses A).                                                                                                                                                                                                                                     | Check for loops in your module dependencies in the modules being published                                                                            |
| INVALID\_FRIEND\_DECL\_WITH\_SELF                               |                                                                                                                                                                                                                                                           Cannot mark the module itself as a friend.                                                                                                                                                                                                                                                          | Confirm no module has itself marked as a friend in the modules being published                                                                        |
| INVALID\_FRIEND\_DECL\_WITH\_MODULES\_OUTSIDE\_ACCOUNT\_ADDRESS |                                                                                                                                                                                                                                                 Cannot declare modules outside of account address as friends.                                                                                                                                                                                                                                                 | Confirm all friends are in the same account address in the modules being published                                                                    |
| INVALID\_FRIEND\_DECL\_WITH\_MODULES\_IN\_DEPENDENCIES          |                                                                                                                                                                                                                                                 Cannot declare modules that this module depends on as friends.                                                                                                                                                                                                                                                | Check friend declarations of the modules being published                                                                                              |
| CYCLIC\_MODULE\_FRIENDSHIP                                      |                                                                                                                                                                                                                                  The updated module introduces a cyclic friendship (i.e., A friends B and B also friends A).                                                                                                                                                                                                                                  | Check friend declarations of the modules being published                                                                                              |
| INVALID\_PHANTOM\_TYPE\_PARAM\_POSITION                         |                                                                                                                                                                                                                                                  A phantom type parameter was used in a non-phantom position.                                                                                                                                                                                                                                                 | Confirm phantom types are used only with generics                                                                                                     |
| LOOP\_MAX\_DEPTH\_REACHED                                       |                                                                                                                                                                                                                                                                  Loops are too deeply nested.                                                                                                                                                                                                                                                                 | Check for many nested loops                                                                                                                           |
| TYPE\_RESOLUTION\_FAILURE                                       |                                                                                                                                                                                                                                             Failed to resolve type due to linking being broken after verification.                                                                                                                                                                                                                                            | N/A                                                                                                                                                   |
| RESOURCE\_DOES\_NOT\_EXIST                                      |                                                                                                                                                                                                                                              We tried to access a resource that does not exist under the account.                                                                                                                                                                                                                                             | Check the contract and possibly change it to handle resources that don't exist                                                                        |
| RESOURCE\_ALREADY\_EXISTS                                       |                                                                                                                                                                                                                                       We tried to create a resource under an account where that resource already exists.                                                                                                                                                                                                                                      | Check the contract and possibly change it to handle resources that already exist                                                                      |
| UNKNOWN\_STATUS                                                 |                                                                                                                                                                                                         A reserved status to represent an unknown vm status. This is std::u64::MAX, but we can't pattern match on that, so put the hardcoded value in.                                                                                                                                                                                                        | N/A                                                                                                                                                   |
| LINKER\_ERROR                                                   |                                                                                                                            This may be due to the function has not been published on chain or by trying to call an invalid function as the result of either an incorrect account address, module name, or function name. This might not happen locally if the sources are available locally but have yet to be published on-chain.                                                                                                                            | There are many reasons, but you should check your account addresses, module names, and function names to determine that they're correct and published |
| FAILED\_TO\_DESERIALIZE\_ARGUMENT                               | This error in deserializing argument is triggered by one of the following validation checks. 1) It exceeds the limit on the number of nested or unpacked structs (including in a vector). The maximum overall args equals to depth \* number of args. The max depth is currently 10. 2) The nested struct exceeds the aforementioned max depth. 3) The serialized arguments to constructor contained extra data. 4) It was derializing utf8 but struct\_constructors are disabled. 5) The string argument is too long. 6) BCS deserialization fails for utf8. | N/A                                                                                                                                                   |

## Move Standard Library (stdlib)

| Error               |                                             Meaning                                             |
| ------------------- | :---------------------------------------------------------------------------------------------: |
| INVALID\_ARGUMENT   |                        Caller specified an invalid argument (HTTP: 400).                        |
| OUT\_OF\_RANGE      |                 An input or result of a computation is out of range (HTTP: 400).                |
| INVALID\_STATE      |          The system is not in a state where the operation can be performed (HTTP: 400).         |
| UNAUTHENTICATED     | Request not authenticated due to missing, invalid, or expired authentication token (HTTP: 401). |
| PERMISSION\_DENIED  |                   The client does not have sufficient permission (HTTP: 403).                   |
| NOT\_FOUND          |                          A specified resource is not found (HTTP: 404).                         |
| ABORTED             |              Concurrency conflict, such as read-modify-write conflict (HTTP: 409).              |
| ALREADY\_EXISTS     |              The resource that a client tried to create already exists (HTTP: 409).             |
| RESOURCE\_EXHAUSTED |                         Out of gas or other forms of quota (HTTP: 429).                         |
| CANCELLED           |                           Request cancelled by the client (HTTP: 499).                          |
| INTERNAL            |                                   Internal error (HTTP: 500).                                   |
| NOT\_IMPLEMENTED    |                               Feature not implemented (HTTP: 501).                              |
| UNAVAILABLE         | The service is currently unavailable. Indicates that a retry could solve the issue (HTTP: 503). |

## Aptos accounts

| Error                                    |                                                                Meaning                                                                | Possible Resolution                                                              |
| ---------------------------------------- | :-----------------------------------------------------------------------------------------------------------------------------------: | -------------------------------------------------------------------------------- |
| EACCOUNT\_ALREADY\_EXISTS                |                                                        Account already exists.                                                        | N/A                                                                              |
| EACCOUNT\_DOES\_NOT\_EXIST               |                                                        Account does not exist.                                                        | Create the account first                                                         |
| ESEQUENCE\_NUMBER\_TOO\_BIG              |                                          Sequence number exceeds the maximum value for a u64.                                         | Provide a smaller sequence number                                                |
| EMALFORMED\_AUTHENTICATION\_KEY          |                                         The provided authentication key has an invalid length.                                        | Check your authentication key; it should be a 32-byte vector                     |
| ECANNOT\_RESERVED\_ADDRESS               |                                           Cannot create account because address is reserved.                                          | N/A                                                                              |
| EOUT\_OF\_GAS                            |                                              Transaction exceeded its allocated max gas.                                              | Increase the max gas amount                                                      |
| EWRONG\_CURRENT\_PUBLIC\_KEY             |                                              Specified current public key is not correct.                                             | Confirm the public key matches the account                                       |
| EINVALID\_PROOF\_OF\_KNOWLEDGE           |                          Specified proof of knowledge required to prove ownership of a public key is invalid.                         | Check your proof of knowledge in key rotation to ensure it has proper signatures |
| ENO\_CAPABILITY                          |                          The caller does not have a digital-signature-based capability to call this function.                         | Confirm you have the capability for the called functions                         |
| EINVALID\_ACCEPT\_ROTATION\_CAPABILITY   |                           The caller does not have a valid rotation capability offer from the other account.                          | Confirm the account being rotated is correct                                     |
| ENO\_VALID\_FRAMEWORK\_RESERVED\_ADDRESS |                                 Address to create is not a valid reserved address for Aptos framework.                                | N/A                                                                              |
| EINVALID\_SCHEME                         | Specified scheme required to proceed with the smart contract operation - can only be ED25519\_SCHEME(0) OR MULTI\_ED25519\_SCHEME(1). | Confirm the transaction was signed correctly when creating the account           |
| EINVALID\_ORIGINATING\_ADDRESS           |             Abort the transaction if the expected originating address is different from the originating address on-chain.             | Confirm you are rotating the correct account's key                               |
| ENO\_SUCH\_SIGNER\_CAPABILITY            |                                       The signer capability doesn't exist at the given address.                                       | Confirm the address is correct                                                   |

## Aptos coins

| Error                                  |                                                 Meaning                                                | Possible Resolution                                                       |
| -------------------------------------- | :----------------------------------------------------------------------------------------------------: | ------------------------------------------------------------------------- |
| ECOIN\_INFO\_ADDRESS\_MISMATCH         | Address of account which is used to initialize a coin `CoinType` doesn't match the deployer of module. | Create the coin using a `CoinType` in the same account creating the coin. |
| ECOIN\_INFO\_ALREADY\_PUBLISHED        |                              `CoinType` is already initialized as a coin.                              | N/A                                                                       |
| ECOIN\_INFO\_NOT\_PUBLISHED            |                              `CoinType` hasn't been initialized as a coin.                             | Create the coin with `CoinType` first before using it                     |
| ECOIN\_STORE\_ALREADY\_PUBLISHED       |                       Account already has `CoinStore` registered for `CoinType`.                       | N/A                                                                       |
| ECOIN\_STORE\_NOT\_PUBLISHED           |                          Account hasn't registered `CoinStore` for `CoinType`.                         | Register the account for the `CoinType`                                   |
| EINSUFFICIENT\_BALANCE                 |                                Not enough coins to complete transaction.                               | Transfer less coins, or acquire more coins prior to the transfer          |
| EDESTRUCTION\_OF\_NONZERO\_TOKEN       |                                     Cannot destroy non-zero coins.                                     | N/A                                                                       |
| EZERO\_COIN\_AMOUNT                    |                                       Coin amount cannot be zero.                                      | Don't burn coins or conduct other actions with zero coins                 |
| EFROZEN                                |                      CoinStore is frozen. Coins cannot be deposited or withdrawn.                      | Account is frozen for this token; talk to the coin owner                  |
| ECOIN\_SUPPLY\_UPGRADE\_NOT\_SUPPORTED |                  Cannot upgrade the total supply of coins to different implementation.                 | N/A                                                                       |
| ECOIN\_NAME\_TOO\_LONG                 |                                      Name of the coin is too long.                                     | Coin name must be less than or equal to 32 characters                     |
| ECOIN\_SYMBOL\_TOO\_LONG               |                                     Symbol of the coin is too long.                                    | Coin symbol must be less than or equal to 10 characters                   |

## Aptos tokens

| Error                                              |                             Meaning                            |
| -------------------------------------------------- | :------------------------------------------------------------: |
| EALREADY\_HAS\_BALANCE                             |        The token has balance and cannot be initialized.        |
| ECOLLECTIONS\_NOT\_PUBLISHED                       |         There isn't any collection under this account.         |
| ECOLLECTION\_NOT\_PUBLISHED                        |          Cannot find collection in creator's account.          |
| ECOLLECTION\_ALREADY\_EXISTS                       |                 The collection already exists.                 |
| ECREATE\_WOULD\_EXCEED\_COLLECTION\_MAXIMUM        |     Exceeds the collection's maximal number of token\_data.    |
| EINSUFFICIENT\_BALANCE                             |                   Insufficient token balance.                  |
| EINVALID\_TOKEN\_MERGE                             |      Cannot merge the two tokens with different token IDs.     |
| EMINT\_WOULD\_EXCEED\_TOKEN\_MAXIMUM               |             Exceed the token data maximal allowed.             |
| ENO\_BURN\_CAPABILITY                              |                       No burn capability.                      |
| ETOKEN\_DATA\_ALREADY\_EXISTS                      |                    TokenData already exists.                   |
| ETOKEN\_DATA\_NOT\_PUBLISHED                       |                    TokenData not published.                    |
| ETOKEN\_STORE\_NOT\_PUBLISHED                      |                    TokenStore doesn't exist.                   |
| ETOKEN\_SPLIT\_AMOUNT\_LARGER\_THAN\_TOKEN\_AMOUNT |     Cannot split token to an amount larger than its amount.    |
| EFIELD\_NOT\_MUTABLE                               |                    The field is not mutable.                   |
| ENO\_MUTATE\_CAPABILITY                            |                    Not authorized to mutate.                   |
| ENO\_TOKEN\_IN\_TOKEN\_STORE                       |                  Token not in the token store.                 |
| EUSER\_NOT\_OPT\_IN\_DIRECT\_TRANSFER              |               User didn't opt-in direct transfer.              |
| EWITHDRAW\_ZERO                                    |                    Cannot withdraw 0 token.                    |
| ENFT\_NOT\_SPLITABLE                               |          Cannot split a token that only has 1 amount.          |
| ENO\_MINT\_CAPABILITY                              |                       No mint capability                       |
| ECOLLECTION\_NAME\_TOO\_LONG                       |                The collection name is too long.                |
| ENFT\_NAME\_TOO\_LONG                              |                    The NFT name is too long.                   |
| EURI\_TOO\_LONG                                    |                      The URI is too long.                      |
| ENO\_DEPOSIT\_TOKEN\_WITH\_ZERO\_AMOUNT            |              Cannot deposit a token with 0 amount.             |
| ENO\_BURN\_TOKEN\_WITH\_ZERO\_AMOUNT               |                      Cannot burn 0 token.                      |
| EWITHDRAW\_PROOF\_EXPIRES                          |                     Withdraw proof expires.                    |
| EOWNER\_CANNOT\_BURN\_TOKEN                        |                 Token is not burnable by owner.                |
| ECREATOR\_CANNOT\_BURN\_TOKEN                      |                Token is not burnable by creator.               |
| ECANNOT\_UPDATE\_RESERVED\_PROPERTY                | Reserved fields for token contract. Cannot be updated by user. |
| EURI\_TOO\_SHORT                                   |                         URI too short.                         |
| ETOKEN\_OFFER\_NOT\_EXIST                          |                   Token offer doesn't exist.                   |

# Aptos Fungible Asset (FA) Standard

> Learn about the Aptos Fungible Asset standard for creating and managing fungible tokens on Aptos blockchain with enhanced security and functionality.

import { ThemedImage } from '~/components/ThemedImage';

import { Aside } from '@astrojs/starlight/components';

The Aptos Fungible Asset Standard (also known as ‚ÄúFungible Asset‚Äù or ‚ÄúFA‚Äù) provides a standard, type-safe way to define fungible assets in the Move ecosystem. It is a modern replacement for the `coin` module that allows for seamless minting, transfer, and customization of fungible assets for any use case.

This standard is important because it allows fungible assets on Aptos (such as Currencies and Real World Assets (RWAs)) to represent and transfer ownership in a consistent way dApps can recognize. This standard also allows for more extensive customization than the `coin` module did by leveraging [Move Objects](/build/smart-contracts/objects) to represent fungible asset data.

The FA standard provides all the functionality you need to create, mint, transfer, and burn fungible assets (as well as automatically allowing recipients of the fungible asset to store and manage any fungible assets they receive).

It does so by using two Move Objects:

1. `Object<Metadata>` - This represents details about the fungible asset itself, including information such as the `name`, `symbol`, and `decimals`.
2. `Object<FungibleStore>` - This stores a count of fungible asset units owned by this account. Fungible assets are interchangeable with any other fungible asset that has the same metadata. An account _may_ own more than one `FungibleStore` for a single Fungible Asset, but that is only for advanced use cases.

The diagram below shows the relationship between these Objects. The `Metadata` Object is owned by the Fungible Asset creator, then referenced in FA holders' `FungibleStore`s to indicate which FA is being tracked:

<ThemedImage
  alt="FA Object Relationship"
  sources={{
light: '~/images/fa-diagram-light.png',
dark: '~/images/fa-diagram-dark.png',
}}
/>

[This implementation](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/fungible_asset.move) is an improvement on the `coin` Standard because Move Objects are more customizable and extensible via smart contract. See the advanced guides on writing [Move Objects](/build/smart-contracts/objects) for more details.
The FA standard also automatically handles tracking how much of a fungible asset an account owns, as opposed to requiring the recipient to register a `CoinStore` resource separate from the transfer.

## Creating a new Fungible Asset (FA)

At a high level, this is done by:

1. Creating a non-deletable Object to own the newly created Fungible Asset `Metadata`.
2. Generating `Ref`s to enable any desired permissions.
3. Minting Fungible Assets and transferring them to any account you want to.

To start with, the Fungible Asset standard is implemented using Move Objects. Objects by default are transferable, can own multiple resources, and can be customized via smart contract. For full details on Objects and how they work, please read [this guide](/build/smart-contracts/objects).

To create an FA, first you need to create a **non-deletable Object** since destroying the metadata for a Fungible Asset while there are active balances would not make sense. You can do that by either calling `object::create_named_object(caller_address, NAME)` or `object::create_sticky_object(caller_address)` to create the Object on-chain.

When you call these functions, they will return a `ConstructorRef`. `Ref`s allow Objects to be customized immediately after they are created. You can use the `ConstructorRef` to generate other permissions that may be needed based on your use case.

<Aside type="note">
  Note that the `ConstructorRef` cannot be stored and is destroyed by the end of the transaction used to create this Object, so any `Ref`s must be generated during Object creation.
</Aside>

One use for the `ConstructorRef` is to generate the FA `Metadata` Object. The standard provides a generator function called `primary_fungible_store::create_primary_store_enabled_fungible_asset` which will allow your fungible asset to be transferred to any account. This method makes it so the primary `FungibleStore` for recipients is automatically created or re-used so you don't need to create or index the store directly.

This is what `create_primary_store_enabled_fungible_asset` looks like:

```move filename="example.move"
public fun create_primary_store_enabled_fungible_asset(
    constructor_ref: &ConstructorRef,
    // This ensures total supply does not surpass this limit - however,
    // Setting this will prevent any parallel execution of mint and burn.
    maximum_supply: Option<u128>,
    // The fields below here are purely metadata and have no impact on-chain.
    name: String,
    symbol: String,
    decimals: u8,
    icon_uri: String,
    project_uri: String,
)
```

<Aside type="note">
  Alternatively, you can use `add_fungibility` which uses the same parameters, but requires recipients to keep track of their `FungibleStore` addresses to keep track of how many units of your FA they have.
</Aside>

Once you have created the Metadata, you can also use the `ConstructorRef` to generate additional `Ref`s. In addition to the usual [Object Refs](/build/smart-contracts/object/creating-objects), FAs define three additional permissions you can generate:

1. `MintRef` offers the capability to mint new FA units.
2. `TransferRef` offers the capability to freeze accounts from transferring this FA, or to bypass an existing freeze. (This can be important when trying to be compliant with some regulations).
3. `BurnRef` offers the capability to burn or delete FA units.

<Aside type="caution">
  Note: All `Ref`s must be generated when the Object is created as that is the only time you can generate an Object's `ConstructorRef`.
</Aside>

To generate an Object with all FA permissions, you could deploy a contract like this:

```move filename="example.move"
module my_addr::my_fungible_asset_example {
    use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, Metadata, FungibleAsset};
    use aptos_framework::object::{Self, Object};
    use aptos_framework::primary_fungible_store;
    use std::error;
    use std::signer;
    use std::string::utf8;
    use std::option;

  const ASSET_SYMBOL: vector<u8> = b"FA";

	// Make sure the `signer` you pass in is an address you own.
	// Otherwise you will lose access to the Fungible Asset after creation.
  entry fun initialize(admin: &signer) {
    // Creates a non-deletable object with a named address based on our ASSET_SYMBOL
    let constructor_ref = &object::create_named_object(admin, ASSET_SYMBOL);

    // Create the FA's Metadata with your name, symbol, icon, etc.
    primary_fungible_store::create_primary_store_enabled_fungible_asset(
        constructor_ref,
        option::none(),
        utf8(b"FA Coin"), /* name */
        utf8(ASSET_SYMBOL), /* symbol */
        8, /* decimals */
        utf8(b"http://example.com/favicon.ico"), /* icon */
        utf8(b"http://example.com"), /* project */
    );

    // Generate the MintRef for this object
    // Used by fungible_asset::mint() and fungible_asset::mint_to()
    let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);

    // Generate the TransferRef for this object
    // Used by fungible_asset::set_frozen_flag(), fungible_asset::withdraw_with_ref(),
    // fungible_asset::deposit_with_ref(), and fungible_asset::transfer_with_ref().
    let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);

    // Generate the BurnRef for this object
    // Used by fungible_asset::burn() and fungible_asset::burn_from()
    let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);

    // Add any other logic required for your use case.
    // ...
  }
}
```

<Aside type="note">
  For a full example of how to create your own Fungible Asset module, please see [fa\_coin.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/move-examples/fungible_asset/fa_coin/sources/FACoin.move).
  Alternatively, you can explore the collection of [FA example code here](https://github.com/aptos-labs/aptos-core/tree/main/aptos-move/move-examples/fungible_asset).
</Aside>

Now you can use the `MintRef` to mint via:

```move filename="example.move"
public fun mint(ref: &MintRef, amount:u64): FungibleAsset
```

Or burn FA units using the `BurnRef` like so:

```move filename="example.move"
public fun burn(ref: &BurnRef, fa: FungibleAsset)
```

At this point, you can mint, transfer, and burn Fungible Assets using the `Ref`s you generated. See the above example Move scripts for how to implement those entry functions.

## Reference Docs

You can find the complete set of functions that the Fungible Asset Standard provides [here](/move-reference/mainnet/aptos-framework/fungible_asset). {/* TODO: Update the Move Reference link once we migrate that page */}

The basic features owners of Fungible Assets can use include the following.

### Withdraw

An owner can withdraw FA from their primary store by calling:

```move filename="withdraw"
public fun primary_fungible_store::withdraw<T: key>(owner: &signer, metadata: Object<T>, amount:u64): FungibleAsset
```

This function will emit a `WithdrawEvent`.

### Deposit

An owner can deposit FA to their primary store by calling:

```move filename="deposit"
public fun primary_fungible_store::deposit(owner: address, fa: FungibleAsset)
```

This function will emit a `DepositEvent`.

### Transfer

An owner can deposit FA from their primary store to that of another account by calling:

```move filename="transfer"
public entry fun primary_fungible_store::transfer<T: key>(sender: &signer, metadata: Object<T>, recipient: address, amount:u64)
```

This will emit both `WithdrawEvent` and `DepositEvent` on the respective `FungibleStore`s.

### Check Balance

To check the balance of a primary store, call:

```move filename="check_balances"
public fun primary_fungible_store::balance<T: key>(account: address, metadata: Object<T>): u64
```

### Check Frozen Status

To check whether the given account's primary store is frozen, call:

```move filename="is_frozen"
public primary_fungible_store::fun is_frozen<T: key>(account: address, metadata: Object<T>): bool
```

### Events

FAs have three events emitted from the above basic functions:

1. `Deposit`: Emitted when FAs are deposited into a store.

```move filename="deposit_event"
struct Deposit has drop, store {
    store: address,
    amount: u64,
}
```

2. `Withdraw`: Emitted when FAs are withdrawn from a store.

```move filename="withdraw_event"
struct Withdraw has drop, store {
    store: address,
    amount: u64,
}
```

3. `Frozen`: Emitted when the frozen status of a fungible store is updated.

```move filename="frozen_event"
struct Frozen has drop, store {
    store: address,
    frozen: bool,
}
```

## Dispatchable Fungible Asset (Advanced)

Aside from the default managed fungible asset functionality provided by the Aptos Framework, fungible asset issuers can implement their own deposit/withdraw logic using the dispatchable fungible asset standard. This is done by registering custom hook functions to be invoked at withdrawal/deposit time. These hook functions are stored in the metadata of a fungible asset class, and the Aptos Framework will automatically invoke them instead of the default logic. This allows issuers to implement complex logic, such as customized access control. For more details, refer to the corresponding [AIP](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-73.md).

### Implementing the Hook Function

To implement a custom hook function, build a module with functions that have the following signature:

```move filename="example.move"
module my_addr::my_fungible_asset_example {
    // ...
    public fun withdraw<T: key>(
        store: Object<T>,
        amount: u64,
        transfer_ref: &TransferRef,
    ): FungibleAsset {
        // Your custom logic here
    }

    public fun deposit<T: key>(
        store: Object<T>,
        fa: FungibleAsset,
        transfer_ref: &TransferRef,
    ) {
        // Your custom logic here
    }
    // ...
}
```

### Limitations

- **Reentrancy Prevention**: Only call `with_ref` APIs in your custom hooks for deposit/withdraw operations.
  - Use `fungible_asset::deposit_with_ref` instead of `fungible_asset::deposit`.
  - Use `fungible_asset::withdraw_with_ref` instead of `fungible_asset::withdraw`.
- Avoid calling functions defined in `dispatchable_fungible_asset` and `primary_fungible_store`, _except_ for inline functions, to prevent errors during transfers.
- Note that calling `fungible_asset::withdraw` and `fungible_asset::deposit` will NOT work for assets with registered hooks. See more information in Interacting with dispatchable fungible asset.

For more details on these limitations, refer to the [AIP](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-73.md).

### Registering the Hook Function

Once the functions are implemented, use the API defined in `dispatchable_fungible_asset::register_dispatch_functions` to bind the functions with your fungible asset.

```move filename="register_dispatch"
module 0x1::dispatchable_fungible_asset {
    public fun register_dispatch_functions(
        constructor_ref: &ConstructorRef,
        withdraw_function: Option<FunctionInfo>,
        deposit_function: Option<FunctionInfo>,
        derived_balance_function: Option<FunctionInfo>,
    )
}
```

<Aside type="note">
  The `register_dispatch_functions` function takes `Option<FunctionInfo>` as input to specify whether to use custom or default logic for withdraw/deposit/balance operations. If `option::none()` is passed, the default logic is used.
  A `FunctionInfo` identifies the function to be used as a custom hook.
  The `constructor_ref` is a reference for the metadata object of your fungible asset.
</Aside>

To construct a `FunctionInfo`, use either of:

```move filename="new_function_info"
module 0x1::function_info {
    public fun new_function_info(module_signer: &signer, module_name: String, function_name: String): FunctionInfo
    // or if you do not have the signer:
    public fun new_function_info_from_address(module_address: address, module_name: String, function_name: String): FunctionInfo
}
```

The registration can look like this:

```move filename="example.move"
module my_addr::my_fungible_asset_example {
    use aptos_framework::string;
    use aptos_framework::object;
    use aptos_framework::primary_fungible_store;
    use aptos_framework::dispatchable_fungible_asset;
    use aptos_framework::function_info;

    fun create_fungible_asset(module_signer: &signer, /* ... */) {
        // Make the deposit override function info
        let deposit_override = function_info::new_function_info(
            module_signer,
            string::utf8(b"my_fungible_asset_example"),
            string::utf8("deposit")
        );

        // Create the fungible asset
        let constructor_ref = object::create_sticky_object( /* ... */);

        primary_fungible_store::create_primary_store_enabled_fungible_asset(&constructor_ref, ...);
        // or below if not having primary stores
        // fungible_asset::add_fungibility(&constructor_ref, /* ... */);

        // Override default functionality for deposit
        dispatchable_fungible_asset::register_dispatch_functions(
            &constructor_ref,
            option::none(),
            option::some(deposit_override),
            option::none()
        );

        // ...
    }

    // ...
}
```

### Interacting with dispatchable fungible asset

For users using `primary_fungible_store` to manage assets, no changes are required to interact with assets with dispatchable hooks. The Aptos Framework automatically invokes the dispatch logic if a hook is set up.

For users using secondary `FungibleStore` to interact with assets, use `dispatchable_fungible_asset::withdraw/deposit` instead of `fungible_asset::withdraw/deposit` to handle assets with registered hooks.

The `dispatchable_fungible_asset::withdraw/deposit` functions are replacements, and also work with functions that do not have hooks registered.

## Managing Stores (Advanced)

Behind the scenes, the Fungible Asset Standard needs to manage how the asset balances are stored on each account. In the vast majority of circumstances, users will store all FA balances in their Primary `FungibleStore`. Sometimes though, additional ‚ÄúSecondary Stores‚Äù can be created for advanced DeFi applications.

- Each account owns only one non-deletable primary store for each type of FA, the address of which is derived in a deterministic manner from the account address and metadata object address. If primary store does not exist, it will be created if FA is going to be deposited by calling functions defined in `primary_fungible_store.move`
- Secondary stores do not have deterministic addresses and are deletable when empty. Users are able to create as many secondary stores as they want using the provided functions but there is a caveat that addressing secondary stores on-chain may be more complex.

You can look up a primary store via the following function:

```move filename="primary_store"
public fun primary_store<T: key>(owner: address, metadata: Object<T>): Object<FungibleStore>
```

And if you want to create a primary store manually you can use this function:

```move filename="create_primary_store"
public fun create_primary_store<T: key>(owner_addr: address, metadata: Object<T>): Object<FungibleStore>
```

The primary reason to use a secondary store is for assets managed by a smart contract. For example, an asset pool may have to manage multiple fungible stores for one or more types of FA.

To create a secondary store, you must:

1. Create an Object to get its `ConstructorRef`.
2. Call:

```move filename="create_store"
public fun create_store<T: key>(constructor_ref: &ConstructorRef, metadata: Object<T>): Object<FungibleStore>
```

This will create a secondary store owned by the newly created Object. Sometimes an object can be reused as a store. For example, a metadata object can also be a store to hold some FA of its own type or a liquidity pool object can be a store of the issued liquidity pool's coin.

It is crucial to set the correct owner of a `FungibleStore` object for managing the FA stored inside. By default, the owner of a newly created object is the creator whose `signer` is passed into the creation function. For `FungibleStore` objects managed by smart contract itself, the owner should usually be an Object address controlled by the contract. For those cases, those objects should keep their `ExtendRef` at the proper place to create `signer` as needed to modify the `FungibleStore` via contract logic.

## Migration from `Coin` to the Fungible Asset Standard

### Smart Contract Migration

**Projects utilizing the `coin` module do not need to modify their contracts.** The `coin` module has been enhanced to handle migration automatically. Whenever a paired FA is required for a `coin`, it will be automatically created if it doesn't already exist. The mapping between coins and FAs is immutable and stored in an on-chain table:

```move filename="coin_conversion"
struct CoinConversionMap has key {
    coin_to_fungible_asset_map: Table<TypeInfo, address>,
}
```

A `#[view]` function is available to retrieve metadata for the paired FA if it exists:

```move filename="paired_metadata"
#[view]
public fun paired_metadata<CoinType>(): Option<Object<Metadata>>
```

Similarly, a function exists for reverse lookup:

```move filename="paired_coin"
#[view]
public fun paired_coin(metadata: Object<Metadata>): Option<TypeInfo>
```

### Off-chain Migration

There are two changes needed for off-chain services:

1. Balances should reflect that a user may have **both** a `coin` balance and a paired FA balance.
2. Event listeners should listen for both `coin` and FA events.

Since a user may possess **both** a `coin` balance and a paired FA balance, off-chain applications should be updated to reflect the **sum** of both the `coin` balance and its paired FA balance.

- For Aptos Indexer users, you may utilize the table called `current_fungible_asset_balances` to obtain the latest sum of coin balance and FA balance representing the same asset type. If the FA has a paired coin type, the asset type would be set to the coin type, such as `0x1::aptos_coin::AptosCoin`. Otherwise, for FA not paired from a coin, the asset type would be the metadata address. Users could filter by this field to get the FA balance of their interest.
- For users employing Node API or other customized indexing, they should add the balance of the paired FA in users' `FungibleStore` and `ConcurrentFungibleBalance` if any of them exist to the coin balance.

To retrieve the balance of the `PrimaryFungibleStore` for a paired FA to an existing `coin` of type `CoinType`:

1. Call `paired_metadata<CoinType>()` to obtain the paired FA metadata object address (the address is immutable).
2. Retrieve the balance of the paired FA:
   - Call [getCurrentFungibleAssetBalances](https://github.com/aptos-labs/aptos-ts-sdk/blob/c01a26ff899235fac1c31c6cc3fe504b764e5b91/src/api/fungibleAsset.ts#L115).
   - Alternatively, determine the address of the primary `FungibleStore`, which can be deterministically calculated with the following formula:
     - `sha3_256(32-byte account address | 32-byte metadata object address | 0xFC)`
   - Then use that address to obtain the `FungibleStore` resource to fetch the balance.
     - If the balance is non-zero, this is the final balance of this FA.
     - Otherwise, try to get `ConcurrentFungibleBalance` resource at the same address and get the balance there instead.
     - If neither exist, the FA balance for this account is 0.

**Post-migration, both coin events and FA events could be emitted for an activity, depending on whether the user has migrated or not.** Dapps relying on events should update their business logic accordingly.

### Migration FAQs

<details>
  <summary><span className="font-bold">What is the Aptos Fungible Asset (FA) standard?</span></summary>

  <div className="p-8">
    The FA standard introduces a new way to represent fungible tokens as [Move objects](/build/smart-contracts/objects), replacing the legacy Coin resource model. Fungible Assets are more composable and developer-friendly compared to legacy Coins.

    APT will be migrated starting on June 30, 2025.
  </div>
</details>

<details>
  <summary><span className="font-bold">How exactly does the new FA standard differ from legacy Coins?</span></summary>

  <div className="p-8">
    With legacy Coins, each account directly holds a `CoinStore\<CoinType>` resource that tracks balances (in u64), includes flags like "frozen," and emits basic events on deposits or withdrawals. Transfers, mints, and burns are performed via `0x1::coin` module functions.

    Under the FA Standard, token balances are held in FungibleStore objects (instead of each account directly holding a CoinStore resource). Each asset has metadata that defines its properties (name, symbol, etc.). For any account that owns that token, the balance lives in a FungibleStore object belonging to that account and linked to the Metadata object.

    The primary way an account holds a fungible asset is via a primary fungible store; the address of this object is deterministically derived from the user's account address and the token's metadata address.

    FAs come in two flavors:

    1. **Vanilla FA**: Tokens that primarily manage simple balance updates.

    2. **Dispatchable FA (DFA)**: Tokens that embed custom Move logic automatically executed upon transfers.
  </div>
</details>

<details>
  <summary><span className="font-bold">How will this migration impact me?</span></summary>

  <div className="p-8">
    As an end user, you don't need to do anything. Your tokens remain safe, exactly where they should be in their new form. The migration does not affect ownership or usability in any way.

    If you're a developer, your existing smart contract code remains functional, but you should immediately start using the FA SDK for all new work. Existing coin API calls will continue working by silently routing to FA. After the migration, the coin module will be kept as it is, with minimal maintenance. Please note that you will no longer be able to look up coin balance by resource. Move to the `0x1::coin::balance` view function, or the balance REST API instead.
  </div>
</details>

<details>
  <summary><span className="font-bold">What is the migration timeline?</span></summary>

  <div className="p-8">
    All tokens on Aptos will begin migrating automatically from Coin v1 to the FA standard.
    All the coins except APT will be migrated from June 23 to 30. APT will transition from June 30 to July 8, 2025.
    The process involves continuously running batched transactions until every valid CoinStore has been fully converted into the new FungibleStore.
  </div>
</details>

<details>
  <summary><span className="font-bold">Why is the upgrade to the Fungible Asset standard necessary?</span></summary>

  <div className="p-8">
    Short answer: It unlocks powerful functionalities that the legacy Coin module simply cannot support.

    Modern DeFi and RWA apps increasingly demand sophisticated features like automated yield claims, custom fee structures, and built-in compliance checks. These are difficult to implement on legacy Coins. Attempting to bolt these capabilities onto the old standard rapidly creates composability issues, integration headaches and rising complexity.

    Beyond functionality, builders can also use a unified asset standard across all tokens, including stablecoins. Imagine designing a payment kiosk: if it accepts only digital payments, you avoid the complexity of cash slots, coin dispensers, and change mechanisms altogether. Similarly, adopting a single streamlined token standard reduces complexity in platform development. It improves developer productivity and delivers more consistent user experience.

    In short, the FA standard is clean and elegant. Developers can launch tokens that immediately integrate seamlessly across wallets, explorers, and DeFi applications from day one.
  </div>
</details>

<details>
  <summary><span className="font-bold">What are some new and unique functionalities I can build with Fungible Assets?</span></summary>

  <div className="p-8">
    Fungible Assets open the door to a range of advanced features that weren't possible with the legacy Coin model. Some notable capabilities include:

    - Tokens that automatically collect fees (like a percentage charge on transfers).

    - Interest-bearing tokens that accrue yield directly to the holders without manual claims.

    - Tokens with built-in vesting or time-locks that automatically release funds when certain conditions are met, a la escrow.

    - Tokens that dispense loyalty points on-chain when they're spent.

    - Tokens that can dynamically adjust supply; burning or minting based on usage patterns.

    The possibilities are endless.

    A great real-world example is xLPT from [Thala Labs](https://www.thalalabs.xyz/), which uses built-in DFA hooks to automate staking & unstaking LP tokens, updating positions and rewards automatically upon each transfer, without any user intervention.
  </div>
</details>

<details>
  <summary><span className="font-bold">We know there is always a paired FA of a coin type. How can we query the supply and balance of this asset after the migration?</span></summary>

  <div className="p-8">
    After the migration, querying resource `0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>` at account address will be unavailable. Instead, you can query the account balance by the following three ways:

    1. [Balance Node API](/build/apis/fullnode-rest-api#tag/accounts/GET/accounts/%7Baddress%7D/balance/%7Basset_type%7D), the asset\_type can be either coin\_type, such as 0x1::aptos\_coin::AptosCoin or FA metadata address such as 0xa, either way should return the same value.

    2. `#[view] function primary_fungible_store::balance<T: key>(account: address, metadata: Object<T>): u64`

    3. `#[view] function balance<CoinType>(owner: address): u64`. This method is deprecated and not applicable to pure FA tokens (e.g., USDt); it applies only to migrated coins such as APT. Due to its limitations and higher gas costs, it is not recommended.
  </div>
</details>

<details>
  <summary><span className="font-bold">Before migration, I could query all the assets a user has by getting all the resources at their address using API. How do I do it after migration?</span></summary>

  <div className="p-8">
    You can [use the Indexer API](/build/indexer/indexer-api/indexer-reference#current_fungible_asset_balances) to query all the fungible assets the user owns.

    Querying raw resources to get the asset balance and types is not recommended and will not be well-supported by fullnode API.
  </div>
</details>

<details>
  <summary><span className="font-bold">What if I have more questions?</span></summary>

  <div className="p-8">
    Join the [Aptos Discord](https://discord.com/invite/aptosnetwork)! Aptos Labs engineers will be available throughout migration week to answer questions and offer support.
  </div>
</details>

# Aptos Move Lint

> Learn about linter for Move smart contract development on Aptos blockchain.

The "Aptos Move Lint" tool runs on a Move package to find and warn about common issues in Move programs, helping improve your Move code.

You can run it with the aptos CLI command: `aptos move lint`.

If you find any issues, please submit [bugs and feedback](https://github.com/aptos-labs/aptos-core/issues/new?title=%5Blinter%5D%20%3CDescriptive%20Title%3E\&body=%3CDetailed%20description%20of%20the%20issue%20or%20feature%20request%3E\&labels=move-linter\&projects=aptos-labs/16). Also, we are tracking ideas and prioritization requests for new lint rules [here](https://github.com/aptos-labs/aptos-core/issues/15221), we welcome your contributions.

## Lint Checks

### `aborting_overflow_checks`

Checks for patterns that look like overflow checks done in a C style:

```move
// Overflow check
if (x > x + y) {
  abort 1;
};

// Underflow check
if (x < x - y) {
  abort 1;
};
```

This pattern in Move does not make sense, as it either aborts immediately or is always true/false.

### `almost_swapped`

Checks for expression patterns that look like a failed swap attempt and notifies the user. These patterns are likely erroneous code. This currently only detects simple access patterns such as assignments to a variable or a field of a struct. Examples include:

- `a = b; b = a;` which can be correctly swapped with `(a, b) = (b, a);`
- `a.x = b.x; b.x = a.x;` which can be correctly swapped with `(a.x, b.x) = (b.x, a.x);`

### `assert_const`

Checks for trivial assertions, i.e. `assert!(false)` and `assert!(true)`. The latter is equivalent to a no-op, so can be removed entirely, while the former can be replaced by an abort.

### `avoid_copy_on_identity_comparison`

Checks for identity comparisons (`==` or `!=`) between copied values of type `vector` or `struct` (i.e., types for which copy can be expensive). It instead suggests to use reference-based identity comparison instead (i.e., use `&x == &y` instead of `x == y`, when the above mentioned conditions meet).

[This recommendation](/build/smart-contracts/book/equality#avoid-extra-copies) is also given in the Move book. Due to automatic copy inference, it may not be obvious when a copy is being made while using `==` or `!=` on values with types that have the `copy` ability. This lint identifies cases where extra copies on vectors or structs could be skipped by using reference-based identity comparisons.

### `blocks_in_conditions`

Checks for use of blocks in conditions (e.g., in `if`, `match`, and `while` conditions), which can make code hard to read. An example coding pattern caught by this lint is:

```move
if ({let x = foo(); !x}) { // uses a block in condition
  bar();
}
```

Such code can usually be rewritten to hoist the block out and above the condition, usually making it more readable.

It is a common Move pattern to provide inline specifications in conditions, especially loop invariants, which requires creating blocks in conditions. We exclude this pattern in the lint check to continue to allow for this specification pattern.

Note that an `assert!` is translated to a conditional abort, so blocks in `assert!` condition also are reported by this lint.

### `empty_if`

Checks for `if` statements that have no body, which is likely a mistake. For example:

```move
if (x) {
}
```

### `equal_operands_in_bin_op`

Checks for binary operations where both operands are the same, which is likely a mistake. For example `x % x`, `x ^ x`,  `x > x`, `x >= x`, `x == x`, `x | x`, `x & x`, `x / x`, and `x != x` are all caught by this lint. The lint suggests replacing these with a more appropriate value or expression, such as `0`, `true`, or `false`.

This lint does not catch cases where the operands are vector access.

### `empty_range`

Checks for empty ranges in `for` loops, such as `for i in 0..0 { ... }`, which do not execute the loop body. This can happen when the start of the range is greater than or equal to the end of the range, resulting in an empty iteration.

### `find_unnecessary_casts`

Checks for unnecessary type casts where the source expression already has the same type as the target type. These casts are redundant and can be removed to improve code readability.

For example:

```move
let x: u64 = 42;
let y = x as u64; // unnecessary cast, x is already u64
```

The above can be simplified to:

```move
let x: u64 = 42;
let y = x; // cast removed
```

### `infinite_recursion`

Checks for functions or groups of functions that recurse infinitely. Note that the linter cannot detect _conditional_ infinite recursion, only inconditional, so a flag is a definite error in the program.

### `known_to_abort`

Checks for expressions that will always abort at runtime due to known constant values that violate runtime constraints. This lint helps identify code that will deterministically fail before it reaches production.

The following cases are detected:

- **Bit shifts with excessive shift amounts**: `x << n` or `x >> n` where `n` is a constant that is greater than or equal to the bit width of `x`'s type. For example, `value << 64` when `value` is of type `u64` will always abort.
- **Division or modulo by zero**: `x / 0` or `x % 0` operations will always abort at runtime.
- **Out-of-range type casting**: `constant as type` where the `constant` value is outside the representable range of the target `type`. For example, `300 as u8` will abort since `u8` can only represent values 0-255.

### `needless_bool`

Checks for patterns of the form (where `x` is any arbitrary boolean expression):

- `if (x) true else false`, which can be replaced with just `x`.
- `if (x) false else true`, which can be replaced with just `!x`.
- `if (x) { return true } else { return false }`, which can be replaced with just `return x`.
- `if (x) { return false } else { return true }`, which can be replaced with just `return !x`.
- `if (x) true else true` or `if (x) false else false`, which should be rewritten to remove the redundant branch.

### `needless_deref_ref`

Checks for patterns where references taken are immediately dereferenced, and suggests removing the pair of dereference-reference operators:

- `*&x.f` can be simplified to `x.f`
- `*&mut x.f` can be simplified to `x.f`
- `*&mut x.f = 5;` can be simplified to `x.f = 5;`

### `needless_loops`

Checks for loops that always exit on their first iteration, making the loop construct unnecessary. This lint detects loops that immediately return, abort, or break without performing any meaningful iteration.

The linter identifies these patterns:

- Loops where the first instruction is `return`, `abort`, or `break`
- Loops where the first instruction is a conditional branch where both paths immediately exit the loop

Examples of needless loops:

```move
// Always returns on first iteration
loop {
    return 42;
}

// Always aborts on first iteration
loop {
    abort 1;
}
```

These can be simplified by removing the loop construct entirely and using just the exit statement directly.

This lint uses conservative analysis to avoid false positives, only flagging cases where the exit behavior is immediately obvious from the loop's structure.

### `needless_mutable_reference`

Checks for mutable references or borrows (currently: mutable reference parameters, mutable borrow of locals, `borrow_global_mut`) that are not used mutably, and suggests to use the immutable reference or borrow instead.

For example, in the function `foo` below, `&mut` can be replaced by `&` because the reference is not mutably used.

```move
fun foo(x: u64): u64 {
  let y = &mut x;
  *y
}

```

### `needless_ref_deref`

Checks for patterns where immutable reference are taken for a dereference, and suggests removing the pair of reference-dereference operators: `&*x` can be simplified to `x`.

### `needless_ref_in_field_access`

Checks for patterns where there are needless references taken when accessing a field of a struct or an enum, and suggests removing the explicit reference taken:

- `(&s).f` can be simplified to `s.f`
- `(&mut s).f = 42;` can be simplified to `s.f = 42;`

### `needless_return`

Checks for unnecessary `return` statements in functions that can be simplified. This lint identifies cases where a `return` statement is used to return a value that can be directly returned without the `return` keyword.
For example, the following function:

```move
public fun foo(): bool {
  // ...
  return true;
}
```

This pattern can be simplified to:

```move
public fun foo(): bool {
  // ...
  true
}
```

### `nested_if`

Checks for nested if statements that can be simplified using the `&&` operator. This lint identifies patterns where an inner if statement with no else branch is contained within an outer if statement that also has no else branch.

```move
if (a) {
    if (b) {
        // some code
    }
}
```

This pattern can be simplified to:

```move
if (a && b) {
    // some code
}
```

The simplified version is more readable and avoids unnecessary nesting while maintaining the same logical behavior.

### `nonminimal_bool`

Check for boolean expressions that can be simplified when a boolean literal (either `true` or `false`) is part of a binary or unary boolean operator. Examples:

- `x && true` is logically equivalent to `x`
- `x || true` is logically equivalent to `true`
- `x => false` is logically equivalent to `!x`
- `x <==> true` is logically equivalent to `x`
- `! true` is logically equivalent to `false`

Does NOT consider side-effects/short-circuiting in the recommended simplifications. Example:

- `1/0 || true` is logically equivalent to `true`, but applying this simplification affects program semantics.

### `no_op`

Checks for statements that can be removed without changing program behavior. Examples:

- `42;`
- `*(&mut 0) = /*...*/;`
- `x << 4;`

Note that the linter does not take into account possible aborts due to arithmetic errors. If a statement is flagged it's almost definitely a programmer mistake, but you should evaluate the code in question to understand the intent. Sometimes the proper fix is to remove the statement, sometimes the statement should be changed.

### `random_modulo`

Checks for expressions of the form `u{8|16|32|64|128|256}_integer() % x`. Getting the remainder of a division where the dividend is a random number results in a non-uniform distribution, which could affect the fairness of a contract's behavior, depending on how the value is used. For example, the result of `u8_integer() % 255` is twice as likely to be 0 than 1. Instead of wrapping with modulo, `u{8|16|32|64|128|256}_range(0, x)` can be used, which produces a uniform distribution.

### `self_assignment`

Checks for patterns where a variable or a field of a struct is assigned to itself and suggests removing the assignment. These assignments do not affect the state of the program. Examples include:

- `let x = x;`
- `x = x;`
- `a.x = a.x;`

### `simpler_bool_expression`

Checks for boolean patterns that can be simplified through different boolean algebra laws. Examples include:

- Absorption law:
  - `a && b || a` can be simplified to `a`
  - `a || a && b` can be simplified to `a`
- Idempotence:
  - `a && a` can be simplified to `a`
  - `a || a` can be simplified to `a`
- Contradiction
  - `a && !a` can be simplified to `false`
  - `!a && a` can be simplified to `false`
- Tautology:
  - `a || !a` can be simplified to `true`
  - `!a || a` can be simplified to `true`
- Distributive law:
  - `(a && b) || (a && c)` can be simplified to `a && (b || c)`
  - `(a || b) && (a || c)` can be simplified to `a || (b && c)`

Where `a`, `b` and `c` can either be simple or composed expressions.

### `simpler_numeric_expression`

Checks for various patterns where a simpler numeric expression can be used instead. In all these cases, the code must already type check, and `x` can be any numeric expression.

- `x & 0`, `x * 0`, `0 & x`, `0 * x`, `0 << x`, `0 >> x`, `x % 1` can all be replaced with just `0`.
- `x | 0`, `x ^ 0`, `x >> 0`, `x << 0`, `x + 0`, `x - 0`, `x / 1`, `x * 1`, `0 | x`, `0 ^ x`, `0 + x`, `1 * x` can all be replaced with just `x`.

### `unnecessary_boolean_identity_comparison`

Checks for boolean identity comparisons of the form:

- `x == true`, `true == x`, which can be replaced with just `x`.
- `x == false`, `false == x`, which can be replaced with just `!x`.

In all these cases, `x` can be any arbitrary boolean expression.

### `unnecessary_numerical_extreme_comparison`

Checks if there are any numerical comparisons with extreme values (i.e., min and max value representable by that numeric type) that are unnecessary or can be made more precise and clear. Depending on the comparison, various recommendations are made.

Consider the following example expressions that are caught by the lint, and the corresponding recommendations made (in all these cases, `x` is a place holder for a numerical expression of type `u8`, `u16`, `u32`, `u64`, `u128`, or `u256`, and `MAX` is a place holder for the max value representable for that numeric type):

- `x < 0`, `0 > x`, `x > MAX`, `MAX < x`, are always false, rewrite code to remove this comparison
- `x >= 0`, `0 <= x`, `x <= MAX`, `MAX >= x`, are always true, rewrite code to remove this comparison
- `x <= 0`, `0 >= x`, `x >= MAX`, `MAX <= x`, can all be simplified to use `==` instead
- `x > 0`, `0 < x`, `x < MAX`, `MAX > x`, can all be clarified to use `!=` instead

### `redundant_comparison`

Checks for redundant, contradictory, and tautological numerical comparisons over the same variable in boolean expressions combined with `&&` and `||`. This lint identifies logic errors in conditional statements that can lead to unreachable code or always-true/false conditions.

Examples of patterns caught by this lint:

- **Redundant with `&&`**: `x <= 400 && x < 500` - the second condition is redundant since it's always satisfied when the first is true
- **Contradictory with `&&`**: `x <= 400 && x > 500` - these conditions can never both be true, making the expression always false
- **Redundant with `||`**: `x > 10 || x >= 5` - the first condition is redundant since the second covers more cases
- **Tautology with `||`**: `x < 5 || x >= 5` - this expression is always true for any value of x

The lint only triggers when comparisons are on the same variable and can detect constants on either side of the comparison operator.

### `while_true`

Checks for `while (true) { .... }` patterns and suggests using the more explicit `loop { .... }` construct instead.

## Suppressing Lint Warnings

To suppress one or more lint checks named `check1`, `check2`, ... (and so on), you can add the attribute `#[lint::skip(check1, check2, ...)]` to a function or a module. The linter will then not perform the checks named `check1`, `check2`, ... (and so on) for that function or module.

For example, the function below would usually get a warning from the linter about a `needless_bool`, but due to the attribute on the function, the linter does not emit a warning.

```move
#[lint::skip(needless_bool)]
fun violation(): bool {
    if (foo()) true else false
}
```

## Security Checks

### `contains_in_table`

Checks for unsafe usage of table operations that could lead to runtime errors. This lint helps prevent common mistakes when working with tables by detecting:

1. **Unsafe `table::borrow` calls**: Borrowing from a table without first checking if the key exists using `table::contains`. This can cause runtime errors if the key doesn't exist.

2. **Unsafe `table::add` calls**: Adding to a table without ensuring the key doesn't already exist. This can cause runtime errors if the key already exists.

The lint analyzes control flow to understand when keys are known to exist or not exist based on `table::contains` checks.

**Examples of patterns caught by this lint:**

```move
// Unsafe borrow - no contains check
table::borrow(&table, key); // Error: might fail if key doesn't exist

// Unsafe add - no contains check
table::add(&mut table, key, value); // Error: might fail if key already exists

// Wrong key check
if (table::contains(&table, key1)) {
    table::borrow(&table, key2); // Error: checked key1 but borrowing key2
}

// Wrong branch usage
if (!table::contains(&table, key)) {
    table::borrow(&table, key); // Error: key is known NOT to exist
}
```

**Recommended solutions:**

- For `table::borrow`: Use `table::contains` first to check if the key exists
- For `table::add`: Use `table::upsert` instead, or check with `table::contains` that the key doesn't exist first

### `return_signer`

This security check detects when a public function returns a `signer` value, which can leak authority and is usually a security risk. Returning a `signer` from a public function allows callers to obtain signer capabilities that they shouldn't have access to, potentially leading to unauthorized operations.

**Examples of patterns caught by this lint:**

```move
// Direct signer return - security risk
public fun get_signer(): signer {
    // ... code that returns a signer
}

// Signer in vector - security risk
public fun get_signers(): vector<signer> {
    // ... code that returns signers
}

// Signer in tuple - security risk
public fun get_data(): (u64, signer) {
    // ... code that returns a tuple with signer
}
```

### `zero_address`

This security check detects the use of `address` parameters in external functions that are not checked for being zero before being used. This could lead to loss of funds or other security issues.‚èé

### `return_constructor_ref`

Checks for public functions that return an `ConstructorRef`. Constructor references confer the authority to create an object, and returning them from functions can leak privileged capability. This lint helps prevent accidental exposure of sensitive object creation authority.

**Examples of patterns caught by this lint:**

```move
// Public function returning ConstructorRef - security risk
public fun create_object_ref(): ConstructorRef {
    // ... code that returns ConstructorRef
}

// Public function returning a struct containing ConstructorRef
public fun get_authority(): MyStruct<ConstructorRef> {
    // ... code that returns struct with ConstructorRef
}

// Public function returning vector containing ConstructorRef
public fun get_refs(): vector<ConstructorRef> {
    // ... code that returns vector with ConstructorRef
}
```

## Experimental Checks

### `cyclomatic_complexity`

Cyclomatic complexity measures the number of linearly independent execution paths through a function. A high value generally correlates with code that is harder to test and maintain.

This linter performs an approximation while traversing the Move expression tree:

1. The complexity score starts at **1**.
2. The score is incremented for each control-flow decision point found:
   - +1 for each `if`
   - +1 for each `else if`
   - +1 for each `loop`, `while`, or `for`
   - +1 for each `break` or `continue`
   - +1 for each `return` statement that is not the final expression in the function
   - +n where n = (number of match arms - 1)

When the accumulated score exceeds the default threshold (currently **10**), the linter emits a diagnostic suggesting that the function be simplified or decomposed.

# Maps

> Learn about maps for Move smart contract development on Aptos blockchain.

There are multiple different implementations of key-value maps inside the framework, suited for different usecases.
We will go over their differences and similarities, and how to choose which one to use.

## Aptos Blockchain performance and gas cost considerations

Aptos Blockchain state is kept in **storage slots**.
Furthermore, transaction performance and gas cost is heavily influenced by how these **slots** are read and written.
Breaking down the gas costs further, we have:

1. Storage fee, which are determined by the number and size of **slots** (i.e., writing to a new **slot** incurs the highest storage fee, whereas deleting an existing **slot** provides the largest refund.)
2. IO gas costs ‚Äîgenerally much lower‚Äî which depend on the number and size of resources read and modified.
3. execution gas costs are based on the computation needed, and are generally in the similar scale as io gas costs.

Transactions that modify the same **slot** cannot be executed concurrently (with some exceptions, like aggregators and resources as a part of the same resource group), as they conflict with one another.

One useful analogy is thinking about each **slot** being a file on a disk,
then performance of smart contract would correlate well to a program that
operates on files in the same way.

## Different Map implementations

| Implementation    | Size Limit                          | Storage Structure                                                                                                                               | Key Features                                                                                                                                                                                                  |
| ----------------- | ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `OrderedMap`      | Bounded (fits in a single **slot**) | Stored entirely within the resource that contains it                                                                                            | Supports ordered access (front/back, prev/next), implemented as sorted vector, but operations are effectively O(log(n)) due to internal optimizations                                                         |
| `Table`           | Unbounded                           | Each (key, value) stored in a separate **slot**                                                                                                 | Supports basic operations, like `add`, `remove`, `contains`, but **not iteration**, and **cannot be destroyed**; useful for large/unbounded keys/values and where high-concurrency is needed                  |
| `TableWithLength` | Unbounded                           | same as `Table`                                                                                                                                 | Variant of `Table`, with additional length tracking, which adds `length`, `empty`, and `destroy_empty` methods; Adding or removing elements **cannot** be done concurrently, modifying existing elements can. |
| `BigOrderedMap`   | Unbounded                           | Combines multiple keys into a single **slot**, initially stored within resource that contains it, and grows into multiple **slots** dynamically | Implemented as B+ tree; **opportunistically concurrent** for non-adjacent keys; supports ordered access (front/back, prev/next); configurable node capacities to balance storage and performance              |

Note:

- `SimpleMap` has been deprecated, and replaced with `OrderedMap`.
- `SmartTable` has been deprecated, and replaced with `BigOrderedMap`.

#### Performance comparison

We measured performance at small scale, measuring microseconds taken for a single pair of `insert` + `remove` operation, into a map of varied size.

| num elements | OrderedMap | BigOrderedMap max\_degree>10000 | BigOrderedMap max\_degree=16 |
| ------------ | ---------- | ------------------------------- | ---------------------------- |
| 10           | 65         | 123                             | 123                          |
| 100          | 85         | 146                             | 455                          |
| 1000         | 105        | 168                             | 567                          |
| 10000        | 142        | 210                             | 656                          |

You can see that overhead of `BigOrderedMap` compared to `OrderedMap`, when both are in the single **slot**, is around 1.5-2x.
So you can generally used `BigOrdredMap` when it is unknown if data will be too large to be stored in a single **slot**.

## Common map operations:

Most maps above support the same set of functions (for actual signatures and restrictions, check out the corresponding implementations):

#### Creating Maps

- `new<K, V>(): Self`: creates an empty map

#### Destroying Maps

- `destroy_empty<K, V>(self: Self<K, V>)`: Destroys an empty map. (**not** supported by `Table`)
- `destroy<K, V>(self: Self<K, V>, dk: |K|, dv: |V|)`: Destroys a map with given functions that destroy corresponding elements. (**not** supported by `Table` and `TableWithLength`)

#### Managing Entries

- `add<K, V>(self: &mut Self<K, V>, key: K, value: V)`: Adds a key-value pair to the map.
- `remove<K, V>(self: &mut Self<K, V>, key: K): V`: Removes and returns the value associated with a key.
- `upsert<K, V>(self: &mut Self<K, V>, key: K, value: V): Option<V>`: Inserts or updates a key-value pair.
- `add_all<K, V>(self: &mut Self<K, V>, keys: vector<K>, values: vector<V>)`: Adds multiple key-value pairs to the map. (**not** supported by `Table` and `TableWithLength`)

#### Retrieving Entries

- `contains<K, V>(self: &Self<K, V>, key: &K): bool`: Checks whether key exists in the map.
- `borrow<K, V>(self: &Self<K, V>, key: &K): &V`: Returns an immutable reference to the value associated with a key.
- `borrow_mut<K: drop, V>(self: &mut Self<K, V>, key: K): &mut V`: Returns a mutable reference to the value associated with a key.
  (`BigOrderedMap` only allows `borrow_mut` when value type has a static constant size, due to modification being able to break it's invariants otherwise. Use `remove()` and `add()` combination instead)

#### Order-dependant functions

These set of functions are only implemented by `OrderedMap` and `BigOrderedMap`.

- `borrow_front<K, V>(self: &Self<K, V>): (&K, &V)`
- `borrow_back<K, V>(self: &Self<K, V>): (&K, &V)`
- `pop_front<K, V>(self: &mut Self<K, V>): (K, V)`
- `pop_back<K, V>(self: &mut Self<K, V>): (K, V)`
- `prev_key<K: copy, V>(self: &Self<K, V>, key: &K): Option<K>`
- `next_key<K: copy, V>(self: &Self<K, V>, key: &K): Option<K>`

#### Utility Functions

- `length<K, V>(self: &Self<K, V>): u64`: Returns the number of entries in the map. (not supported by `Table`)

#### Traversal Functions

These set of functions are not implemented by `Table` and `TableWithLength`.

- `keys<K: copy, V>(self: &Self<K, V>): vector<K>`

- `values<K, V: copy>(self: &Self<K, V>): vector<V>`

- `to_vec_pair<K, V>(self: Self<K, V>): (vector<K>, vector<V>)`

- `for_each_ref<K, V>(self: &Self<K, V>, f: |&K, &V|)`

- `to_ordered_map<K, V>(self: &BigOrderedMap<K, V>): OrderedMap<K, V>`: Converts `BigOrderedMap` into `OrderedMap`

## Example Usage

### Creating and Using a OrderedMap

```move filename="map_usage.move"
module 0x42::map_usage {
    use aptos_framework::ordered_map;

    public entry fun main() {
        let map = ordered_map::new<u64, u64>();
        map.add(1, 100);
        map.add(2, 200);

        let length = map.length();
        assert!(length == 2, 0);

        let value1 = map.borrow(&1);
        assert!(*value1 == 100, 0);

        let value2 = map.borrow(&2);
        assert!(*value2 == 200, 0);

        let removed_value = map.remove(&1);
        assert!(removed_value == 100, 0);

        map.destroy_empty();
    }
}
```

## Additional details for `BigOrderedMap`

Its current implementation is B+ tree, which is chosen as it is best suited for the onchain storage layout - where the majority of cost comes from loading and writing to storage items, and there is no partial read/write of them.

Implementation has few characteristics that make it very versatile and useful across wide range of usecases:

- When it has few elements, it stores all of them within the resource that contains it, providing comparable performance to OrderedMap itself, while then dynamically growing to multiple resources as more and more elements are added
- It reduces amount of conflicts: modifications to a different part of the key-space can be generally done concurrently, and it provides knobs for tuning between concurrency and size
- All operations have guaranteed upper-bounds on performance (how long they take, as well as how much execution and io gas they consume), allowing for safe usage across a variety of use cases.
  - One caveat, is refundable storage fee. By default, operation that requires map to grow to more resources needs to pay for storage fee for it. Implementation here has an option to pre-pay for storage slots, and to reuse them as elements are added/removed, allowing applications to achieve fully predictable overall gas charges, if needed.
- If key/value is within the size limits map was configured with, inserts will never fail unpredictably, as map internally understands and manages maximal **slot** size limits.

### `BigOrderedMap` structure

`BigOrderedMap` is represented as a tree, where inner nodes split the "key-space" into separate ranges for each of it's children, and leaf nodes contain the actual key-value pairs.
Internally it has `inner_max_degree` representing largest number of children an inner node can have, and `leaf_max_degree` representing largest number of key-value pairs leaf node can have.

#### Creating `BigOrderedMap`

Because it's layout affects what can be inserted and performance, there are a few ways to create and configure it:

- `new<K, V>(): Self<K, V>`: Returns a new `BigOrderedMap` with the default configuration. Only allowed to be called with constant size types. For variable sized types, another constructor is needed, to explicitly select automatic or specific degree selection.
- `new_with_type_size_hints<K, V>(avg_key_bytes: u64, max_key_bytes: u64, avg_value_bytes: u64, max_value_bytes: u64): Self<K, V>`: Returns a map that is configured to perform best when keys and values are of given `avg` sizes, and guarantees to fit elements up to given `max` sizes.
- `new_with_config<K, V>(inner_max_degree: u16, leaf_max_degree: u16, reuse_slots: bool): Self<K, V>`: Returns a new `BigOrderedMap` with the provided max degree consts (the maximum # of children a node can have, both inner and leaf). If 0 is passed for either, then it is dynamically computed based on size of first key and value, and keys and values up to 100x times larger will be accepted.
  If non-0 is passed, sizes of all elements must respect (or their additions will be rejected):

  - `key_size * inner_max_degree <= MAX_NODE_BYTES`
  - `entry_size * leaf_max_degree <= MAX_NODE_BYTES`

  `reuse_slots` means that removing elements from the map doesn't free the storage slots and returns the refund.
  Together with `allocate_spare_slots`, it allows to preallocate slots and have inserts have predictable gas costs.
  (otherwise, inserts that require map to add new nodes, cost significantly more, compared to the rest)

## Source Code

- [ordered\_map.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/datastructures/ordered_map.move)
- [table.move](https://github.com/aptos-labs/aptos-core/blob/6f5872b567075fe3615e1363d35f89dc5eb45b0d/aptos-move/framework/aptos-stdlib/sources/table.move)
- [table\_with\_length.move](https://github.com/aptos-labs/aptos-core/blob/6f5872b567075fe3615e1363d35f89dc5eb45b0d/aptos-move/framework/aptos-stdlib/sources/table.move)
- [big\_ordered\_map.move](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/datastructures/big_ordered_map.move)

## Additional details of (deprecated) SmartTable

The Smart Table is a scalable hash table implementation based on linear hashing.
This data structure aims to optimize storage and performance by utilizing linear hashing, which splits one bucket at a time instead of doubling the number of buckets, thus avoiding unexpected gas costs.
Unfortunately, it's implementation makes every addition/removal be a conflict, making such transactions fully sequential.
The Smart Table uses the SipHash function for faster hash computations while tolerating collisions. Unfortunately, this also means that collisions are predictable, which means that if end users can control the keys being inserted, it can have large number of collisions in a single bucket.

### SmartTable Structure

The `SmartTable` struct is designed to handle dynamic data efficiently:

- `buckets`: A table with a length that stores vectors of entries.
- `num_buckets`: The current number of buckets.
- `level`: The number of bits representing `num_buckets`.
- `size`: The total number of items in the table.
- `split_load_threshold`: The load threshold percentage that triggers bucket splits.
- `target_bucket_size`: The target size of each bucket, which is not strictly enforced.

### SmartTable usage examples

- [Move Spiders Smart Table](https://movespiders.com/courses/modules/datastructures/lessonId/7)
- [Move Spiders Querying Smart Table via FullNode APIs](https://movespiders.com/courses/modules/datastructures/lessonId/9)
- [Move Spiders Querying Smart Table via View Function](https://movespiders.com/courses/modules/datastructures/lessonId/10)

# Modules on Aptos

> Learn about modules on aptos for Move smart contract development on Aptos blockchain.

import { Aside } from '@astrojs/starlight/components';

Aptos allows for permissionless publishing of [modules](/build/smart-contracts/book/modules-and-scripts)
within a [package](/build/smart-contracts/book/packages) as well as [upgrading](/build/smart-contracts/book/package-upgrades)
those that have appropriate compatibility policy set.

A module contains several structs and functions, much like Rust.

During package publishing time, a few constraints are maintained:

- Both Structs and public function signatures are published as immutable.
- The `init_module` function plays a crucial role in module initialization:
  - When a module is published for the first time (i.e., the module does not exist on-chain), the VM will search for and execute the `init_module(account: &signer)` function.
  - When upgrading an existing module that is already on-chain, the `init_module` function will NOT be called.
  - The signer of the account that is publishing the module is passed into the `init_module` function.
  - **This function must be private and not return any value.**
  - The `init_module` function can have at most one parameter, and its type must be `&signer`
  - The `init_module` function should not have generic parameters
  - The `init_module` function is commonly used to initialize module-specific data structures or set initial states.

<Aside type="note">
  `init_module` is optional. You only need to implement it if you want to:

  - Initialize module data when publishing a module for the first time
  - Set up initial states or configurations
  - Create resource accounts or other module-specific setup tasks
</Aside>

<Aside type="tip">
  Remember: The `init_module` function will only be called once in a module's lifecycle - when it is first published.
  Subsequent upgrades to the module will not trigger the `init_module` function again.
</Aside>

# Move Reference

> Learn about move reference for Move smart contract development on Aptos blockchain.

{/* <MoveReference /> */}

# Move Security Guidelines

> Learn about move security guidelines for Move smart contract development on Aptos blockchain.

import { Aside } from '@astrojs/starlight/components';

The Move language is designed with security and inherently offers several features including a type system and a linear logic. Despite this, its novelty and the intricacies of some business logic mean that developers might not always be familiar with Move's secure coding patterns, potentially leading to bugs.

This guide addresses this gap by detailing common anti-patterns and their secure alternatives. It provides practical examples to illustrate how security issues can arise and recommends best practices for secure coding. This guide aims to sharpen developers' understanding of Move's security mechanisms and ensure the robust development of smart contracts.

## Access Control

### Object Ownership Check

Every `Object<T>` can be accessed by anyone, which means any `Object<T>` can be passed to any function, even if the caller doesn't own it.
It's important to verify that the `signer` is the rightful owner of the object.

#### Example Insecure Code

In this module, a user must purchase a subscription before performing certain actions. The user invokes the registration function to acquire an `Object<Subscription>`, which they can later use to execute operations.

```move filename="object_example.move"
module 0x42::example {

    struct Subscription has key {
        end_subscription: u64
    }

    entry fun registration(user: &signer, end_subscription: u64) {
        let price = calculate_subscription_price(end_subscription);
        payment(user,price);

        let user_address = address_of(user);
        let constructor_ref = object::create_object(user_address);
        let subscription_signer = object::generate_signer(&constructor_ref);
        move_to(&subscription_signer, Subscription { end_subscription });
    }

    entry fun execute_action_with_valid_subscription(
        user: &signer, obj: Object<Subscription>
    ) acquires Subscription {
        let object_address = object::object_address(&obj);
        let subscription = borrow_global<Subscription>(object_address);
        assert!(subscription.end_subscription >= aptos_framework::timestamp::now_seconds(), 1);
        // Use the subscription
        [...]
    }
}
```

In this insecure example, `execute_action_with_valid_subscription` does not verify if the user owns the `obj` passed to it. Consequently, anyone can use another person's subscription, bypassing the payment requirement.

#### Example Secure Code

Ensure that the signer owns the object.

```move filename="object_example.move"
module 0x42::example {

    struct Subscription has key {
        end_subscription: u64
    }

    entry fun registration(user: &signer, end_subscription: u64) {
        let price = calculate_subscription_price(end_subscription);
        payment(user,price);

        let user_address = address_of(user);
        let constructor_ref = object::create_object(user_address);
        let subscription_signer = object::generate_signer(&constructor_ref);
        move_to(&subscription_signer, Subscription { end_subscription });
    }

    entry fun execute_action_with_valid_subscription(
        user: &signer, obj: Object<Subscription>
    ) acquires Subscription {
        //ensure that the signer owns the object.
        assert!(object::owner(&obj) == address_of(user), ENOT_OWNWER);
        let object_address = object::object_address(&obj);
        let subscription = borrow_global<Subscription>(object_address);
        assert!(subscription.end_subscription >= aptos_framework::timestamp::now_seconds(), 1);
        // Use the subscription
        [...]
    }
}
```

### Global Storage Access Control

Accepting a `&signer` is not always sufficient for access control purposes. Be sure to assert that the signer is the expected account, especially when performing sensitive operations.

Users without proper authorization can execute privileged actions.

#### Example Insecure Code

This code snippet allows any user invoking the `delete` function to remove an `Object`, without verifying that the caller has the necessary permissions.

```move filename="global_storage_insecure.move"
module 0x42::example {
  struct Object has key{
    data: vector<u8>
  }

  public fun delete(user: &signer, obj: Object) {
    let Object { data } = obj;
  }
}
```

#### Example Secure Code

A better alternative is to use the global storage provided by Move, by directly borrowing data off of `signer::address_of(signer)`. This approach ensures robust access control, as it exclusively accesses data contained within the address of the signer of the transaction. This method minimizes the risk of access control errors, ensuring that only the data owned by the `signer` can be manipulated.

```move filename="global_storage_secure.move"
module 0x42::example {
  struct Object has key{
    data: vector<u8>
  }

  public fun delete(user: &signer) {
    let Object { data } = move_from<Object>(signer::address_of(user));
  }
}
```

### Function visibility

Adhere to the principle of least privilege:

- Always start with private functions, change their visibility as it is needed by the business logic.
- Utilize `entry` for functions intended for use solely from the Aptos CLI or SDK.
- Utilize `friend` for functions that can only be accessible by specific modules.
- Utilize the `#[view]` decorator with functions that read data from storage without altering state. #\[view] functions can be invoked indirectly and in this case they might change the storage.

Function visibility determines who can call a function. It's a way to enforce access control and is critical for smart contract security:

- private functions are only callable within the module they are defined in. They're not accessible from other modules or from the CLI/SDK, which prevents unintended interactions with contract internals.

```move filename="private_function.move"
module 0x42::example {
  fun sample_function() { /* ... */ }
}
```

- `public(friend)` functions expand on this by allowing specified _friends_ modules to call the function, enabling controlled interaction between different contracts while still restricting general access.

```move filename="friend_function.move"
module 0x42::example {
  friend package::mod;

  public(friend) fun sample_function() { /* ... */ }
}
```

- `public` functions are callable by any published module or script.

```move filename="public_function.move"
module 0x42::example {
  public fun sample_function() { /* ... */ }
}
```

- `#[view]` decorated functions cannot alter storage; they only read data, providing a safe way to access information without risking state modification.

```move filename="view_function.move"
module 0x42::example {
  #[view]
  public fun read_only() { /* ... */ }
}
```

- The `entry` modifier in Move is used to indicate entry points for transactions. Functions with the `entry` modifier serve as the starting point of execution when a transaction is submitted to the blockchain.

```move filename="entry_function.move"
module 0x42::example {
  entry fun f(){}
}
```

To summarize:

|                | Module itself | Other Modules                | Aptos CLI/SDK |
| -------------- | ------------- | ---------------------------- | ------------- |
| private        | ‚úÖ             | ‚õî                            | ‚õî             |
| public(friend) | ‚úÖ             | ‚úÖ if friend<br />‚õî otherwise | ‚õî             |
| public         | ‚úÖ             | ‚úÖ                            | ‚õî             |
| entry          | ‚úÖ             | ‚õî                            | ‚úÖ             |

This layered visibility ensures that only authorized entities can execute certain functions, greatly reducing the risk of bugs or attacks that compromise contract integrity.

Note that it‚Äôs possible to combine `entry` with `public` or `public(friend)`

```move filename="friend_entry_function.move"
module 0x42::example {
  public(friend) entry fun sample_function() { /* ... */ }
}
```

In this case `sample_function` can be called by both the Aptos CLI/SDK by any module declared as a friend.

#### Impact

Adhering to this principle ensures that functions are not over-exposed, restricting the scope of function access to only what is necessary for the business logic.

## Types and Data Structures

### Generics type check

Generics can be used to define functions and structs over different input data types. When using them, ensure that the generic types are valid and what‚Äôs expected. [Read more](/build/smart-contracts/book/generics) about generics.

Unchecked generics can lead to unauthorized actions or transaction aborts, potentially compromising the integrity of the protocol.

#### Example Insecure Code

The code below outlines a simplified version of a flash loan.

In the `flash_loan<T>` function, a user can borrow a given amount of coins type **`T`** along with a `Receipt` that records the borrowed amount plus a fee that should be returned to the protocol before the end of the transaction.

The `repay_flash_loan<T>` function accepts a `Receipt` and a `Coin<T>` as parameters. The function extracts the repayment amount from the `Receipt` and asserts that the value of the returned `Coin<T>` is greater than or equal to the amount specified in the `Receipt`, however there‚Äôs no check to ensure that the `Coin<T>` returned is the same as the `Coin<T>`that was initially loaned out, giving the ability to repay the loan with a coin of lesser value.

```move filename="flash_loan_insecure.move"
module 0x42::example {
  struct Coin<T> {
    amount: u64
  }

  struct Receipt {
    amount: u64
  }

  public fun flash_loan<T>(user: &signer, amount: u64): (Coin<T>, Receipt) {
    let (coin, fee) = withdraw(user, amount);
    ( coin, Receipt {amount: amount + fee} )
  }

  public fun repay_flash_loan<T>(rec: Receipt, coins: Coin<T>) {
    let Receipt{ amount } = rec;
    assert!(coin::value<T>(&coins) >= rec.amount, 0);
    deposit(coins);
  }
}
```

#### Example Secure Code

The Aptos Framework sample below creates a key-value table consisting of two generic types `K` and `V` . Its related `add` functions accepts as parameters a `Table<K, V>` object, a `key`, and a `value` of types `K` and `V` . The `phantom` syntax ensures that the key and value types cannot be different than those in the table, preventing type mismatches. [Read more](/build/smart-contracts/book/generics#phantom-type-parameters) about `phantom` type parameters.

```move filename="table_secure.move"
module 0x42::example {
  struct Table<phantom K: copy + drop, phantom V> has store {
    handle: address,
  }

  public fun add<K: copy + drop, V>(table: &mut Table<K, V>, key: K, val: V) {
    add_box<K, V, Box<V>>(table, key, Box { val })
  }
}
```

Given the by-design type checking provided by the Move language, we can refine the code of our flash loan protocol. The code below ensures that the coins passed to `repay_flash_loan` match the originally-loaned coins.

```move filename="flash_loan_secure.move"
module 0x42::example {
  struct Coin<T> {
    amount: u64
  }
  struct Receipt<phantom T> {
    amount: u64
  }

  public fun flash_loan<T>(_user: &signer, amount:u64): (Coin<T>, Receipt<T>) {
    let (coin, fee) = withdraw(_user, amount);
    (coin,Receipt { amount: amount + fee})
  }

  public fun repay_flash_loan<T>(rec: Receipt<T>, coins: Coin<T>) {
    let Receipt{ amount } = rec;
    assert!(coin::value<T>(&coins) >= rec.amount, 0);
    deposit(coins);
  }
}
```

### Resource management and Unbounded Execution

Effective resource management and unbounded execution prevention are important for maintaining security and gas efficiency in protocol. It's essential to consider these aspects in contract design:

1. Avoid iterating over a publicly accessible structure that allows for unlimited entries, where any number of users can contribute without constraints.
2. Store user-specific assets, such as coins and NFTs, within individual user accounts.
3. Keep module or package-related information within Objects, separate from user data.
4. Instead of combining all user operations in a single shared global space, separating them by individual users.

#### Impact

The negligence of these aspects allowing an attacker to deplete the gas and abort the transaction. This can block application functionalities.

#### Example Insecure Code

The code below shows a loop iterating over every open order and could potentially be blocked by registering many orders:

```move filename="order_insecure.move"
module 0x42::example {
  public fun get_order_by_id(order_id: u64): Option<Order> acquires OrderStore {
    let order_store = borrow_global_mut<OrderStore>(@admin);
    let i = 0;
    let len = vector::length(&order_store.orders);
    while (i < len) {
      let order = vector::borrow<Order>(&order_store.orders, i);
      if (order.id == order_id) {
        return option::some(*order)
      };
      i = i + 1;
    };
    return option::none<Order>()
  }
  //O(1) in time and gas operation.
  public entry fun create_order(buyer: &signer) { /* ... */ }
}
```

#### Example Secure Code

It's recommended to structure the order management system in a way that each user's orders are stored in their respective account rather than in a single global order store. This approach not only enhances security by isolating user data but also improves scalability by distributing the data load. Instead of using **`borrow_global_mut<OrderStore>(@admin)`** which accesses a global store, the orders should be accessed through the individual user's account.

```move filename="order_secure.move"
module 0x42::example {
  public fun get_order_by_id(user: &signer, order_id: u64): Option<Order> acquires OrderStore {
    let order_store = borrow_global_mut<OrderStore>(signer::address_of(user));
    if (smart_table::contains(&order_store.orders, order_id)) {
      let order = smart_table::borrow(&order_store.orders, order_id);
      option::some(*order)
    } else {
      option::none<Order>()
    }
  }
}
```

It is also advisable to utilize efficient data structures tailored to the specific needs of the operations being performed. For instance, a **`SmartTable`** can be particularly effective in this context.

### Move Abilities

Move's abilities are a set of permissions that control the possible actions on data structures within the language. Smart contract developers must handle these capabilities with care, ensuring they're only assigned where necessary and understanding their implications to prevent security vulnerabilities.

| Ability | Description                                                                                                            |
| ------- | ---------------------------------------------------------------------------------------------------------------------- |
| copy    | Permits the duplication of values, allowing them to be used multiple times within the contract.                        |
| drop    | Allows values to be discarded from memory, which is necessary for controlling resources and preventing leaks.          |
| store   | Enables data to be saved in the global storage, critical to persist data across transactions.                          |
| key     | Grants data the ability to serve as a key in global storage operations, important for data retrieval and manipulation. |

[Read more](/build/smart-contracts/book/abilities) about abilities.

Incorrect usage of abilities can lead to security issues such as unauthorized copying of sensitive data (`copy`), resource leaks (`drop`), and global storage mishandling (`store`).

#### Example Insecure Code

```move filename="abilities_insecure.move"
module 0x42::example {
  struct Token has copy { }
  struct FlashLoan has drop { }
}
```

- `copy` capability for a `Token` allows tokens to be replicated, potentially enabling double-spending and inflation of the token supply, which could devalue the currency.
- Allowing the `drop` capability in a `FlashLoan` struct could permit borrowers to get out of their loan by destroying it before repayment.

## Arithmetic Operations

***

### Division Precision

Arithmetic operations that decrease precision by rounding down could lead protocols to underreport the outcome of these computations.

Move includes six unsigned integer data types: `u8`, `u16`, `u32`, `u64`, `u128`, and `u256`. Division operations in Move truncate any fractional part, effectively rounding down to the nearest whole number, potentially causing protocols to underrepresent the result of such calculations.

Rounding errors in calculations can have wide-ranging impacts, potentially causing financial imbalances, data inaccuracies, and flawed decision-making processes. These errors can result in a loss of revenue, give undue benefits, or even pose safety risks, depending on the context. Accurate and precise computation is essential to maintain system reliability and user confidence.

#### Example Insecure Code

```move filename="division_insecure.move"
module 0x42::example {
  public fun calculate_protocol_fees(size: u64): (u64) {
    return size * PROTOCOL_FEE_BPS / 10000
  }
}
```

If `size` is less than `10000 / PROTOCOL_FEE_BPS`, the fee will round down to 0, effectively enabling a user to interact with the protocol without incurring any fees.

#### Example Secure Code

The following examples outlines two distinct strategies to mitigate the issue in the code:

- Set a minimum order size threshold that is greater than `10000 / PROTOCOL_FEE_BPS`, ensuring that the fee will never round down to zero.

```move filename="division_secure_min.move"
module 0x42::example {
  const MIN_ORDER_SIZE: u64 = 10000 / PROTOCOL_FEE_BPS + 1;

  public fun calculate_protocol_fees(size: u64): (u64) {
    assert!(size >= MIN_ORDER_SIZE, 0);
    return size * PROTOCOL_FEE_BPS / 10000
  }
}
```

- Check that fees are non-zero and handle the situation specifically, for example by set a minimum fee or rejecting the transaction.

```move filename="division_secure_check.move"
module 0x42::example {
  public fun calculate_protocol_fees(size: u64): (u64) {
    let fee = size * PROTOCOL_FEE_BPS / 10000;
    assert!(fee > 0, 0);
    return fee;
  }
}
```

### Integer Considerations

In Move, the security around integer operations is designed to prevent overflow and underflow which can cause unexpected behavior or vulnerabilities. Specifically:

- Additions (`+`) and multiplications (`*`) cause the program to abort if the result is too large for the integer type. An abort in this context means that the program will terminate immediately.
- Subtractions (`-`) abort if the result is less than zero.
- Division (`/`) abort if the divisor is zero.
- Left Shift (`<<`), uniquely, does not abort in the event of an overflow. This means if the shifted bits exceed the storage capacity of the integer type, the program will not terminate, resulting in incorrect values or unpredictable behavior.

[Read more](/build/smart-contracts/book/integers#operations) about operations.

Bad operations could unexpectedly alter the correct execution of the smart contract, either by causing an unwanted abort or by calculating inaccurate data.

## Aptos Objects

***

### ConstructorRef leak

When creating objects ensure to never expose the object‚Äôs `ConstructorRef` as it allows adding resources to an object. A `ConstructorRef` can also be used to generate other capabilities (or "Refs") that are used to alter or transfer the ownership the object. [Read more](/build/smart-contracts/object/creating-objects) about Objects capabilities.

#### Example Vulnerable code

For example, if a `mint` function returns the `ConstructorRef` for an NFT, it can be transformed to a `TransferRef`, stored in global storage, and can allow the original owner to transfer the NFT back after it‚Äôs being sold.

```move filename="constructor_ref_vulnerable.move"
module 0x42::example {
  use std::string::utf8;

  public fun mint(creator: &signer): ConstructorRef {
    let constructor_ref = token::create_named_token(
        creator,
        string::utf8(b"Collection Name"),
        string::utf8(b"Collection Description"),
        string::utf8(b"Token"),
        option::none(),
        string::utf8(b"https://mycollection/token.jpeg"),
    );
    constructor_ref
  }
}
```

#### Example Secure Code

Don‚Äôt return `CostructorRef` in the `mint` function:

```move filename="constructor_ref_secure.move"
module 0x42::example {
  use std::string::utf8;

  public fun mint(creator: &signer) {
    let constructor_ref = token::create_named_token(
        creator,
        string::utf8(b"Collection Name"),
        string::utf8(b"Collection Description"),
        string::utf8(b"Token"),
        option::none(),
        string::utf8(b"https://mycollection/token.jpeg"),
    );
  }
}
```

### Object Accounts

In the Aptos Framework, multiple `key`-able resources can be stored at a single object account.

However, objects should be isolated to different account, otherwise modifications to one object within an account can influence the entire collection.

For example, transferring one resource implies the transfer of all group members, since the transfer function operates on `ObjectCore`, which is essentially a general tag for all resources at the account.

[Read more](/build/smart-contracts/objects) about Aptos Objects.

#### Example Insecure Code

The `mint_two` function lets `sender` create a `Monkey` for themselves and send a `Toad` to `recipient`.

As `Monkey` and `Toad` belong to the same object account the result is that both objects‚Äô are now owned by the `recipient`.

```move filename="object_accounts_insecure.move"
module 0x42::example {
  #[resource_group(scope = global)]
  struct ObjectGroup { }

  #[resource_group_member(group = 0x42::example::ObjectGroup)]
  struct Monkey has store, key { }

  #[resource_group_member(group = 0x42::example::ObjectGroup)]
  struct Toad has store, key { }

  fun mint_two(sender: &signer, recipient: &signer) {
    let constructor_ref = &object::create_object_from_account(sender);
    let sender_object_signer = object::generate_signer(constructor_ref);
    let sender_object_addr = object::address_from_constructor_ref(constructor_ref);

    move_to(sender_object_signer, Monkey{});
    move_to(sender_object_signer, Toad{});
    let monkey_object: Object<Monkey> = object::address_to_object<Monkey>(sender_object_addr);
    object::transfer<Monkey>(sender, monkey_object, signer::address_of(recipient));
  }
}
```

#### Example Secure Code

In this example, objects should be stored at separate object accounts:

```move filename="object_accounts_secure.move"
module 0x42::example {
  #[resource_group(scope = global)]
  struct ObjectGroup { }

  #[resource_group_member(group = 0x42::example::ObjectGroup)]
  struct Monkey has store, key { }

  #[resource_group_member(group = 0x42::example::ObjectGroup)]
  struct Toad has store, key { }

  fun mint_two(sender: &signer, recipient: &signer) {
    let sender_address = signer::address_of(sender);

    let constructor_ref_monkey = &object::create_object(sender_address);
    let constructor_ref_toad = &object::create_object(sender_address);
    let object_signer_monkey = object::generate_signer(&constructor_ref_monkey);
    let object_signer_toad = object::generate_signer(&constructor_ref_toad);

    move_to(object_signer_monkey, Monkey{});
    move_to(object_signer_toad, Toad{});

    let object_address_monkey = signer::address_of(&object_signer_monkey);

    let monkey_object: Object<Monkey> = object::address_to_object<Monkey>(object_address_monkey);
    object::transfer<Monkey>(sender, monkey_object, signer::address_of(recipient));
  }
}
```

## Business logic

### Front-running

Front-running involves executing transactions ahead of others by exploiting knowledge of future actions already made by others. This tactic gives front-runners an unfair advantage, as they can anticipate and benefit from the outcomes of these pending transactions.

Front-running can undermine the fairness and integrity of a decentralized application. It can lead to loss of funds, unfair advantages in games, manipulation of market prices, and a general loss of trust in the platform

#### Example Insecure Code

In a lottery scenario, users participate by selecting a number from 1 to 100. At a certain point, the game administrator invokes the function `set_winner_number` to set the winning number. Subsequently, in a separate transaction, the administrator reviews all player bets to determine the winner via `evaluate_bets_and_determine_winners`.

A front-runner observing the winning number set by `set_winner_number` could attempt to submit a late bet or modify an existing bet to match the winning number before `evaluate_bets_and_determine_winners` executes.

```move filename="front_running_insecure.move"
module 0x42::example {
  struct LotteryInfo {
    winning_number: u8,
    is_winner_set: bool,
  }

  struct Bets { }

  public fun set_winning_number(admin: &signer, winning_number: u8) {
    assert!(signer::address_of(admin) == @admin, 0);
    assert!(winning_number < 10, 0);
    let lottery_info = LotteryInfo { winning_number, is_winner_set: true };
    move_to<LotteryInfo>(admin, lottery_info);
  }

  public fun evaluate_bets_and_determine_winners(admin: &signer) acquires LotteryInfo, Bets {
    assert!(signer::address_of(admin) == @admin, 0);
    let lottery_info = borrow_global<LotteryInfo>(admin);
    assert(lottery_info.is_winner_set, 1);

    let bets = borrow_global<Bets>(admin);
    let winners: vector<address> = vector::empty();

    let winning_bets_option = smart_table::borrow_with_default(&bets.bets, lottery_info.winning_number, &vector::empty());

    vector::iter(winning_bets_option, |bet| {
       vector::push_back(&mut winners, bet.player);
    });
    distribute_rewards(&winners);
  }
}
```

#### Example Secure Code

An effective strategy to avoid front-running could be implementing a `finalize_lottery` function that reveals the answer and concludes the game within a single transaction, and making the other functions private. This approach guarantees that as soon as the answer is disclosed, the system no longer accepts any new answers, thereby eliminating the chance for front-running.

```move filename="front_running_secure.move"
module 0x42::example {
  public fun finalize_lottery(admin: &signer, winning_number: u64) {
    set_winner_number(admin, winning_number);
    evaluate_bets_and_determine_winners(admin);
  }

  fun set_winning_number(admin: &signer, winning_number: u64) { }

  fun evaluate_bets_and_determine_winners(admin: &signer) acquires LotteryInfo, Bets { }
}
```

### Price Oracle Manipulation

In Defi applications, price oracles that utilize the liquidity ratio of tokens in a pair to determine prices for transactions can be vulnerable to manipulation. This susceptibility arises from the fact that the liquidity ratio can be influenced by market participants who hold a significant amount of tokens. When these participants strategically increase or decrease their token holdings, it can impact the liquidity ratio and consequently affect the prices determined by the price oracle, potentially draining the pool.

We recommend to use multiple oracles to determine prices.

#### Secure Code Example

Thala, for example, utilizes a tiered-oracle design. The system has a primary and a secondary oracle. Should one of the oracles fail, the other one serves as a backup based on a sophisticated switching logic. The system is designed with adversarial situations in mind, and strives to provide highly accurate price feeds with minimal governance interaction all the time.

For more in-depth information, refer to [Thala's documentation](https://docs.thala.fi/thala-protocol-design/move-dollar-mod/oracles).

### Token Identifier Collision

When dealing with tokens, ensure that the method for comparing token structs to establish a deterministic ordering does not lead to collisions. Concatenating the address, module, and struct names into a vector is insufficient, as it does not differentiate between similar names that should be treated as unique.

As a consequence, the protocol may erroneously reject legitimate swap pairs due to collisions in token struct comparisons. This oversight could compromise the integrity of swap operations, leading to a loss of funds.

#### Example Insecure Code

The `get_pool_address` function creates a unique address for a liquidity pool associated with trading pairs of fungible assets. It generates and returns an address that serves as a distinct identifier for the liquidity pool of the specified two tokens.

However, users have the freedom to create an `Object<Metadata>` with any symbol they choose. This flexibility could lead to the creation of `Object<Metadata>` instances that mimic other existing instances. This issue might result in a seed collision, which in turn could cause a collision in the generation of the pool address.

```move filename="token_collision_insecure.move"
module 0x42::example {
  public fun get_pool_address(token_1: Object<Metadata>, token_2: Object<Metadata>): address {
    let token_symbol = string::utf8(b"LP-");
    string::append(&mut token_symbol, fungible_asset::symbol(token_1));
    string::append_utf8(&mut token_symbol, b"-");
    string::append(&mut token_symbol, fungible_asset::symbol(token_2));
    let seed = *string::bytes(&token_symbol);
    object::create_object_address(&@swap, seed)
  }
}
```

#### Example Secure Code

`object::object_address` returns an unique identifier for each `Object<Metadata>`

```move filename="token_collision_secure.move"
module 0x42::example {
  public fun get_pool_address(token_1: Object<Metadata>, token_2: Object<Metadata>): address {
    let seeds = vector[];
    vector::append(&mut seeds, bcs::to_bytes(&object::object_address(&token_1)));
    vector::append(&mut seeds, bcs::to_bytes(&object::object_address(&token_2)));
    object::create_object_address(&@swap, seeds)
  }
}
```

## Operations

***

### Pausing functionality

Protocols should have the ability to pause operations effectively. For immutable protocols, a built-in pause functionality is necessary. Upgradable protocols can achieve pausing either through smart contract functionality or via protocol upgrades. Teams should be equipped with automation for the quick and efficient execution of this process.

The absence of a pausing mechanism can lead to prolonged exposure to vulnerabilities, potentially resulting in significant losses. An efficient pausing functionality allows for prompt response to security threats, bugs, or other critical issues, minimizing the risk of exploitation and ensuring the safety of user assets and protocol integrity.

#### Example Secure Code

Example of how to integrate a pause functionality

```move filename="pause_functionality.move"
module 0x42::example {
  struct State {
    is_paused: bool,
  }

  public entry fun pause_protocol(admin: &signer) {
    assert!(signer::address_of(admin) == @protocol_address, ERR_NOT_ADMIN);
    let state = borrow_global_mut<State>(@protocol_address);
    state.is_paused = true;
  }

  public entry fun resume_protocol(admin: &signer) {
    assert!(signer::address_of(admin) == @protocol_address, ERR_NOT_ADMIN);
    let state = borrow_global_mut<State>(@protocol_address);
    state.is_paused = false;
  }

  public fun main(user: &signer) {
    let state = borrow_global<State>(@protocol_address);
    assert!(!state.is_paused, 0);
    // ...
  }
}
```

### Smart contract publishing key management

Using the same account for testnet and mainnet poses a security risk, as testnet private keys, often stored in less secure environments (ex. laptops), can be more easily exposed or leaked. An attacker that can obtain the private key for the testnet smart contract would be able to upgrade the mainnet one.

## Randomness

For more information on randomness and why it is crucial for preventing the predictability of random numbers, please refer to this page: [Randomness Guide](/build/smart-contracts/randomness).

***

### Randomness - test-and-abort

> At Aptos, We are always security-first. During compilation, we ensure that no randomness API is invoked from a public function. However, we still allow users to make this choice by adding the attribute `#[lint::allow_unsafe_randomness]` to the public function.

If a `public` function directly or indirectly invokes the randomness API, a malicious user can abuse the composability of this function and abort the transaction if the result is not as desired. This allows the user to keep trying until they achieve a beneficial outcome, undermining the randomness.

#### Example Vulnerable code

```move filename="randomness_example.move"
module user::lottery {
    fun mint_to_user(user: &signer) {
        move_to(user, WIN {});
    }

    #[lint::allow_unsafe_randomness]
    public entry fun play(user: &signer) {
        let random_value = aptos_framework::randomness::u64_range(0, 100);
        if (random_value == 42) {
            mint_to_user(user);
        }
    }
}
```

In this example, the `play` function is `public`, allowing it to be composed with other modules. A malicious user can invoke this function and then check if they have won. If they have not won, they can abort the transaction and try again.

```move filename="randomness_example.move"
module attacker::exploit {
    entry fun exploit(attacker: &signer) {
        @user::lottery::play(attacker);
        assert!(exists<@user::lottery::WIN>(address_of(attacker)));
    }
}
```

To resolve the possible issue, is sufficient to set the visibility of all functions that invoke the randomness API, either directly or indirectly, to `entry` rather than `public` or `public entry`.

#### Example Secure Code

```move filename="randomness_example.move"
module user::lottery {
    fun mint_to_user(user: &signer) {
        move_to(user, WIN {});
    }

    #[lint::allow_unsafe_randomness]
    entry fun play(user: &signer) {
        let random_value = aptos_framework::randomness::u64_range(0, 100);
        if (random_value == 42) {
            mint_to_user(user);
        }
    }
}
```

### Randomness - undergasing

When different code paths in a function consume different amounts of gas, an attacker can manipulate the gas limit to bias the outcome. Let's look at an example of how different paths can consume different amounts of gas.

#### Example Vulnerable code

```move filename="randomness_example.move"
module user::lottery {

    //transfer 10 aptos from admin to user
    fun win(user: &signer) {
        let admin_signer = &get_admin_signer();
        let aptos_metadata = get_aptos_metadata();
        primary_fungible_store::transfer(admin_signer, aptos_metadata, address_of(user),10);
    }

    //transfer 10 aptos from user to admin, then 1 aptos from admin to fee_admin
    fun lose(user: &signer) {

        //user to admin
        let aptos_metadata = get_aptos_metadata();
        primary_fungible_store::transfer(user, aptos_metadata, @admin, 10);

        //admin to fee_admin
        let admin_signer = &get_admin_signer();
        primary_fungible_store::transfer(admin_signer, aptos_metadata, @fee_admin, 1);
    }

    #[randomness]
    entry fun play(user: &signer) {
        let random_value = aptos_framework::randomness::u64_range(0, 100);
        if (random_value == 42) {
            win(user);
        } else {
            lose(user);
        }
    }
}
```

In this lottery-example, `win` and `lose` consume different amounts of gas.
The `lose` function consumes more gas than the `win` function. An attacker can set the max gas limit that is sufficient for `win` but not for `lose`. This forces the transaction to abort when the `lose` path is taken, ensuring that the user will never execute the `lose` path. Then, the user can call the function repeatedly until they win.

#### Example Secure Code

There are different ways to secure the code:

1. Ensure better outcomes use more or the same gas as worse outcomes.
2. Allow only admin addresses to invoke the randomness API.
3. Ensure entry functions work regardless of random outcomes. This can be handled by committing the random result, then using the random result to provide the action in a different transaction. Avoid immediate actions based on randomness for consistent gas use.

> We will be providing more functionality in the future, to allow for more complex code to be able to be safe against undergasing attacks.

## Reentrancy

A **reentrancy attack** occurs when a contract performs an external call that can invoke the original contract again _before it finishes updating its state_. This can let an attacker repeat state-dependent actions (e.g., multiple withdrawals) against **stale state**.

Historically, Move prevented reentrancy. With the introduction of **function values**, certain forms of reentrancy are now possible under specific conditions. By contrast, **dispatchable fungible assets** remain protected against reentrancy.

<Aside type="note" emoji="‚ÑπÔ∏è" title="Dispatchable Fungible Assets">
  **No reentrancy permitted.** All native dispatchable functions are **locked against re-entering an active module** (a module already invoked within the current transaction).
</Aside>

***

## Function Values

Since language version **2.2**, Move supports **function values** (first-class functions). Function values can be stored, and passed around like any other value.

<Aside type="caution" emoji="üö®">
  Function values are **not** locked against reentrancy. Callbacks via function values can re-enter the original module.
</Aside>

```mermaid
graph LR
  %% Stable: no quotes, no parentheses, no double colons, no special edge labels.

  %% Left (no function values)
  A[Without Function Values]
  m1a[m1]
  m2a[m2]
  noteA[acyclic usage -> no reentrancy]
  A --- m1a
  m1a --> m2a
  m2a --- noteA

  %% Right (with function values)
  B[With Function Values]
  m1b[m1]
  call1[call m2.f passing FV]
  m2b[m2]
  cb1[callback to m1 via FV]
  noteB[closure dynamic dispatch -> reentrancy possible]
  B --- m1b
  m1b --> call1 --> m2b
  m2b -.-> cb1 -.-> m1b
  m2b --- noteB
```

***

### Resource Locking

To preserve Move‚Äôs reference semantics and suppress side effects from reentrancy, **re-entered modules cannot access their own resources** during dynamic dispatch through a closure. Attempts to borrow or move such resources **abort**.

Examples that will abort on re-entry:

- `borrow_global<m::R>(addr)`
- `move_from<m::R>(addr)`

[Read more](/build/smart-contracts/book/functions#reentrancy-check) about the function-value reentrancy checks.

### Time-of-Check vs Time-of-Use (TOCTOU)

Function values (FVs) can be stored inside wrapper structs and moved to global storage. Because FVs can **capture local variables**, scenarios arise where a value is **checked now** but **used later** (after state changes), leading to TOCTOU bugs.

```move filename="function_value_struct.move"
module example::function_value_struct {
    struct S {
        fn: |u64| u64
    }
}
```

**Guidance:**

- If an **amount** (or any state-derived value) is validated before creating the FV, **re-validate it at invocation time**‚Äîespecially if the FV (or a struct containing it) is stored in global storage and called later.
- There is **no guarantee** that the state captured by an FV remains unchanged by the time the FV executes (or that it executes at all).

**Safer pattern‚Äîcapture a concrete resource:**

Capturing a concrete value whose identity is stable and which has the `store` ability is generally safer for long-lived function values‚Äîespecially when the function value must be stored in global storage. This avoids relying on state-derived values that can change between time-of-check and time-of-use.

Important: `FungibleAsset` does not have the `store` ability. Any function value that captures a `FungibleAsset` therefore cannot itself be storable. If you need a storable function value, capture a separate, concrete resource that records the intended action (for example, a voucher/grant) and then perform the FA operation at invocation time.

This approach assumes that the FA is acquired and stored under a controlled FungibleStore without any state changes. Only at the time of voucher use and destruction are state changes or operations performed.

Example: capturing a storable voucher resource, then currying a persistent function so the resulting function value is storable:

```move filename="voucher_example.move"
module example::vouchers {
    use std::signer;

    // Concrete resource with store ability; identity and contents are fixed at capture time
    struct Voucher has store {
        metadata: Object<Metadata>,
        amount: u64
    }

    // Persistent, via public, function so the resulting FV can have `store`
    public fun redeem(to: address, v: Voucher) {
        // Redeem using the fixed metadata/amount in the voucher
        // e.g., withdraw/deposit at this point
    }

    // Produces a storable FV that closes over a concrete Voucher
    public fun build_redeemer(v: Voucher): |address| {
        |to| redeem(to, v)
    }
}
```

Case: `FungibleAsset` (non-storable capture). If you capture a `FungibleAsset`, the function value cannot be stored, it must be invoked immediately in the same transaction. For persistence, capture a storable description (such as a voucher) instead of the FA itself.

```move filename="fungible_asset_case.move"
module example::fa_case {
    // Pattern B: Pass FA as an argument to a function value (no capture)
    public fun with_handler(
        owner: &signer,
        token: Object<Metadata>,
        amount: u64,
        handle: |FungibleAsset|
    ) {
        let fa = primary_fungible_store::withdraw(owner, token, amount);
        handle(fa);
    }
}
```

### Immutable Parameters

If a function value has captured or lifted arguments, those arguments are not going to be overridden at the time of invocation.
The following example demonstrates this intended behavior.

```move filename="immutable_parameters.move"
module example::example {
    use std::signer;
    use std::debug;

    fun foo(x: u64) {
        debug::print(&x);
    }

    public fun invoke(f: |u64|) {
        f(1); // The captured value (10) is not overridden at the time of invocation.
    }

    #[test(_att = @0x1337)]
    fun run(_att: &signer) {
        invoke(|_x| foo(10));
    }
}
```

To understand this behavior, we need to look at how closures are lifted into functions.

```text filename="lambda_assembly.masm"
__lambda__1__run(_x: u64) /* def_idx: 3 */ {
B0:
	0: LdU64(10) // load the value 10 into the stack
	1: Call foo(u64)
	2: Ret
}
```

You can see that the resulting function fixes the first argument to 10. So `x` is not overridden at the time of invocation.

### Arbitrary Function Value

Passing one or a chain of functions as a parameter to another function, or storing FVs in a table, e.g. to be used as custom hooks, are patterns that can lead to reentrancy.

**Example Vulnerable code:**

In this example, the `withdraw_operations` acts as a proxy to call into a series of functions.
As `Grant` is not part of `0x42::example`, any operation on it is **allowed** during closure dynamic dispatch.

```move filename="reentrancy_example.move"
module example::account {
    use std::signer;
    friend example::example;

    const ENOT_ENOUGH_BALANCE: u64 = 1;

    public struct Grant has drop {}

    public(friend) fun grant(): Grant {
        Grant {}
    }

    public(friend) fun balance(_account: address): u64 {
        1_000
    }

    public(friend) fun transfer(
        _from: address, _to: address, _amount: u64
    ) {}

    public(friend) fun has_grant(_g: &Grant): bool {
        true
    }
}

module example::example {
    use std::signer::address_of;
    use std::option::{Self as option, Option};
    use example::account;

    const EGRANT_NOT_FOUND: u64 = 2;
    const ENOT_ENOUGH_BALANCE: u64 = 3;

    public fun withdraw_operations(
        user: &signer,
        recipient: Option<address>,
        amount: u64,
        f: |address, Option<address>, &account::Grant, u64|
    ) {
        let account_addr = address_of(user);
        let bal = account::balance(account_addr);
        assert!(bal >= amount, ENOT_ENOUGH_BALANCE);
        let g = account::grant();
        f(account_addr, recipient, &g, amount);
    }

    public fun withdraw(
        account_addr: address,
        recipient: Option<address>,
        grant: &account::Grant,
        amount: u64
    ) {
        assert!(account::has_grant(grant), EGRANT_NOT_FOUND);
        let r = recipient;
        if (option::is_some(&r)) {
            account::transfer(account_addr, option::destroy_some(r), amount);
        } else {
            option::destroy_none(r);
        };
        account::transfer(account_addr, account_addr, amount);
    }
}
```

An attacker can exploit this by calling `withdraw_operations` with a function value that calls `withdraw` and passes the `Grant` as a parameter.
By altering, or [prefixing](/build/smart-contracts/move-security-guidelines#immutable-parameters), the amount of the transfer, which if pulled from a shared pool of funds, allows the attacker to overdraw the balance of the account.

```move filename="attacker.move"
module attacker::exploit {
    use 0x42::example;
    entry fun start(attacker: &signer) {
        example::withdraw_operations(
            attacker,
            None,
            10,
            |account, recipient, grant, amount| example::withdraw(
                attacker, recipient, grant, 100_000_000
            )
        );
    }
}
```

**Example Secure code:**

We've introduced the amount field into the grant structure to fix the amount at a specific moment. At the same time, we've finalized the status update. This can be thought of as a bank transfer that the bank is simply waiting to execute but has already recorded.

```move filename="reentrancy_secure.move"
module example::account {
    use std::signer;
    friend example::example;

    const ENOT_ENOUGH_BALANCE: u64 = 1;

    // Notice that the grant is not droppable to ensure it used, but we can allow it to be stored.
    public struct Grant {
        account: address,
        amount: u64
    } // might capture other information like the asset type.

    public(friend) fun grant(account: address, amount: u64): Grant {
        update_balance_withdraw(account, amount);
        Grant { account, amount }
    }

    fun update_balance_withdraw(account: address, amount: u64) { /* retrieve the account and update the balance */ } // The state update is done here.

    public(friend) fun balance(_account: address): u64 {
        1_000
    }

    public(friend) fun transfer(_to: address, _grant: Grant) {
        /* transfer the amount of the grant to the recipient and destroy the grant */
    }

    public(friend) fun has_grant(_g: &Grant): bool {
        true
    }
}

module example::example {
    use std::signer::address_of;
    use std::option::{Self as option, Option};
    use example::account;

    const EGRANT_NOT_FOUND: u64 = 2;
    const ENOT_ENOUGH_BALANCE: u64 = 3;

    public fun withdraw_operations(
        user: &signer,
        recipient: Option<address>,
        amount: u64,
        f: |address, account::Grant|
    ) {
        let account_addr = address_of(user);
        let bal = account::balance(account_addr);
        assert!(bal >= amount, ENOT_ENOUGH_BALANCE);
        let g = account::grant(account_addr, amount); // When the grant is created, the amount is fixed and verified to be available.
        if (option::is_some(&recipient)) {
            f(option::destroy_some(recipient), g); // By the time the function value is invoked, the state update is done, so reentrancy is not a problem.
        } else {
            f(account_addr, g);
        };
    }

    public fun withdraw(recipient: address, grant: account::Grant) {
        assert!(account::has_grant(&grant), EGRANT_NOT_FOUND);
        account::transfer(recipient, grant);
    }
}
```

# Move VSCode Extension

> Learn about move vscode extension for Move smart contract development on Aptos blockchain.

import { Aside } from '@astrojs/starlight/components';

# Move on Aptos Language Extension

This is the official Visual Studio Code (and Cursor) extension for [developing smart contracts in the Move language on the Aptos blockchain](/build/smart-contracts).

Built from the ground up, it delivers a modern and performant development experience, offering essential features like semantic highlighting, real-time diagnostics, auto-formatting and seamless integration with the rest of the Aptos toolchain - all designed to help developers build and test Move contracts with ease and confidence.

Actively maintained by the Aptos team, this extension is designed to evolve alongside the Move language and supports both developers who are new to Move, and those building more complex applications.

## Features

- Semantic Highlighting
- Go to Definition
- Find All References & Symbol Renaming
- Type and Documentation on Hover
- Contextual Auto-Completion
- Inlay Hints for Types and Function Parameters

![Inlay hints](~/images/move-vscode-extension/inlay_hints.png)

- Real-Time Diagnostics
- [Code suggestions](#code-suggestions-with-fixes)
- `movefmt` Integration

![Formatting with movefmt](~/images/move-vscode-extension/format.gif)

- Run `#[test]` functions
- Check modules and functions with Move Prover

## Installation

We publish releases both on [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=AptosLabs.move-on-aptos) and [OpenVSX](https://open-vsx.org/extension/aptoslabs/move-on-aptos).

We also publish `nightly` pre-releases, which are built from `main` branch every night. To use those, select **Switch to Pre-Release Version** from your editor's Extensions View.

![Pre-releases selection](~/images/move-vscode-extension/pre-releases.png)

### Build from sources

Clone the repo, then run:

```
cargo run -p xtask -- install --server --client
```

(or just `cargo xtask install --server --client`, see [https://github.com/matklad/cargo-xtask](https://github.com/matklad/cargo-xtask))

The command builds `move-on-aptos.vsix` extension file and installs it into your VSCode.
Then it runs `cargo install` to build and install language server.

Put

```
"move-on-aptos.server.path": "~/.cargo/bin/aptos-language-server",
```

to your `settings.json` to point the extension to your locally built language server.

### Build from sources: Cursor AI editor

If you use [https://www.cursor.com/](https://www.cursor.com/) AI editor, you need to do a bit more work.

Run the installation command above. The result would be a `./editors/code/move-on-aptos.vsix` vscode extension package.
Then install it from the editor using the `"Install from VSIX..."` command.

## Configuration

<Aside type="note">
  Extension by itself won't download your dependencies from the network.

  If you see `unresolved reference` errors on the `AptosFramework` imports -
  try running `aptos move compile` once on your project to download your remote dependencies.
</Aside>

This extension provides configurations through VSCode's configuration settings.
All configurations are under `move-on-aptos.*`.

### Recommended configuration for the Move package directories

LSP is somewhat limited in what it can actually do, so some of the settings need to be specified manually.

#### Mark Move Library sources read-only

Add the following to your `settings.json`:

```json5
    "files.readonlyInclude": {
        "**/build/*/sources/**/*.move": true,
        "**/.move/**/*.move": true,
    }
```

#### Auto-close `b"` and `x"` properly

```json5
    "[move]": {
        "editor.wordSeparators": "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?bx",
    },
```

A bunch of symbols in the config value are the defaults, we're adding `b` and `x` symbols for the string prefixes.

#### Set `Organize Imports` command to a keyboard shortcut

```json5
    {
        "key": "ctrl+alt+o",
        "command": "move-on-aptos.organizeImports",
        "when": "editorTextFocus && !editorReadonly"
    }
```

## AdvancedConfiguration

### Diagnostics

Extension provides a number of diagnostics, from hard errors like "unresolved reference" to style lints.
Some of those might be less useful than others for different coding styles, so there's an escape hatch to disable those:

```json5
{
    "move-on-aptos.diagnostics.disabled": [],
}
```

where values are diagnostic codes from the error messages, like `unused-variable` here:

![Diagnostic code example](~/images/move-vscode-extension/diag_code.png)

### Inlay hints

Type hints for the let statements and lambda parameters are supported.

```move
module 0x1::m {
    fun main() {
        let a/*: integer*/ = 1;
        let f: |u8| u8 = |e/*: u8*/| e;
    }
}
```

To disable those, use:

```json5
{
    "move-on-aptos.inlayHints.typeHints.enable": false,
}
```

### Formatting (works with `movefmt` >= 1.2.1)

Specify a path to the `movefmt` executable and extra args (like a `--config-path`) if necessary:

```json5
{
    "move-on-aptos.movefmt.path": "~/code/movefmt/target/release/movefmt",
    "move-on-aptos.movefmt.extraArgs": [],
}
```

Formatting on Save can be enabled in VSCode with

```json5
{
    "editor.formatOnSave": true,
}
```

## Debugging

It's useful to enable INFO logging level, it's not very chatty and could provide with a valuable information to debug:

```
    "move-on-aptos.server.extraEnv": { "RA_LOG": "info" },
```

## Additional commands

### `aptos-language-server diagnostics`

Run server diagnostics on the file (or package directory). If `--apply-fixes` is provided, automatically applies available autofixes:

[See available diagnostics with auto-fixes](#code-suggestions-with-fixes)

```shell
  $ aptos-language-server diagnostics --apply-fixes replace-with-method-call ./aptos-stdlib/sources/cryptography/keyless.move 
processing package 'aptos-stdlib', file: /home/mkurnikov/code/aptos-core/aptos-move/framework/aptos-stdlib/sources/cryptography/keyless.move
note[replace-with-method-call]: Can be replaced with method call
   ‚îå‚îÄ /home/mkurnikov/code/aptos-core/aptos-move/framework/aptos-stdlib/sources/cryptography/keyless.move:67:17
   ‚îÇ
67 ‚îÇ         assert!(string::bytes(&iss).length() <= MAX_ISSUER_UTF8_BYTES_LENGTH, error::invalid_argument(E_INVALID_ISSUER_UTF8_BYTES_LENGTH));
   ‚îÇ                 ^^^^^^^^^^^^^^^^^^^
   ‚îÇ
   ‚îå‚îÄ /home/mkurnikov/code/aptos-core/aptos-move/framework/aptos-stdlib/sources/cryptography/keyless.move:67:17
   ‚îÇ
67 ‚îÇ         assert!(iss.bytes().length() <= MAX_ISSUER_UTF8_BYTES_LENGTH, error::invalid_argument(E_INVALID_ISSUER_UTF8_BYTES_LENGTH));
   ‚îÇ                 ^^^^^^^^^^^ after fix


```

## Code suggestions (with fixes)

### Use method call notation

**Code**: `replace-with-method-call`

![Replace with method call](~/images/move-vscode-extension/replace_with_method_call.gif)

### Use compound assignment expression

**Code**: `replace-with-compound-expr`

![Compound assignment expression](~/images/move-vscode-extension/compound_expr.gif)

### Use vector index expr

**Code**: `replace-with-index-expr`

Detects expressions of form `*vector::borrow(&some_vector, index)` and `*some_vector.borrow(index)`,
which can be converted to `some_vector[index]`.

![Vector index expression](~/images/move-vscode-extension/vector_index_expr.gif)

### Use field initialization shorthand

**Code**: `use-struct-lit-field-shorthand`, `use-struct-pat-field-shorthand`, `use-schema-lit-field-shorthand`

Detects struct literal fields which could be written in shorthand form.

![Field initialization shorthand](~/images/move-vscode-extension/field_shorthand.gif)

### Redundant integer type cast

**Code**: `remove-redundant-cast`

Detects expressions like `number as u8`, where `number` is already of type it's being casted to.

![Redundant integer type cast](~/images/move-vscode-extension/redundant_cast.gif)

### Add `_` prefix to the variable name

**Code**: `rename-with-underscore-prefix`

Prefixes unused variable with `_`.

![Rename with underscore prefix](~/images/move-vscode-extension/rename_fix.gif)

## Roadmap

- More error highlighting:
  - Implement more errors from the Aptos Move compiler (like ability checking)
  - Implement lints from the `aptos move lint` with extension-provided quickfixes.

- Working with imports:
  - Detect unused imports and remove them with "Organize Imports" VSCode feature.
  - Show completion items not imported in the current module, create `use` statements for those automatically.

- Integration with the `aptos-cli` commands: compile packages, publishing modules and executing transactions.

- `Move.toml` support.

- AI integration (via MCP server).

# Creating objects

> Master object creation patterns, ownership models, and lifecycle management in Aptos Move development.

import { Aside } from '@astrojs/starlight/components';

Creating an Object involves two steps:

1. Creating the `ObjectCore` resource group (which has an address you can use to refer to the Object later).
2. Customizing how the Object will behave using permissions called `Ref`s.

<Aside type="note">
  Configuring an Object by generating `Ref`s has to happen in the same
  transaction you create it. Later on it is impossible to change those settings.
</Aside>

## Creating an Object

There are three types of Object you can create:

1. A **normal Object.** This type is deletable and has a random address. You can create it using: `0x1::object::create_object(owner_address: address)`. For example:

```move filename="object_playground.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object;

  entry fun create_my_object(caller: &signer) {
    let caller_address = signer::address_of(caller);
    let constructor_ref = object::create_object(caller_address);
    // ...
  }
}
```

2. A **named Object.** This type is **not** deletable and has a deterministic address. You can create it by using: `0x1::object::create_named_object(creator: &signer, seed: vector<u8>)`. For example:

```move filename="object_playground.move"
module my_addr::object_playground {
  use std::signer;
  use aptos_framework::object;

  /// Seed for my named object, must be globally unique to the creating account
  const NAME: vector<u8> = b"MyAwesomeObject";

  entry fun create_my_object(caller: &signer) {
    let caller_address = signer::address_of(caller);
    let constructor_ref = object::create_named_object(caller, NAME);
    // ...
  }

  #[view]
  fun has_object(creator: address): bool {
    let object_address = object::create_object_address(&creator, NAME);
