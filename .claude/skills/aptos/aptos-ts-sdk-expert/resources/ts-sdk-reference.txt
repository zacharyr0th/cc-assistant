# TypeScript SDK

> Official TypeScript SDK for building applications on Aptos - the most comprehensive and up-to-date SDK

import { CardGrid, LinkCard } from '@astrojs/starlight/components';

import { RemoteCodeblock } from '~/components/RemoteCodeblock';

<div className="flex gap-2 mt-6 flex-wrap">
  <a target="_blank" href="https://github.com/aptos-labs/aptos-ts-sdk">
    ![Github Repo Stars](https://img.shields.io/github/stars/aptos-labs/aptos-ts-sdk)
  </a>

  <a target="_blank" href="https://www.npmjs.com/package/@aptos-labs/ts-sdk">
    ![NPM Version](https://img.shields.io/npm/v/%40aptos-labs%2Fts-sdk)
  </a>

  <a target="_blank" href="https://www.npmjs.com/package/@aptos-labs/ts-sdk">
    ![Node Version](https://img.shields.io/node/v/%40aptos-labs%2Fts-sdk)
  </a>

  <a target="_blank" href="https://www.npmjs.com/package/@aptos-labs/ts-sdk">
    ![NPM bundle size](https://img.shields.io/bundlephobia/min/%40aptos-labs/ts-sdk)
  </a>

  <a target="_blank" href="https://aptos-labs.github.io/aptos-ts-sdk/@aptos-labs/ts-sdk-latest">
    ![Static Badge](https://img.shields.io/badge/SDK_Reference-Docs)
  </a>
</div>

The TypeScript SDK allows you to connect, explore, and interact on the Aptos blockchain. You can use it to request data, send transactions, set up test environments, and more!

```shellscript npm2yarn
npm i @aptos-labs/ts-sdk
```

## Examples

<CardGrid>
  <LinkCard href="/build/sdks/ts-sdk/quickstart" title="Quickstart" description="See the quickstart to get a working demo in < 5 minutes" />

  <LinkCard href="https://github.com/aptos-labs/aptos-ts-sdk/tree/main/examples/typescript" title="20+ Examples" description="Explore all of the TypeScript examples provided in the SDK repository" target="_blank" />

  <LinkCard href="https://github.com/aptos-labs/aptos-ts-sdk/tree/main/tests/e2e" title="Comprehensive Tests" description="See end to end tests which demonstrate how to use each feature of the SDK" target="_blank" />
</CardGrid>

### Transfer APT in 10 lines or less

<RemoteCodeblock permalink="https://github.com/aptos-labs/aptos-ts-sdk/blob/bcde1e3af2f09615015c774fb0c2f5206377346e/examples/typescript/simple_transfer.ts#L77-L91" />

# Creating and Managing Accounts

> Learn how to generate, fund, and manage Aptos accounts using the TypeScript SDK with different signing schemes

import { Aside } from '@astrojs/starlight/components';

There are several ways to generate account credentials using the TypeScript SDK. You can use:

- `Account.generate()`
- `Account.fromPrivateKey()`
- `Account.fromDerivationPath()`

`Account.generate()` is the most commonly used method to create keys for a new account.
It defaults to `ED25519` key encodings, but you can also manually specify which signing scheme you would prefer like so:

```typescript
const account = Account.generate(); // defaults to Legacy Ed25519
const account = Account.generate({ scheme: SigningSchemeInput.Secp256k1Ecdsa }); // Single Sender Secp256k1
const account = Account.generate({
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
}); // Single Sender Ed25519
```

<Aside type="note">
  Following [AIP-55](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-55.md) the SDK supports `Legacy` and `Unified` authentications. `Legacy` includes `ED25519` and `MultiED25519` and `Unified` includes `SingleSender` and `MultiSender` authenticators.
</Aside>

Once you have generated credentials, you **must** fund it for the network to know it exists.

In localnet / devnet this can be done with a faucet by running the following command:

```typescript filename="fund.ts"
const transaction = await aptos.fundAccount({
  accountAddress: account.accountAddress,
  amount: 100,
});
```

For testnet you can use the mint page [here](/network/faucet).

## Other Ways To Represent Accounts

If you have a private key, or equivalent representation, you can use that to create an `Account` object to manage those credentials while using the TypeScript SDK.

Here are several examples that show how to do so with specific encoding schemes.

### Derive an account from private key

The SDK supports deriving an account from a private key with `fromPrivateKey()` static method.
In addition, this method supports deriving an account from a private key and account address.
This method uses a local calculation and therefore is used to derive an `Account` that has not had its authentication key rotated.

```typescript
// to derive an account with a legacy Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a Single Sender Ed25519 key scheme
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey, legacy: false });

// to derive an account with a Single Sender Secp256k1 key scheme
const privateKey = new Secp256k1PrivateKey(privateKeyBytes);
const account = Account.fromPrivateKey({ privateKey });

// to derive an account with a private key and account address
const privateKey = new Ed25519PrivateKey(privateKeyBytes);
const address = AccountAddress.from(address);
const account = Account.fromPrivateKey({ privateKey, address });
```

### Derive an account from derivation path

The SDK supports deriving an account from derivation path with `fromDerivationPath()` static method.

```typescript
// to derive an account with a legacy Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
});

// to derive an account with a Single Sender Ed25519 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
});

// to derive an account with a Single Sender Secp256k1 key scheme
const { mnemonic, address, path } = wallet;
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Secp256k1Ecdsa,
});
```

# Account Abstraction

> Implement custom transaction authentication logic through Move modules with Aptos Account Abstraction

import { Aside, Steps } from '@astrojs/starlight/components';

Account Abstraction (AA) on Aptos **enables custom transaction authentication logic through Move modules**, allowing accounts to define their own rules beyond native cryptographic schemes. **Note:** This is currently only live on testnet as of July 17, 2025.

## Core Concepts

### `FunctionInfo`

A struct defining the authentication function to be invoked.

```move
struct FunctionInfo has copy, drop, store {
    module_address: address,
    module_name: String,
    function_name: String
}
```

The authentication function is responsible for defining the authentication logic using Move. It should return a signer if authentication is successful, otherwise it aborts the transaction.
The only accepted authentication function signature that can be added onto an account is the following:

```move
// The function can return a signer if authentication is successful, otherwise it aborts the transaction.
public fun authenticate(account: signer, auth_data: AbstractionAuthData): signer;
```

**Example (Move)**

```move
module deployer::authenticator {
    use aptos_framework::auth_data::{AbstractionAuthData};

    public fun authenticate(account: signer, auth_data: AbstractionAuthData): signer {
        // ... authentication logic ...
        account
    }
}
```

**Example (Typescript)**

```typescript
const authenticationFunction = `${deployer}::authenticator::authenticate`;
```

### `AbstractionAuthData`

An enum variant defining the authentication data to be passed to the authentication function. It contains:

- `digest`: The sha256 hash of the signing message.
- `authenticator`: Abstract bytes that will be passed to the authentication function that will be used to verify the transaction.

```move
enum AbstractionAuthData has copy, drop {
    V1 { 
        digest: vector<u8>,       // SHA3-256 hash of the signing message
        authenticator: vector<u8> // Custom auth data (e.g., signatures)
    },
}
```

**Why is the `digest` important?**

The `digest` is checked by the MoveVM to ensure that the signing message of the transaction being submitted is the same as the one presented in the `AbstractionAuthData`. This
is important because it allows the authentication function to verify signatures with respect to the correct transaction.

For example, if you want to permit a public key to sign transactions on behalf of the user, you can permit the public key to sign a transaction with a specific payload.
However, if a malicious user sends a signature for the correct public key but a different payload from the `digest`, the signature will not be valid.

**Example (Move)**

This example demonstrates a simple authentication logic that checks if the authenticator is equal to `"hello world"`.

```move
module deployer::hello_world_authenticator {
    use aptos_framework::auth_data::{Self, AbstractionAuthData};

    public fun authenticate(
        account: signer,
        auth_data: AbstractionAuthData
    ): signer {
        let authenticator = *auth_data::authenticator(&auth_data);
        assert!(authenticator == b"hello world", 1);
        account
    }
}
```

**Example (Typescript)**

```typescript
const abstractedAccount = new AbstractedAccount({
  /**
   * The result of the signer function will be available as the `authenticator` field in the `AbstractionAuthData` enum variant.
   */
  signer: () => new TextEncoder().encode("hello world"),
  /**
   * The authentication function to be invoked.
   */
  authenticationFunction: `${deployer}::hello_world_authenticator::authenticate`,
});
```

## Minimal Step-by-Step Guide

<Steps>
  1. 1. Deploy Authentication Module

     In this example, we will deploy the `hello_world_authenticator` module. The `authenticate` function takes an `AbstractionAuthData` and returns a `signer`
     if the authentication is successful, otherwise it aborts the transaction. The authentication logic will only allow transactions that have an authenticator equal to `"hello world"`.

     ```move
     module deployer::hello_world_authenticator {
         use aptos_framework::auth_data::{Self, AbstractionAuthData};
         use std::bcs;

         public fun authenticate(
             account: signer,
             auth_data: AbstractionAuthData
         ): signer {
             let authenticator = *auth_data::authenticator(&auth_data);
             assert!(authenticator == b"hello world", 1);
             account
         }
     }
     ```

     To deploy the module, you can use the following commands from the [Aptos CLI](/build/cli). We assume that you already have set up a workspace with `aptos init` and
     declared the named addresses in your `Move.toml` file.

     ```shellscript
     aptos move publish --named-addresses deployer=0x1234567890123456789012345678901234567890
     ```

  2. 2. Setup your Environment

     Once deployed, you can setup your environment. In this example, we will use Devnet and create an account named `alice` which will act as our user.

     ```typescript
     const DEPLOYER = "0x<hello_world_authenticator_deployer>"

     const aptos = new Aptos(new AptosConfig({ network: Network.DEVNET }));

     const alice = Account.generate();

     const authenticationFunctionInfo = `${deployer}::hello_world_authenticator::authenticate`;
     ```

  3. 3. (Optional) Check if Account Abstraction is Enabled

     Before you ask them to enable account abstraction, you can check if the account has account abstraction enabled by calling the `isAccountAbstractionEnabled` function.
     This will return a boolean value indicating if the account has account abstraction enabled.

     ```typescript
     const accountAbstractionStatus = await aptos.abstraction.isAccountAbstractionEnabled({
         accountAddress: alice.accountAddress,
         authenticationFunction,
     });

     console.log("Account Abstraction status: ", accountAbstractionStatus);
     ```

  4. 4. Enable the Authentication Function

     Assuming that the account does not have account abstraction enabled, you need to enable the authentication function for the account. This can be done by calling
     the `enableAccountAbstractionTransaction` function. This creates a raw transaction that needs to be signed and submitted to the network. In this example, `alice`
     will be the account that will be enabled.

     ```typescript
     const transaction = aptos.abstraction.enableAccountAbstractionTransaction({
       accountAddress: alice.accountAddress,
       authenticationFunction: `${deployer}::hello_world_authenticator::authenticate`,
     });

     const pendingTransaction = await aptos.signAndSubmitTransaction({
       transaction,
       signer: alice.signer,
     });

     await aptos.waitForTransaction({ hash: pendingTransaction.hash });

     console.log("Account Abstraction enabled for account: ", alice.accountAddress);
     ```

     <details>
       <summary>
         <b>Wallet Adapter Example</b>
       </summary>

       <Aside type="note">
         If you are using the wallet adapter, you can use the `signTransaction` function to sign the transaction before submitting it to the network.
       </Aside>

       ```tsx
       export default function useEnableAbstraction() {
         const { account, signTransaction } = useWallet();

         return {
           enableAbstraction: async () => {
             if (!account) return;

             // Note: The Aptos client must be defined somewhere in the application.
             const transaction = aptos.abstraction.enableAccountAbstractionTransaction({
               accountAddress: account.address,
               authenticationFunction: `${deployer}::hello_world_authenticator::authenticate`,
             });

             const senderAuthenticator = await signTransaction(txn);

             const pendingTxn = await aptos.transaction.submit.simple({
               transaction: txn,
               senderAuthenticator,
             });

             return await aptos.waitForTransaction({ hash: pendingTxn.hash });
           }
         }
       }
       ```
     </details>

  5. 5. Create an Abstracted Account

     Once the authentication function is enabled, you can create an abstracted account object for signing transactions. You must provide the authentication function that will be used to verify the transaction
     and a `signer` function that will be used to sign the transaction. The `signer` function is responsible for generating the authenticator that will be passed to the authentication function.

     ```typescript
     const abstractedAccount = new AbstractedAccount({
       accountAddress: alice.accountAddress,
       signer: () => new TextEncoder().encode("hello world"),
       authenticationFunction: `${deployer}::hello_world_authenticator::authenticate`,
     });
     ```

  6. 6. Sign and Submit a Transaction using the Abstracted Account

     Once you have created the abstracted account, you can use it to sign transactions normally. It is important that the `sender` field in the transaction
     is the same as the abstracted account's address.

     ```typescript
     const coinTransferTransaction = await aptos.transaction.build.simple({
       sender: abstractedAccount.accountAddress,
       data: {
         function: "0x1::coin::transfer",
         typeArguments: ["0x1::aptos_coin::AptosCoin"],
         functionArguments: [alice.accountAddress, 100],
       },
     });

     const pendingCoinTransferTransaction = await aptos.transaction.signAndSubmitTransaction({
       transaction: coinTransferTransaction,
       signer: abstractedAccount,
     });

     await aptos.waitForTransaction({ transactionHash: pendingCoinTransferTransaction.hash });

     console.log("Coin transfer transaction submitted! ", pendingCoinTransferTransaction.hash);
     ```

  7. 7. Conclusion

     To verify that you have successfully sign and submitted the transaction using the abstracted account, you can use the explorer to check the transaction. If the
     transaction signature contains a `function_info` and `auth_data` field, it means you successfully used account abstraction! The full E2E demo can be found [here](https://github.com/aptos-labs/aptos-ts-sdk/blob/main/examples/typescript/public_key_authenticator_account_abstraction.ts).

     ![Transaction Signature](~/images/account-abstraction/minimal-guide-transaction-signature.png)
</Steps>

## Complex Step-by-Step Guide

Now that you have a basic understanding of how account abstraction works, let's dive into a more complex example.

In this example, we will create an authenticator that allows users to permit certain public keys to sign transactions on behalf of the abstracted account.

<Steps>
  1. 1. Create an Authenticator module

     We will deploy the `public_key_authenticator` module that does two things:

     - Allow users to permit and/or revoke public keys from signing on behalf of the user.
     - Allow users to authenticate on behalf of somebody else using account abstraction.

     ```move
     module deployer::public_key_authenticator {
         use std::signer;
         use aptos_std::smart_table::{Self, SmartTable};
         use aptos_std::ed25519::{
             Self,
             new_signature_from_bytes,
             new_unvalidated_public_key_from_bytes,
             unvalidated_public_key_to_bytes
         };
         use aptos_framework::bcs_stream::{Self, deserialize_u8};
         use aptos_framework::auth_data::{Self, AbstractionAuthData};

         // ====== Error Codes ====== //

         const EINVALID_PUBLIC_KEY: u64 = 0x20000;
         const EPUBLIC_KEY_NOT_PERMITTED: u64 = 0x20001;
         const EENTRY_ALREADY_EXISTS: u64 = 0x20002;
         const ENO_PERMISSIONS: u64 = 0x20003;
         const EINVALID_SIGNATURE: u64 = 0x20004;

         // ====== Data Structures ====== //

         struct PublicKeyPermissions has key {
             public_key_table: SmartTable<vector<u8>, bool>,
         }

         // ====== Authenticator ====== //

         public fun authenticate(
             account: signer,
             auth_data: AbstractionAuthData
         ): signer acquires PublicKeyPermissions {
             let account_addr = signer::address_of(&account);
             assert!(exists<PublicKeyPermissions>(account_addr), ENO_PERMISSIONS);
             let permissions = borrow_global<PublicKeyPermissions>(account_addr);

             // Extract the public key and signature from the authenticator
             let authenticator = *auth_data::authenticator(&auth_data);
             let stream = bcs_stream::new(authenticator);
             let public_key = new_unvalidated_public_key_from_bytes(
                 bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x))
             );
             let signature = new_signature_from_bytes(
                 bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x))
             );

             // Check if the public key is permitted
             assert!(smart_table::contains(&permissions.public_key_table, unvalidated_public_key_to_bytes(&public_key)), EPUBLIC_KEY_NOT_PERMITTED);

             // Verify the signature
             let digest = *auth_data::digest(&auth_data);
             assert!(ed25519::signature_verify_strict(&signature, &public_key, digest), EINVALID_SIGNATURE);

             account
         }

         // ====== Core Functionality ====== //

         public entry fun permit_public_key(
             signer: &signer,
             public_key: vector<u8>
         ) acquires PublicKeyPermissions {
             let account_addr = signer::address_of(signer);
             assert!(std::vector::length(&public_key) == 32, EINVALID_PUBLIC_KEY);
             
             if (!exists<PublicKeyPermissions>(account_addr)) {
                 move_to(signer, PublicKeyPermissions {
                     public_key_table: smart_table::new(),
                 });
             };

             let permissions = borrow_global_mut<PublicKeyPermissions>(account_addr);
             assert!(
                 !smart_table::contains(&permissions.public_key_table, public_key), 
                 EENTRY_ALREADY_EXISTS
             );

             smart_table::add(&mut permissions.public_key_table, public_key, true);
         
         }

         public entry fun revoke_public_key(
             signer: &signer,
             public_key: vector<u8>
         ) acquires PublicKeyPermissions {
             let account_addr = signer::address_of(signer);
             
             assert!(exists<PublicKeyPermissions>(account_addr), ENO_PERMISSIONS);

             let permissions = borrow_global_mut<PublicKeyPermissions>(account_addr);
             smart_table::remove(&mut permissions.public_key_table, public_key);
         }

     }
     ```

     Let's break down the module...

     **Storing Public Keys**

     The `PublicKeyPermissions` struct is a key that contains a `SmartTable` of public keys that determines
     whether a public key is permitted to sign transactions on behalf of the user.

     ```move
     module deployer::public_key_authenticator {
       // ...
      
       struct PublicKeyPermissions has key {
           public_key_table: SmartTable<vector<u8>, bool>,
       } 
       
     }
     ```

     **Permitting and Revoking Public Keys**

     We define two entry functions to permit and revoke public keys. These functions are used to add and remove public keys from the `PublicKeyPermissions` struct.

     ```move
     module deployer::public_key_authenticator {
       // ...

           public entry fun permit_public_key(
             signer: &signer,
             public_key: vector<u8>
         ) acquires PublicKeyPermissions {
             let account_addr = signer::address_of(signer);
             assert!(std::vector::length(&public_key) == 32, EINVALID_PUBLIC_KEY);
             
             if (!exists<PublicKeyPermissions>(account_addr)) {
                 move_to(signer, PublicKeyPermissions {
                     public_key_table: smart_table::new(),
                 });
             };

             let permissions = borrow_global_mut<PublicKeyPermissions>(account_addr);
             assert!(
                 !smart_table::contains(&permissions.public_key_table, public_key), 
                 EENTRY_ALREADY_EXISTS
             );

             smart_table::add(&mut permissions.public_key_table, public_key, true);
         
         }

         public entry fun revoke_public_key(
             signer: &signer,
             public_key: vector<u8>
         ) acquires PublicKeyPermissions {
             let account_addr = signer::address_of(signer);
             
             assert!(exists<PublicKeyPermissions>(account_addr), ENO_PERMISSIONS);

             let permissions = borrow_global_mut<PublicKeyPermissions>(account_addr);
             smart_table::remove(&mut permissions.public_key_table, public_key);
         }
     }
     ```

     **Authenticating on behalf of somebody else**

     The `authenticate` function is the main function that allows users to authenticate on behalf of somebody else using account abstraction. The `authenticator`
     will contain the **public key** and a **signature** of the user. We will verify that the public key is permitted and that the signature is valid.

     The signature is the result of signing the `digest`. The `digest` is the sha256 hash of the **signing message** which contains information about the transaction.
     By signing the `digest`, we confirm that the user has approved the specific transaction that was submitted.

     ```move
     module deployer::public_key_authenticator {
         // ...

         public fun authenticate(
             account: signer,
             auth_data: AbstractionAuthData
         ): signer acquires PublicKeyPermissions {
             let account_addr = signer::address_of(&account);
             assert!(exists<PublicKeyPermissions>(account_addr), ENO_PERMISSIONS);
             let permissions = borrow_global<PublicKeyPermissions>(account_addr);

             // Extract the public key and signature from the authenticator
             let authenticator = *auth_data::authenticator(&auth_data);
             let stream = bcs_stream::new(authenticator);
             let public_key = new_unvalidated_public_key_from_bytes(
                 bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x))
             );
             let signature = new_signature_from_bytes(
                 bcs_stream::deserialize_vector<u8>(&mut stream, |x| deserialize_u8(x))
             );

             // Check if the public key is permitted
             assert!(smart_table::contains(&permissions.public_key_table, unvalidated_public_key_to_bytes(&public_key)), EPUBLIC_KEY_NOT_PERMITTED);

             // Verify the signature
             let digest = *auth_data::digest(&auth_data);
             assert!(ed25519::signature_verify_strict(&signature, &public_key, digest), EINVALID_SIGNATURE);

             account
         }
     }
     ```

     To deploy the module, you can use the following commands from the [Aptos CLI](/build/cli). We assume that you already have set up a workspace with `aptos init` and
     declared the named addresses in your `Move.toml` file.

     ```shellscript
     aptos move publish --named-addresses deployer=0x1234567890123456789012345678901234567890
     ```

  2. 2. Setup your Environment

     Once deployed, you can setup your environment. In this example, we will use Devnet and create an account named `alice` as the user that will be authenticated on behalf of
     and `bob` as the user that will be permitted to sign transactions on behalf of `alice`.

     ```typescript
     const DEPLOYER = "0x<public_key_authenticator_deployer>"

     const aptos = new Aptos(new AptosConfig({ network: Network.DEVNET }));

     const alice = Account.generate();
     const bob = Account.generate();

     const authenticationFunctionInfo = `${deployer}::public_key_authenticator::authenticate`;
     ```

  3. 3. (Optional) Check if Account Abstraction is Enabled

     Before we enable the authentication function, we can check if the account has account abstraction enabled by calling the `isAccountAbstractionEnabled` function.
     This will return a boolean value indicating if the account has account abstraction enabled.

     ```typescript
     const accountAbstractionStatus = await aptos.abstraction.isAccountAbstractionEnabled({
         accountAddress: alice.accountAddress,
         authenticationFunction,
     });

     console.log("Account Abstraction status: ", accountAbstractionStatus);
     ```

  4. 4. Enable the Authentication Function

     Assuming that the account does not have account abstraction enabled, we need to enable the authentication function for the account. This can be done by calling
     the `enableAccountAbstractionTransaction` function. This creates a raw transaction that needs to be signed and submitted to the network. In this example, `alice`
     will be the account that will be enabled.

     ```typescript
     const transaction = await aptos.abstraction.enableAccountAbstractionTransaction({
       accountAddress: alice.accountAddress,
       authenticationFunction,
     });

     const pendingTransaction = await aptos.signAndSubmitTransaction({
       transaction,
       signer: alice.signer,
     });

     await aptos.waitForTransaction({ hash: pendingTransaction.hash });

     console.log("Account Abstraction enabled for account: ", alice.accountAddress);
     ```

  5. 5. Permit Bob's Public Key

     Now that we have enabled the authentication function, we can permit `bob`'s public key to sign transactions on behalf of `alice`.

     ```typescript
     const enableBobPublicKeyTransaction = await aptos.transaction.build.simple({
         sender: alice.accountAddress,
         data: {
           function: `${alice.accountAddress}::public_key_authenticator::permit_public_key`,
           typeArguments: [],
           functionArguments: [bob.publicKey.toUint8Array()],
         },
       });

     const pendingEnableBobPublicKeyTransaction = await aptos.signAndSubmitTransaction({
       signer: alice,
       transaction: enableBobPublicKeyTransaction,
     });

     await aptos.waitForTransaction({ hash: pendingEnableBobPublicKeyTransaction.hash });

     console.log(`Enable Bob's public key transaction hash: ${pendingEnableBobPublicKeyTransaction.hash}`);
     ```

  6. 6. Create an Abstracted Account

     Now that we have permitted `bob`'s public key, we can create an abstracted account that will be used to sign transactions on behalf of `alice`.
     **Notice that the `signer` function uses `bob`'s signer.**

     ```typescript
     const abstractedAccount = new AbstractedAccount({
       accountAddress: alice.accountAddress,
       signer: (digest) => {
           const serializer = new Serializer();
           bob.publicKey.serialize(serializer);
           bob.sign(digest).serialize(serializer);
           return serializer.toUint8Array();
       },
       authenticationFunction,
     });
     ```

  7. 7. Sign and Submit a Transaction using the Abstracted Account

     Now that we have created the abstracted account, we can use it to sign transactions normally. It is important that the `sender` field in the transaction
     is the same as the abstracted account's address.

     ```typescript
     const coinTransferTransaction = new aptos.transaction.build.simple({
       sender: abstractedAccount.accountAddress,
       data: {
         function: "0x1::coin::transfer",
         typeArguments: ["0x1::aptos_coin::AptosCoin"],
         functionArguments: [alice.accountAddress, 100],
       },
     });

     const pendingCoinTransferTransaction = await aptos.transaction.signAndSubmitTransaction({
       transaction: coinTransferTransaction,
       signer: abstractedAccount,
     });

     await aptos.waitForTransaction({ hash: pendingCoinTransferTransaction.hash });

     console.log("Coin transfer transaction submitted! ", pendingCoinTransferTransaction.hash);
     ```

  8. 8. Conclusion

     To verify that you have successfully sign and submitted the transaction using the abstracted account, you can use the explorer to check the transaction. If the
     transaction signature contains a `function_info` and `auth_data` field, it means you successfully used account abstraction! The full E2E demo can be found [here](https://github.com/aptos-labs/aptos-ts-sdk/blob/main/examples/typescript/public_key_authenticator_account_abstraction.ts)

     ![Transaction Signature](~/images/account-abstraction/complex-guide-transaction-signature.png)
</Steps>

## Management Operations

If you want to disable account abstraction for an account, you can use the `disableAccountAbstractionTransaction`. If you do not specify an authentication function,
the transaction will disable all authentication functions for the account.

```typescript
const transaction = aptos.abstraction.disableAccountAbstractionTransaction({
  accountAddress: alice.accountAddress,
  /**
   * The authentication function to be disabled. If left `undefined`, all authentication functions will be disabled.
  */
  authenticationFunction,
});
```

## Application User Experience

Applications that want to leverage account abstraction will want to provide a user experience that allows users to check if the account has account abstraction enabled,
and to enable it, if it is not enabled.

Below is a diagram of the UX flow for enabling account abstraction.

![Account Abstraction UX](~/images/account-abstraction/account-abstraction-ux.png)

# Derivable Account Abstraction

> Enable deterministic account address derivation with custom authentication schemes using Derivable Account Abstraction

import { Steps } from '@astrojs/starlight/components';

[Derivable Account Abstraction (DAA)](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-113.md)
is a standard for account abstraction that enables custom authentication schemes by registering a `derivable_authentication_function`.

DAA differs from vanilla [Account Abstraction (AA)](/build/sdks/ts-sdk/account/account-abstraction) in that, for a given `derivable_authentication_function`,
it defines how to deterministically derive the account address from an `abstract_public_key`, which can be done off-chain.

In contrast, vanilla AA is enabled for a specific pre-existing account by explicitly registering an on-chain `authentication_function`
and submitting a transaction, which involves extra steps and costs gas for each account.

This allows registering secondary authentication schemes with identical user experience to the native ones.
More specifically, this provides a flexible and secure way to manage cross-chain signatures. (see [x-chain accounts](/build/sdks/wallet-adapter/x-chain-accounts))

## Core Concepts

### Authentication function

DAA works by defining an custom authentication scheme and registering a valid authentication function to perform on-chain authentication.

Each abstract account should have an associated `abstract_public_key` and should be able to produce `abstract_signature`s
whose formats depend on the authentication scheme.

Simply put, the `derivable_authentication_function` needs to check that:

- the `abstract_signature` is valid for the given `abstract_public_key`
- the `abstract_signature` depends on the transaction's digest

```move
// The function should return a signer if authentication is successful, otherwise it aborts the execution
public fun authenticate(account: signer, auth_data: AbstractionAuthData): signer;
```

The DAA framework automatically checks whether the address derived from `abstract_public_key` matches with the signer's address.

### Authentication data

`AbstractionAuthData` is an enum that represent the authentication data to be passed to custom authentication functions.
It's used in all flavors of AA, but the `DerivableV1` variant defines the following fields:

- `digest`: The SHA3-256 hash of the signing message.
- `abstract_signature`: Abstract signature bytes that need to be verified against `abstract_public_key`.
- `abstract_public_key`: Abstract public key bytes associated to the abstract account

Here's what the Move enum looks like:

```move
enum AbstractionAuthData has copy, drop {
  V1 { ... }, // Only applicable to vanilla AA
  DerivableV1 {
      digest: vector<u8>, // SHA3-256 hash of the signing message
      abstract_signature: vector<u8>,
      abstract_public_key: vector<u8>,
  }
}
```

**Why is the `digest` important?**

The `digest` is checked by the MoveVM to ensure that the signing message of the transaction being submitted is the same as the one presented in the `AbstractionAuthData`. This
is important because it allows the authentication function to verify signatures with respect to the correct transaction.

For example, if you want to permit a public key to sign transactions on behalf of the user, you can permit the public key to sign a transaction with a specific payload.
However, if a malicious user sends a signature for the correct public key but a different payload from the `digest`, the signature will not be valid.

### Account address derivation

With DAA, a given `derivable_authentication_function` defines a space of account addresses that can be deterministically derived from their associated `abstract_public_key`.

The on-chain function looks like the following:

```move
public fun derive_account_address(derivable_func_info: FunctionInfo, abstract_public_key: &vector<u8>): address {
  let bytes = bcs::to_bytes(&derivable_func_info);
  bytes.append(bcs::to_bytes(abstract_public_key));
  bytes.push_back(DERIVABLE_ABSTRACTION_DERIVED_SCHEME);
  from_bcs::to_address(hash::sha3_256(bytes))
}
```

where `FunctionInfo` is a fully qualified identifier for a on-chain function:

```move
struct FunctionInfo has copy, drop, store {
    module_address: address,
    module_name: String,
    function_name: String
}
```

The address derivation depends on the authentication function's identifier and on a DAA-specific domain separator.
Because of this, each address space is isolated from the others and it's not possible for the same account to have multiple
authentication functions.

**Example (Move)**

This example demonstrates domain account abstraction using ed25519 hex for signing.

```move
module aptos_experimental::test_derivable_account_abstraction_ed25519_hex {
    use std::error;
    use aptos_std::string_utils;
    use aptos_std::ed25519::{
        Self,
        new_signature_from_bytes,
        new_unvalidated_public_key_from_bytes,
    };
    use aptos_framework::auth_data::AbstractionAuthData;

    const EINVALID_SIGNATURE: u64 = 1;

    /// Authorization function for derivable account abstraction.
    public fun authenticate(account: signer, aa_auth_data: AbstractionAuthData): signer {
    let hex_digest = string_utils::to_string(aa_auth_data.digest());

    let public_key = new_unvalidated_public_key_from_bytes(*aa_auth_data.derivable_abstract_public_key());
    let signature = new_signature_from_bytes(*aa_auth_data.derivable_abstract_signature());
    assert!(
        ed25519::signature_verify_strict(
            &signature,
            &public_key,
            *hex_digest.bytes(),
        ),
        error::permission_denied(EINVALID_SIGNATURE)
    );

    account
    }
}
```

**Example (Typescript)**

```typescript
const derivableAbstractedAccount = new DerivableAbstractedAccount({
  /**
   * The result of the signer function will be available as the `abstract_signature` field in the `AbstractionAuthData` enum variant.
   */
  signer: (digest) => {
    const hexDigest = new TextEncoder().encode(Hex.fromHexInput(digest).toString());
    return solanaAccount.sign(hexDigest).toUint8Array();
  },
  /**
   * The authentication function to be invoked.
   */
  authenticationFunction: `0x7::test_derivable_account_abstraction_ed25519_hex::authenticate`,
  /**
  * The abstract public key (i.e the account identity)
  */
  abstractPublicKey: account.publicKey.toUint8Array(),
});
```

## Minimal Step-by-Step Guide

<Steps>
  1. 1. Generate a ED25519 key pair

     ```typescript
     const ed25519Account = Account.generate();
     ```

  2. 2. Create a DAA

     ```typescript
     const daa = new DerivableAbstractedAccount({
       signer: (digest) => {
         const hexDigest = new TextEncoder().encode(Hex.fromHexInput(digest).toString());
         return ed25519Account.sign(hexDigest).toUint8Array();
       },
       authenticationFunction: `0x7::test_derivable_account_abstraction_ed25519_hex::authenticate`,
       abstractPublicKey: ed25519Account.publicKey.toUint8Array(),
     });
     ```

  3. 3. Fund the DAA to create it on chain

     ```typescript
     await aptos.fundAccount({ accountAddress: daa.accountAddress, amount: 1000000 });
     ```

  4. 4. Create a recipient account and transfer APT to it

     ```typescript
     const recipient = Account.generate();

     const pendingTxn = await aptos.transaction.signAndSubmitTransaction({
       signer: daa,
       transaction: await aptos.transferCoinTransaction({
         sender: daa.accountAddress,
         recipient: recipient.accountAddress,
         amount: 100,
       }),
     });

     const response = await aptos.waitForTransaction({ transactionHash: pendingTxn.hash });
     ```
</Steps>

# Building Transactions

> Comprehensive guide to building, simulating, signing, submitting, and executing transactions on Aptos using the TypeScript SDK

import { Aside, Steps } from '@astrojs/starlight/components';

Transactions allow you to change on-chain data or trigger events. Generally, transactions follow 5 steps from building to executing on chain: building, simulating, signing, submitting, and waiting.

<Aside type="note">
  For these examples, `aptos` is an instance of the [`Aptos`](https://aptos-labs.github.io/aptos-ts-sdk/@aptos-labs/ts-sdk-1.35.0/classes/Aptos.html) client object.
</Aside>

<Steps>
  1. Build

     Building a transaction is how you specify:

     1. **The `sender` account.** <br />This account normally pays the gas fees for this transaction. See [Transaction Sponsoring](/build/sdks/ts-sdk/building-transactions/sponsoring-transactions) to learn how to have another account pay for fees.
     2. **The `function` being called on-chain.** <br />This is the identifier for the smart contract entry function on-chain that will trigger when you execute this transaction.
     3. **The `functionArguments`.** <br />This is any data the function needs to run.

     This can be packaged into a `SimpleTransaction` using `aptos.transaction.build.simple(...)` like so:

     ```typescript filename="build-a-transaction.ts"
     const transaction = await aptos.transaction.build.simple({
       sender: sender.accountAddress,
       data: {
     	  // All transactions on Aptos are implemented via smart contracts.
     	  function: "0x1::aptos_account::transfer",
     	  functionArguments: [destination.accountAddress, 100],
       },
     });
     ```

     <Aside type="note">
       There is a more advanced format to pass in `functionArguments` called [Binary Canonical Serialization (BCS)](/build/sdks/ts-sdk/building-transactions/bcs-format) format which is how the Aptos chain parses function arguments. The SDK converts TypeScript primitives to BCS format behind the scenes via an API call.
     </Aside>

     #### Building Options

     You can customize the way your transaction executes by passing in `options: {...}` when building. Some of the most commonly used options are:

     1. `maxGasAmount` - This caps the amount of gas you are willing to pay for to execute this transaction.
     2. `gasUnitPrice` - You can specify a higher than minimum price per gas to be executed with higher priority by the Aptos network.
     3. `expireTimestamp` - This gives a concrete time the transaction must execute by or it will be canceled.

     The SDK provides sensible defaults for these values if they are not specified explicitly.

  2. Simulate (Optional)

     Every transaction on the Aptos chain has a gas fee associated with how much work the network machines have to do when executing the transaction. In order to estimate the cost associated with that, you can simulate transactions before committing them.

     <Aside type="note">
       This simulation only requires the `publicKey` of an account since it will not impact the actual state of the ledger.
     </Aside>

     You can execute the simulation by using `aptos.transaction.simulate.simple(...)` like so:

     ```typescript filename="build-a-transaction.ts"
     const [userTransactionResponse] = await aptos.transaction.simulate.simple({
       signerPublicKey: signer.publicKey,
       transaction,
     });
     // If the fee looks ok, continue to signing!
     ```

  3. Sign

     Once the transaction is built and the fees seem reasonable, you can sign the transaction with `aptos.transaction.sign`. The signature must come from the `sender` account.

     ```typescript filename="build-a-transaction.ts"
     // 3. Sign
     const senderAuthenticator = aptos.transaction.sign({
       signer: sender,
       transaction,
     });
     ```

  4. Submit

     Now that the transaction is signed, you can submit it to the network using `aptos.transaction.submit.simple` like so:

     ```typescript filename="build-a-transaction.ts"
     // 4. Submit
     const committedTransaction = await aptos.transaction.submit.simple({
       transaction,
       senderAuthenticator,
     });
     ```

  5. Wait

     Finally, you can wait for the result of the transaction by using [`aptos.waitForTransaction`](https://aptos-labs.github.io/aptos-ts-sdk/@aptos-labs/ts-sdk-1.35.0/classes/Aptos.html#waitForTransaction) and specifying the hash of the transaction you just submitted like so:

     ```typescript filename="build-a-transaction.ts"
     // 5. Wait
     const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });
     ```
</Steps>

## Full TypeScript Example

```typescript filename="build-a-transaction.ts"
/**
 * This example shows how to use the Aptos SDK to send a transaction.
 * Don't forget to install @aptos-labs/ts-sdk before running this example!
 */

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
} from "@aptos-labs/ts-sdk";

async function example() {
    console.log("This example will create two accounts (Alice and Bob) and send a transaction transfering APT to Bob's account.");

    // 0. Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    let alice = Account.generate();
    let bob = Account.generate();

    console.log("=== Addresses ===\n");
    console.log(`Alice's address is: ${alice.accountAddress}`);
    console.log(`Bob's address is: ${bob.accountAddress}`);

    console.log("\n=== Funding accounts ===\n");
    await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 100_000_000,
    });
    await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 100,
    });
    console.log("Funded Alice and Bob's accounts!")

    // 1. Build
    console.log("\n=== 1. Building the transaction ===\n");
    const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        data: {
        // All transactions on Aptos are implemented via smart contracts.
        function: "0x1::aptos_account::transfer",
        functionArguments: [bob.accountAddress, 100],
        },
    });
    console.log("Built the transaction!")

    // 2. Simulate (Optional)
    console.log("\n === 2. Simulating Response (Optional) === \n")
    const [userTransactionResponse] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        transaction,
    });
    console.log(userTransactionResponse)

    // 3. Sign
    console.log("\n=== 3. Signing transaction ===\n");
    const senderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
    });
    console.log("Signed the transaction!")

    // 4. Submit
    console.log("\n=== 4. Submitting transaction ===\n");
    const submittedTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator,
    });

    console.log(`Submitted transaction hash: ${submittedTransaction.hash}`);

    // 5. Wait for results
    console.log("\n=== 5. Waiting for result of transaction ===\n");
    const executedTransaction = await aptos.waitForTransaction({ transactionHash: submittedTransaction.hash });
    console.log(executedTransaction)
};

example();
```

## Summary

Building and sending transactions on-chain involves the following 5 steps:

1. **Build** the transaction.
2. **Simulate** the cost. (Optional)
3. **Sign** the transaction (if the simulated cost seems ok).
4. **Submit** the transaction to the network.
5. **Wait** for the chain to validate and update.

## Explore Advanced Transaction Features

Transactions have a couple of additional features which let them adapt to your needs which you can learn about here:

1. [Multi-Agent Transactions](/build/sdks/ts-sdk/building-transactions/multi-agent-transactions) - Allowing multiple accounts to interact with a single transaction.
2. [Orderless Transactions](/build/sdks/ts-sdk/building-transactions/orderless-transactions) - Allowing for transactions to be executed out of order for easier management.
3. [Sponsoring Transactions](/build/sdks/ts-sdk/building-transactions/sponsoring-transactions) - Have another account pay gas fees for this transaction.
4. [Batch Submit Transactions](/build/sdks/ts-sdk/building-transactions/batching-transactions) - How to send multiple transactions quickly from a single account.
5. [Binary Canonical Serialization (BCS)](/build/sdks/ts-sdk/building-transactions/bcs-format) - The format used to serialize data for Aptos transactions.
6. [Composing multiple Move calls with ScriptComposer](/build/sdks/ts-sdk/building-transactions/script-composer) - (Experimental) Building more complex transaction payload that calls into multiple Move functions dynamically.

# Batching Transactions

> Execute multiple independent transactions simultaneously from a single account using batch transaction processing

The TypeScript SDK has a built-in way to send several independent transactions together in a batch. This can be a convenient tool when trying to execute multiple transactions quickly from the same account.

This can be done with `aptos.transaction.batch.forSingleAccount` as can be seen in the below example.

## Full TypeScript Example

```typescript filename="batch.ts"
/**
 * This example shows how to use the Aptos SDK to send several transactions in a batch.
 */

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
    InputGenerateTransactionPayloadData,
} from "@aptos-labs/ts-sdk";

async function example() {
    console.log("This example will send several transactions in a batch.");

    // Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    let sender = Account.generate();

    console.log("=== Addresses ===\n");
    console.log(`Sender's address is: ${sender.accountAddress}`);

    console.log("\n=== Funding sender ===\n");
    await aptos.fundAccount({
        accountAddress: sender.accountAddress,
        amount: 100_000_000,
    });  
    console.log("Funded the sender account!")

    // Generate several recipients to send APT to
    const recipients = [Account.generate(), Account.generate(), Account.generate()];

    // Create transactions to send APT to each account
    const transactions: InputGenerateTransactionPayloadData[] = [];

    for (let i = 0; i < recipients.length; i += 1) {
        const transaction: InputGenerateTransactionPayloadData = {
            function: "0x1::aptos_account::transfer",
            functionArguments: [recipients[i].accountAddress, 10],
        };
        transactions.push(transaction);
    }

    // Sign and submit all transactions as fast as possible (throws if any error)
    await aptos.transaction.batch.forSingleAccount({ sender: sender, data: transactions });
};

example();
```

## Checking The Status of Batched Transactions

In order to tell when transaction submitted in a batch have executed on chain, you must listen to events while the process runs.

```typescript filename="transaction-worker-events.ts"
export enum TransactionWorkerEventsEnum {
  // Fired after a transaction gets sent to the chain
  TransactionSent = "transactionSent",
  // Fired if there is an error sending the transaction to the chain
  TransactionSendFailed = "transactionSendFailed",
  // Fired when a single transaction has executed successfully
  TransactionExecuted = "transactionExecuted",
  // Fired if a single transaction fails in execution
  TransactionExecutionFailed = "transactionExecutionFailed",
  // Fired when the worker has finished its job / when the queue has been emptied
  ExecutionFinish = "executionFinish",
}
```

You can find an example of how to listen to these events [here](https://github.com/aptos-labs/aptos-ts-sdk/blob/main/examples/typescript/batch_funds.ts#L108).

# BCS Format

> Learn how to use Binary Canonical Serialization (BCS) format for advanced transaction parameter handling and performance optimization

Behind the scenes, the Aptos SDK has two formats for transaction parameters:

1. **Simple** - This represents transaction parameters using primitive types like strings, integers, etc.
2. **Binary Canonical Serialization (BCS)** - This is the format the Aptos chain recognizes, with specific types (ex. Instead of an integer, it uses types like `U64` or `U128`)

Normally, the TypeScript SDK will automatically convert simple types in function parameters into BCS in order to communicate with the network. For some contracts though, you will have to use BCS directly to specify complicated types.

Using BCS directly can have a light performance advantage as the SDK can skip an API call to transform the TypeScript primitive parameter format into BCS format.

You can directly use the BCS format to build transactions by specifying argument types explicitly like so:

```typescript filename="example.ts"
const transaction = await aptos.transaction.build.simple({
    sender: alice.accountAddress,
    data: {
      function: "0x1::aptos_account::transfer",
      functionArguments: [AccountAddress.fromString("0x123"), new U64(1_000_000)],
    },
  });
```

You can learn more about BCS by exploring the [BCS GitHub repo](https://github.com/aptos-labs/bcs).

# Multi-Agent Transactions

> Enable multiple accounts to participate in a single transaction with coordinated signatures and shared resources

import { Aside, Steps } from '@astrojs/starlight/components';

Multi-agent transactions allow multiple accounts to participate in the logic of a Move contract.

This can be used to require multiple parties agree to a transaction before executing or to use resources from multiple accounts.

## Writing Multi-Agent Transactions

Creating and executing a multi-agent transaction follows a similar flow to the [simple transaction flow](/build/sdks/ts-sdk/building-transactions), but with several notable differences.

<Aside type="note">
  Instead of `.simple`, multi-agent transaction functions use `.multiAgent`.
</Aside>

<Steps>
  1. Build the transaction by including secondarySignerAddresses with a list of each additional agent.

     <Aside type="note">
       Make sure to replace the `function` field below with your entry function that requires multiple agents to sign.
     </Aside>

     ```typescript filename="multi-agent.ts"
     const transaction = await aptos.transaction.build.multiAgent({
       sender: alice.accountAddress,
       secondarySignerAddresses: [bob.accountAddress],
       data: {
         // REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE
         function:
           "<REPLACE WITH YOUR MULTI AGENT MOVE ENTRY FUNCTION> (Syntax {address}::{module}::{function})",
         // Pass in arguments for the function you specify above
         functionArguments: [],
       },
     });
     ```

  2. (Optional) Simulate the transaction.

     You can simulate the multi-agent transaction to preview the result before submitting it as follows:

     ```typescript filename="multi-agent.ts"
     const [userTransactionResponse] = await aptos.transaction.simulate.multiAgent(
       {
         signerPublicKey: alice.publicKey,
         secondarySignersPublicKeys: [bob.publicKey],
         transaction,
       },
     );
     ```

     The `signerPublicKey` and `secondarySignersPublicKeys` inputs are optional and can be omitted to skip authentication key checks for the signers during simulation. If you want to skip the authentication key check for only some of the secondary signers, you can provide `secondarySignersPublicKeys` with the public keys of the specific signers you want to check, using `undefined` as a placeholder for the others.

     For example, if `bob` and `carol` are secondary signers and you only want to check `carol`s authentication key, you can set `secondarySignersPublicKeys: [undefined, carol.publicKey]`, leaving `undefined` as a placeholder for `bob`.

  3. Sign once for each agent.

     You will combine these signatures in the next step.

     ```typescript filename="multi-agent.ts"
     const aliceSenderAuthenticator = aptos.transaction.sign({
       signer: alice,
       transaction,
     });
     // Bob is a secondary signer for this transaction
     const bobSenderAuthenticator = aptos.transaction.sign({
       signer: bob,
       transaction,
     });
     ```

  4. Submit the transaction by combining all agent signatures via the additionalSignerAuthenticators parameter.

     ```typescript filename="multi-agent.ts"
     const committedTransaction = await aptos.transaction.submit.multiAgent({
       transaction,
       senderAuthenticator: aliceSenderAuthenticator,
       additionalSignersAuthenticators: [bobSenderAuthenticator],
     });
     ```

  5. Lastly, wait for the transaction to resolve.

     ```typescript filename="multi-agent.ts"
     const executedTransaction = await aptos.waitForTransaction({
       transactionHash: committedTransaction.hash,
     });
     ```
</Steps>

## Full TypeScript Multi-Agent Code Snippet

<Aside type="caution">
  The below snippet needs light editing to work properly! (See below steps)
</Aside>

1. Install `@aptos-labs/ts-sdk` by running `pnpm i @aptos-labs/ts-sdk` or using whichever package manager is most comfortable for you.
2. Update the below snippet to build a transaction that requires multi-agent signing.
   1. Replace the function and parameters below this comment: `// REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE`
   2. This customization is needed as there are no pre-made Aptos contracts which need multi-agent signatures. If you want to deploy your own example multi-agent contract, you can deploy the ["transfer two by two" example Move contract](https://github.com/aptos-labs/aptos-ts-sdk/blob/main/tests/move/transfer/sources/script_two_by_two.move#L5).

```typescript filename="multi-agent.ts"
/**
 * This example shows how to use the Aptos SDK to send a transaction.
 */

import { Account, Aptos, AptosConfig, Network } from "@aptos-labs/ts-sdk";

async function example() {
  console.log(
    "This example will create two accounts (Alice and Bob) and send a transaction transfering APT to Bob's account.",
  );

  // 0. Setup the client and test accounts
  const config = new AptosConfig({ network: Network.DEVNET });
  const aptos = new Aptos(config);

  let alice = Account.generate();
  let bob = Account.generate();
  let carol = Account.generate();

  console.log("=== Addresses ===\n");
  console.log(`Alice's address is: ${alice.accountAddress}`);
  console.log(`Bob's address is: ${bob.accountAddress}`);
  console.log(`Carol's address is: ${carol.accountAddress}`);

  console.log("\n=== Funding accounts ===\n");
  await aptos.fundAccount({
    accountAddress: alice.accountAddress,
    amount: 100_000_000,
  });
  await aptos.fundAccount({
    accountAddress: bob.accountAddress,
    amount: 100_000_000,
  });
  await aptos.fundAccount({
    accountAddress: carol.accountAddress,
    amount: 100_000_000,
  });
  console.log("Done funding Alice, Bob, and Carol's accounts.");

  // 1. Build
  console.log("\n=== 1. Building the transaction ===\n");
  const transaction = await aptos.transaction.build.multiAgent({
    sender: alice.accountAddress,
    secondarySignerAddresses: [bob.accountAddress],
    data: {
      // REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE
      function:
        "<REPLACE WITH YOUR MULTI AGENT MOVE ENTRY FUNCTION> (Syntax {address}::{module}::{function})",
      functionArguments: [],
    },
  });
  console.log("Transaction:", transaction);

  // 2. Simulate (Optional)
  console.log("\n === 2. Simulating Response (Optional) === \n");
  const [userTransactionResponse] = await aptos.transaction.simulate.multiAgent(
    {
      signerPublicKey: alice.publicKey,
      secondarySignersPublicKeys: [bob.publicKey],
      transaction,
    },
  );
  console.log(userTransactionResponse);

  // 3. Sign
  console.log("\n=== 3. Signing transaction ===\n");
  const aliceSenderAuthenticator = aptos.transaction.sign({
    signer: alice,
    transaction,
  });
  const bobSenderAuthenticator = aptos.transaction.sign({
    signer: bob,
    transaction,
  });
  console.log(aliceSenderAuthenticator);
  console.log(bobSenderAuthenticator);

  // 4. Submit
  console.log("\n=== 4. Submitting transaction ===\n");
  const committedTransaction = await aptos.transaction.submit.multiAgent({
    transaction,
    senderAuthenticator: aliceSenderAuthenticator,
    additionalSignersAuthenticators: [bobSenderAuthenticator],
  });
  console.log("Submitted transaction hash:", committedTransaction.hash);

  // 5. Wait for results
  console.log("\n=== 5. Waiting for result of transaction ===\n");
  const executedTransaction = await aptos.waitForTransaction({
    transactionHash: committedTransaction.hash,
  });
  console.log(executedTransaction);
}

example();
```

## Common Errors

`NUMBER_OF_SIGNER_ARGUMENTS_MISMATCH` - This happens when you are attempting to do multi-agent signing for a function which does not require that number of accounts. For example, if you try using multiple signatures for a `0x1::aptos_account::transfer` function - it only expects one address, and so produces an error when more than one is provided.

# Orderless Transactions

> Create transactions that can be executed in any order, enabling flexible multi-machine signing scenarios

import { Aside } from '@astrojs/starlight/components';

Orderless transactions allow you to create transactions that do not specify a
order of execution between them. This is particularly useful
in scenarios where multiple machines need to sign a transaction, but the order
in which they sign does not affect the outcome of the transaction or matter to
the creator.

## Building Orderless Transactions

Creating and executing a multi-agent transaction follows a similar flow to the
[simple transaction flow](/build/sdks/ts-sdk/building-transactions), and the
[multi-agent transaction flow](/build/sdks/ts-sdk/building-transactions/multi-agent-transactions).

<Aside type="note">
  Instead of providing a `sequenceNumber` (or no sequence number at all), a
  `Replay Protection Nonce` is used to ensure that the transaction is unique and
  cannot be replayed (i.e., executed multiple times with the same nonce).
</Aside>

For example, to create a single signer transaction that uses orderless transactions,
specify the `nonce` in the `build.simple` method like so:

```typescript filename="build-a-transaction.ts"
const transaction = await aptos.transaction.build.simple({
  sender: sender.accountAddress,
  data: {
	  // All transactions on Aptos are implemented via smart contracts.
	  function: "0x1::aptos_account::transfer",
	  functionArguments: [destination.accountAddress, 100],
  },
  options: {
    replayProtectionNonce: 12345, // This is the nonce that will be used to ensure the transaction is unique.
  }
});
```

Similarly, if you are building a multi-agent transaction, you can specify the
`replayProtectionNonce` in the `build.multiAgent` method:

```typescript filename="build-a-transaction.ts"
const transaction = await aptos.transaction.build.multiAgent({
  sender: sender.accountAddress,
  secondarySignerAddresses: [bob.accountAddress], // List of secondary signers
  data: {
	  // All transactions on Aptos are implemented via smart contracts.
	  function: "0x1::aptos_account::transfer",
	  functionArguments: [destination.accountAddress, 100],
  },
  options: {
    replayProtectionNonce: 12345, // This is the nonce that will be used to ensure the transaction is unique.
  }
});
```

And the same if you are building a sponsored transaction, you can specify the
`replayProtectionNonce` in the `build.multiAgent` method:

```typescript filename="build-a-transaction.ts"
const transaction = await aptos.transaction.build.multiAgent({
  sender: sender.accountAddress,
  withFeePayer: true, // This indicates that the transaction will be sponsored.
  data: {
	  // All transactions on Aptos are implemented via smart contracts.
	  function: "0x1::aptos_account::transfer",
	  functionArguments: [destination.accountAddress, 100],
  },
  options: {
    replayProtectionNonce: 12345, // This is the nonce that will be used to ensure the transaction is unique.
  }
});
```

<Aside type="note">
  For orderless transactions, the `replayProtectionNonce` must be unique for
  each transaction. Additionally, the expiration time of the transaction is
  maximum 60 seconds from the time it is submitted. If the transaction is not
  executed within that time, it will be considered expired and will not be
  executed.
</Aside>

After that, simply follow the same steps as you would for a simple transaction:

1. [**Simulate** the transaction (optional)](/build/sdks/ts-sdk/building-transactions/simulating-transactions).
2. **Sign** the transaction.
3. **Submit** the transaction to the network.
4. **Wait** for the transaction to be executed.

### Examples

- [TS SDK Example](https://github.com/aptos-labs/aptos-ts-sdk/blob/main/examples/typescript/simple_orderless_transfer.ts)

# Invoke chains of Move calls with Dynamic Script Composer

> Build complex transaction payloads that call multiple Move functions dynamically using the Script Composer SDK

import { Aside } from '@astrojs/starlight/components';

<Aside type="tip">
  We are pleased to announce that we now have an independent package for the Script Composer functionality, which can be found in the following repository:

  [https://github.com/aptos-labs/script-composer-sdk](https://github.com/aptos-labs/script-composer-sdk)

  Of course! You can use it as an npm package! Please install this package:

  [https://www.npmjs.com/package/@aptos-labs/script-composer-sdk](https://www.npmjs.com/package/@aptos-labs/script-composer-sdk)
</Aside>

<Aside type="caution">
  If you are still using the Script Composer in the 1.39.0 version of the ts-sdk, you can switch to the independent package version as soon as possible:
  [https://www.npmjs.com/package/@aptos-labs/ts-sdk/v/1.39.0](https://www.npmjs.com/package/@aptos-labs/ts-sdk/v/1.39.0)
</Aside>

## Overview

In the basic API, you can only specify one entry function call for a single transaction. Advanced builders might want to invoke multiple **public** Move functions in one transaction. This is now enabled by the new `scriptComposer` API provided in the transaction builder.

## Basic Usage

Here's an example of how to invoke the API:

> Please note that the current example is only for reference on how to use Script Composer to combine transactions, receive return values from public functions, and pass them to the next function

```typescript filename="example.ts"
const tx = await BuildScriptComposerTransaction({
    // You need to fill in the sender's address here
    sender: singleSignerED25519SenderAccount.accountAddress,
    builder: async (composer) => {
        // Start by withdrawing some Coin
        const coin = await composer.addBatchedCalls({
            function: "0x1::coin::withdraw",
            functionArguments: [CallArgument.newSigner(0), 1],
            typeArguments: ["0x1::aptos_coin::AptosCoin"],
        });

        // Pass the coin value to 0x1::coin::coin_to_fungible_asset to convert the token
        // into a fungible asset
        const fungibleAsset = await composer.addBatchedCalls({
            function: "0x1::coin::coin_to_fungible_asset",
            // coin[0] represents the first return value from the first call you added
            functionArguments: [coin[0]],
            typeArguments: ["0x1::aptos_coin::AptosCoin"],
        });

        // Deposit the fungibleAsset converted from the second call
        await composer.addBatchedCalls({
            function: "0x1::primary_fungible_store::deposit",
            // You need to fill in the sender's address here
            functionArguments: [singleSignerED25519SenderAccount.accountAddress, fungibleAsset[0]],
            typeArguments: [],
        });
        return composer
    },
    // You need to pass Aptos Config here because the combined transaction needs to read on-chain state
    aptosConfig: new AptosConfig({
        network: Network.TESTNET,
    }),
});
```

## Transaction Processing

After combining the transaction, we can use interfaces like sign transaction / simulate transaction / submit transaction from `@aptos-labs/ts-sdk`:

We'll use the simulate transaction interface to show how to use it:

```typescript filename="example.ts"

...

    const aptos = new Aptos(new AptosConfig({
        network: Network.TESTNET,
    }));

    const simulate_result = await aptos.transaction.simulate.simple({
        transaction: tx,
    })
    
    console.log('simulate_result: ', simulate_result)
...

```

## Examples

If you need some practical examples, we have also prepared usage examples for three common environments:

In the examples, you will see a combined transaction and the return value of the simulated transaction (the simulated transaction uses the 0x1 address as the sender. Although it can be simulated successfully by default,
if you want to actually use this feature to initiate a simulated transaction, please replace it with your account address and set up the corresponding network)

1. nodejs: [https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/nodejs](https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/nodejs)
2. nextjs: [https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/nextjs-project](https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/nextjs-project)
3. react: [https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/react-project](https://github.com/aptos-labs/script-composer-sdk/tree/main/examples/react-project)

## Technical Principles

Under the hood, the SDK will invoke a WASM binary to compile the series of Move calls into a `CompiledScript`. This will guarantee that the type and ability safety of Move is still being honored during the construction process. For the SDK users, this means:

1. Ability safety:
   a. If the returned value does not have the Drop ability, the returned value needs to be consumed by subsequent calls.
   b. If the returned value does not have the Copy ability, the returned value can only be passed to subsequent calls once.
2. The caller will need to make sure they pass the right values as arguments to subsequent calls. In the previous example, the `0x1::coin::coin_to_fungible_asset` function will expect an argument of `Coin<AptosCoin>`.

This implements [AIP-102](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-102.md)

# Simulating Transactions

> Preview transaction costs and effects before submission using transaction simulation with the TypeScript SDK

Simulating transactions allows you to preview the cost and effect of submitting a transaction without paying fees.
You can use this to estimate fees, test a transaction, or to check what the output might be.

To simulate a transaction, you must pass in a transaction and which account would be the signer:

```typescript filename="simulate-a-transaction.ts"
import {
    Account,
    Aptos,
    AptosConfig,
    Network,
} from "@aptos-labs/ts-sdk";

async function example() {
    let sender = Account.generate();
    let receiver = Account.generate();

    // 0. Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    await aptos.fundAccount({
        accountAddress: sender.accountAddress,
        amount: 100_000_000,
    });

    // 1. Build the transaction to preview the impact of it
    const transaction = await aptos.transaction.build.simple({
        sender: sender.accountAddress,
        data: {
        // All transactions on Aptos are implemented via smart contracts.
        function: "0x1::aptos_account::transfer",
        functionArguments: [receiver.accountAddress, 100],
        },
    });

    // 2. Simulate to see what would happen if we execute this transaction
    const [userTransactionResponse] = await aptos.transaction.simulate.simple({
        signerPublicKey: sender.publicKey,
        transaction,
    });
    console.log(userTransactionResponse)

    // If the fee looks ok, continue to signing!
    // ...
}

example();
```

This will produce the same output as if the transaction was submitted.

The `signerPublicKey` parameter in `aptos.transaction.simulate.simple` is used to verify the signers authentication key during transaction simulation. This parameter is optional, and simulation will bypass checking the authentication key if omitted. For example below:

```typescript
// 2. Simulate to see what would happen if we execute this transaction, skipping the authentication key check
const [userTransactionResponse] = await aptos.transaction.simulate.simple({
    transaction,
});
```

<details>
  <summary>Example Output</summary>

  ```shellscript filename="Terminal"
  {
    version: '9534925',
    hash: '0xea50b6fbea39ad1ba015d11cda0e7478334669c34830bc3df067a260d680893c',
    state_change_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
    event_root_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
    state_checkpoint_hash: null,
    gas_used: '9',
    success: true,
    vm_status: 'Executed successfully',
    accumulator_root_hash: '0x0000000000000000000000000000000000000000000000000000000000000000',
    changes: [
      {
        address: '0x811d5a94ccb597fa2a4f7872a3c678867cff94130d9378c39304c1354ef54abe',
        state_key_hash: '0x09adecee8779b64d05847488e2dbec6679c0c9e2fe618caf0793472ba3a7e4ab',
        data: [Object],
        type: 'write_resource'
      },
      {
        address: '0x811d5a94ccb597fa2a4f7872a3c678867cff94130d9378c39304c1354ef54abe',
        state_key_hash: '0x0c70ede5412277b81d9f8d99369930ed5d56ad65862e3e878ad22dd5500833d0',
        data: [Object],
        type: 'write_resource'
      },
      {
        address: '0xf40c314051890d16ba0a2ba427e003a83e730956fdeccf6c8eebc893a229ddc1',
        state_key_hash: '0x503f9cffb248036da24e18875f3dce72bb33d1d3ef5cfdbdb2fb3411cd718f4f',
        data: [Object],
        type: 'write_resource'
      },
      {
        state_key_hash: '0x6e4b28d40f98a106a65163530924c0dcb40c1349d3aa915d108b4d6cfc1ddb19',
        handle: '0x1b854694ae746cdbd8d44186ca4929b2b337df21d1c74633be19b2710552fdca',
        key: '0x0619dc29a0aac8fa146714058e8dd6d2d0f3bdf5f6331907bf91f3acd81e6935',
        value: '0x708f579f62cb01000100000000000000',
        data: null,
        type: 'write_table_item'
      }
    ],
    sender: '0x811d5a94ccb597fa2a4f7872a3c678867cff94130d9378c39304c1354ef54abe',
    sequence_number: '0',
    max_gas_amount: '200000',
    gas_unit_price: '100',
    expiration_timestamp_secs: '1718983701',
    payload: {
      function: '0x1::aptos_account::transfer',
      type_arguments: [],
      arguments: [
        '0xf40c314051890d16ba0a2ba427e003a83e730956fdeccf6c8eebc893a229ddc1',
        '100'
      ],
      type: 'entry_function_payload'
    },
    signature: {
      public_key: '0x966b6b9aa8feb58ee1b911235dea1f185b9169de56303d18bb59937066881e44',
      signature: '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
      type: 'ed25519_signature'
    },
    events: [
      {
        guid: [Object],
        sequence_number: '0',
        type: '0x1::coin::CoinWithdraw',
        data: [Object]
      },
      {
        guid: [Object],
        sequence_number: '0',
        type: '0x1::coin::WithdrawEvent',
        data: [Object]
      },
      {
        guid: [Object],
        sequence_number: '0',
        type: '0x1::coin::CoinDeposit',
        data: [Object]
      },
      {
        guid: [Object],
        sequence_number: '1',
        type: '0x1::coin::DepositEvent',
        data: [Object]
      },
      {
        guid: [Object],
        sequence_number: '0',
        type: '0x1::transaction_fee::FeeStatement',
        data: [Object]
      }
    ],
    timestamp: '1718983681460047'
  }
  ```
</details>

Look [here](/build/sdks/ts-sdk/building-transactions) to see the full example of how to build, simulate, and submit a transaction.

# Simulating more advanced Transactions

You can also learn how to simulate more advanced transactions by looking at the following guides:

- [Sponsored Transactions](/build/sdks/ts-sdk/building-transactions/sponsoring-transactions)
- [Multi-Agent Transactions](/build/sdks/ts-sdk/building-transactions/multi-agent-transactions)
- Multisig V2 Transactions: See the next section for details.

## Simulating On-Chain Multisig (v2) Transactions

For multisig transactions, there are two types of simulation:

1. Simulation of the target payload before its submitted on-chain, ignoring the voting status.
2. Simulation of the approved on-chain multisig transaction before execution to verify output and gas estimation.

To perform the first type, you can simulate the target payload as a sponsored transaction with the multisig account as the sender, and set the fee payer to `0x0` to bypass gas fee payment during simulation. For example:

```typescript
// Generate a raw transaction with the multisig address as the sender,
// the provided entry function payload, and 0x0 as the fee payer address.
const transactionToSimulate = await aptos.transaction.build.simple({
  sender: multisigAddress,
  data: {
    function: "0x1::aptos_account::transfer",
    functionArguments: [recipient.accountAddress, 1_000_000],
  },
  withFeePayer: true,
});

// Simulate the transaction, skipping the public/auth key check for both the sender and the fee payer.
const [simulateMultisigTx] = await aptos.transaction.simulate.simple({
  transaction: transactionToSimulate,
});
```

This setup allows you to preview the target payload's result before submitting it on-chain. Here, `signerPublicKey` is omitted to skip the authentication key check for the sender, as the multisig account does not have a public key. Additionally, `feePayerAddress` defaults to `0x0`, and `feePayerPublicKey` is omitted to bypass the gas fee payment during simulation. When this payload is later executed after submission and approval, the owner executing the transaction will cover the gas fee.

For the second type of simulation, where the on-chain multisig payload transaction is simulated for final validation and gas estimation, use the following approach:

```typescript
const transactionPayload: TransactionPayloadMultiSig = await generateTransactionPayload({
  multisigAddress,
  function: "0x1::aptos_account::transfer",
  functionArguments: [recipient.accountAddress, 1_000_000],
  aptosConfig: config,
});

const rawTransaction = await generateRawTransaction({
  aptosConfig: config,
  sender: owner.accountAddress,
  payload: transactionPayload,
});

const [simulateMultisigTx] = await aptos.transaction.simulate.simple({
  signerPublicKey: owner.publicKey,
  transaction: new SimpleTransaction(rawTransaction),
});
```

Note that `signerPublicKey` is optional and can be omitted if you wish to skip the authentication key check for the sender during simulation.

For the complete source code, see the [Multisig V2 Example](https://github.com/aptos-labs/aptos-ts-sdk/blob/main/examples/typescript-esm/multisig_v2.ts).

# Sponsoring Transactions

> Learn how to sponsor transactions on Aptos, allowing one account to pay gas fees for another account's transactions

import { Aside, Steps } from '@astrojs/starlight/components';

Normally, the account that is executing a transaction pays for the gas fees. You can allow another account to cover those charges by sponsoring a transaction.

This can be used to help manage fees from a central account when working with complicated smart contracts.

## How To Sponsor a Transaction

<Steps>
  1. Build the transaction with the parameter withFeePayer: true.

     ```typescript filename="sponsor.ts"
     const transaction = await aptos.transaction.build.simple({
         sender: sender.accountAddress,
         withFeePayer: true,
         data: {
             // All transactions on Aptos are implemented via smart contracts.
             function: "0x1::aptos_account::transfer",
             functionArguments: [destination.accountAddress, 100],
         },
     });
     ```

  2. Sign the transaction with BOTH the sender and the feePayer.

     1. Sign with the sender account using `.sign`.
     2. Sign with the sponsor account using `.signAsFeePayer`.

     <Aside type="caution">
       The sponsor uses a different function (`.signAsFeePayer`) than the sender to sign!
     </Aside>

     ```typescript filename="sponsor.ts"
     const senderAuthenticator = aptos.transaction.sign({
         signer: sender,
         transaction,
     });
     const feePayerAuthenticator = aptos.transaction.signAsFeePayer({
         signer: feePayer,
         transaction
     })
     ```

  3. (Optional) Simulate the sponsoring transaction

     You can simulate the sponsoring transaction to preview the result before submitting it as follows:

     ```typescript filename="sponsor.ts"
     const [userTransactionResponse] = await aptos.transaction.simulate.simple({
         signerPublicKey: sender.publicKey,
         transaction,
     });
     ```

     By default, the `transaction`s `feePayerAddress` is set to `0x0`, which directs the transaction simulation to skip the gas fee payment. This allows you to simulate the transaction without specifying a fee payer. Note that `signerPublicKey` is optional and can be omitted if you want to skip the authentication key check for the sender.

     You can also simulate the transaction with a specific fee payer by setting the `feePayerAddress` in the `transaction` object as follows:

     ```typescript filename="sponsor.ts"
     transaction.feePayerAddress = feePayer.accountAddress;
     const [userTransactionResponse] = await aptos.transaction.simulate.simple({
         signerPublicKey: sender.publicKey,
         feePayerPublicKey: feePayer.publicKey,
         transaction,
     });
     ```

     This setup will verify that `feePayer` has sufficient balance to cover the gas fee for the transaction. Similarly, `feePayerPublicKey` is optional and can be omitted if you wish to bypass the authentication key check for the fee payer.

  4. Submit the transaction by combining both signatures.

     ```typescript filename="sponsor.ts"
     // 4. Submit
     const committedTransaction = await aptos.transaction.submit.simple({
         transaction,
         senderAuthenticator: senderAuthenticator,
         feePayerAuthenticator: feePayerAuthenticator,
     });
     ```

  5. Wait for the transaction to execute.

     ```typescript filename="sponsor.ts"
     // 5. Wait for results
     const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });
     ```
</Steps>

## TypeScript Sponsor Transaction Code Sample

```typescript filename="sponsor.ts"
/**
 * This example shows how to use the Aptos SDK to send a transaction with a sponsor.
 */

import {
    Account,
    Aptos,
    AptosConfig,
    Network,
} from "@aptos-labs/ts-sdk";

async function example() {
    console.log("This example will send a sponsored transaction from Alice to Carol.");

    // 0. Setup the client and test accounts
    const config = new AptosConfig({ network: Network.DEVNET });
    const aptos = new Aptos(config);

    let alice = Account.generate();
    let bob = Account.generate();
    let carol = Account.generate();

    console.log("=== Addresses ===\n");
    console.log(`Alice's address is: ${alice.accountAddress}`);
    console.log(`Bob's address is: ${bob.accountAddress}`);
    console.log(`Carol's address is: ${carol.accountAddress}`);

    console.log("\n=== Funding accounts ===\n");
    await aptos.fundAccount({
        accountAddress: alice.accountAddress,
        amount: 500_000_000,
    });
    await aptos.fundAccount({
        accountAddress: bob.accountAddress,
        amount: 500_000_000,
    });
    await aptos.fundAccount({
        accountAddress: carol.accountAddress,
        amount: 100,
    });
    console.log("Funded the accounts!")

    // 1. Build
    console.log("\n=== 1. Building the transaction ===\n");
    const transaction = await aptos.transaction.build.simple({
        sender: alice.accountAddress,
        withFeePayer: true,
        data: {
            // All transactions on Aptos are implemented via smart contracts.
            function: "0x1::aptos_account::transfer",
            functionArguments: [carol.accountAddress, 100],
        },
    });
    console.log("Built the transaction!")

    // 2. Sign
    console.log("\n=== 2. Signing transaction ===\n");
    const aliceSenderAuthenticator = aptos.transaction.sign({
        signer: alice,
        transaction,
    });
    const bobSenderAuthenticator = aptos.transaction.signAsFeePayer({
        signer: bob,
        transaction
    })
    console.log("Signed the transaction!")

    // 3. Simulate (Optional)
    console.log("\n === 3. Simulating Response (Optional) === \n")
    const [userTransactionResponse] = await aptos.transaction.simulate.simple({
        signerPublicKey: alice.publicKey,
        feePayerPublicKey: bob.publicKey,
        transaction,
    });
    console.log(userTransactionResponse)

    // 4. Submit
    console.log("\n=== 4. Submitting transaction ===\n");
    const committedTransaction = await aptos.transaction.submit.simple({
        transaction,
        senderAuthenticator: aliceSenderAuthenticator,
        feePayerAuthenticator: bobSenderAuthenticator,
    });
    console.log("Submitted transaction hash:", committedTransaction.hash);

    // 5. Wait for results
    console.log("\n=== 5. Waiting for result of transaction ===\n");
    const executedTransaction = await aptos.waitForTransaction({ transactionHash: committedTransaction.hash });
    console.log(executedTransaction)
};

example();
```

## Common Errors

`INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE` :

1. This may be caused by accidentally using `.sign` instead of `.signAsFeePayer` when signing the transaction before submitting on-chain.
2. Sponsoring a transaction requires that the sponsoring account have enough funds to cover the max possible gas fee. This is often orders of magnitude larger than the expected or actual gas fees required for a transaction to execute. In this case, increase the funds in the account above the `max_gas_amount` **multiplied** by the `gas_unit_price` in the simulated transaction. These must be multiplied because gas is unitless, and so must be multiplied by the conversion rate from gas to  [octas](/network/glossary#Octa). You can learn more about gas [here](/network/blockchain/gas-txn-fee).

# Confidential Asset (CA)

> Complete guide to working with confidential assets on Aptos, including ZK-proofs, encryption, transfers, and key rotation

import { Aside } from '@astrojs/starlight/components';

You can use `confidentialCoin` property of `Aptos` client to interact with `CA`

### Initialization

Operations in CA require generating zk-proofs (ZKPs), and depending on your environment, you need to define a `Range Proof` calculation.

For the web, you could use `confidential-asset-wasm-bindings/confidential-asset-wasm-bindings`:

Let's prepare range-proof generation and configure SDK to use it:

```typescript
import initWasm, {
  batch_range_proof as batchRangeProof,
  batch_verify_proof as batchVerifyProof,
  range_proof as rangeProof,
  verify_proof as verifyProof,
} from '@aptos-labs/confidential-asset-wasm-bindings/range-proofs'
import {
  BatchRangeProofInputs,
  BatchVerifyRangeProofInputs,
  RangeProofInputs,
  VerifyRangeProofInputs,
} from '@lukachi/aptos-labs-ts-sdk'

const RANGE_PROOF_WASM_URL =
  'https://unpkg.com/@aptos-labs/confidential-asset-wasm-bindings@0.3.16/range-proofs/aptos_rp_wasm_bg.wasm'

export async function genBatchRangeZKP(
  opts: BatchRangeProofInputs,
): Promise<{ proof: Uint8Array; commitments: Uint8Array[] }> {
  await initWasm({ module_or_path: RANGE_PROOF_WASM_URL })

  const proof = batchRangeProof(
    new BigUint64Array(opts.v),
    opts.rs,
    opts.val_base,
    opts.rand_base,
    opts.num_bits,
  )

  return {
    proof: proof.proof(),
    commitments: proof.comms(),
  }
}

export async function verifyBatchRangeZKP(
  opts: BatchVerifyRangeProofInputs,
): Promise<boolean> {
  await initWasm({ module_or_path: RANGE_PROOF_WASM_URL })

  return batchVerifyProof(
    opts.proof,
    opts.comm,
    opts.val_base,
    opts.rand_base,
    opts.num_bits,
  )
}
```

And then, just place this at the very top of your app:

```typescript
import { RangeProofExecutor } from '@aptos-labs/ts-sdk'

RangeProofExecutor.setGenBatchRangeZKP(genBatchRangeZKP);
RangeProofExecutor.setVerifyBatchRangeZKP(verifyBatchRangeZKP);
RangeProofExecutor.setGenerateRangeZKP(generateRangeZKP);
RangeProofExecutor.setVerifyRangeZKP(verifyRangeZKP);
```

For the native apps:

Generate `android` and `ios` bindings [here](https://github.com/aptos-labs/confidential-asset-wasm-bindings) and integrate in your app as you please.

And the last, but not the least important part:

To get a "numeric" value of the confidential balance, you also need to solve a Discrete Logarithm Problem (DLP).
CA implements the Pollard's Kangaroo method for solving DLPs on the Ristretto curve.
[Source](https://cr.yp.to/dlog/cuberoot-20120919.pdf)

So we also need to initialize a decryption function for that:

```typescript
// Copyright  Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

import initWasm, {
  create_kangaroo,
  WASMKangaroo,
} from '@aptos-labs/confidential-asset-wasm-bindings/pollard-kangaroo'
import {
  ConfidentialAmount,
  TwistedEd25519PrivateKey,
  TwistedElGamal,
  TwistedElGamalCiphertext,
} from '@lukachi/aptos-labs-ts-sdk'
import { bytesToNumberLE } from '@noble/curves/abstract/utils'

const POLLARD_KANGAROO_WASM_URL =
  'https://unpkg.com/@aptos-labs/confidential-asset-wasm-bindings@0.3.15/pollard-kangaroo/aptos_pollard_kangaroo_wasm_bg.wasm'

export async function createKangaroo(secret_size: number) {
  await initWasm({ module_or_path: POLLARD_KANGAROO_WASM_URL })

  return create_kangaroo(secret_size)
}

export const preloadTables = async () => {
  const kangaroo16 = await createKangaroo(16)
  const kangaroo32 = await createKangaroo(32)
  const kangaroo48 = await createKangaroo(48)

  TwistedElGamal.setDecryptionFn(async pk => {
    if (bytesToNumberLE(pk) === 0n) return 0n

    let result = kangaroo16.solve_dlp(pk, 500n)

    if (!result) {
      result = kangaroo32.solve_dlp(pk, 1500n)
    }

    if (!result) {
      result = kangaroo48.solve_dlp(pk)
    }

    if (!result) throw new TypeError('Decryption failed')

    return result
  })
}
```

[//]: # "TODO: update to 16->32->48 usage"

Now, place this at the top of your app:

```typescript
const init = async () => {
  await preloadTables();
}
```

For the native apps, you could generate `android` and `ios` bindings [here](https://github.com/aptos-labs/confidential-asset-wasm-bindings) to use instead of WASM.

***

Now we are ready to go. Let's define Aptos client:

```typescript
const APTOS_NETWORK: Network = NetworkToNetworkName[Network.TESTNET];
const config = new AptosConfig({ network: APTOS_NETWORK });
export const aptos = new Aptos(config);
```

### Create Decryption Key (DK)

To interact with the confidential asset, create a [unique key pair](/build/sdks/ts-sdk/confidential-asset#confidential-asset-store) first.

Generate new:

```typescript
const dk = TwistedEd25519PrivateKey.generate();
```

Or import existed one:

```typescript
const dk = new TwistedEd25519PrivateKey("0x...");
```

Also, you could derive it using your `signature` (for testing purposes, don't use at production):

```typescript
const user = Account.generate()

const signature = user.sign(TwistedEd25519PrivateKey.decryptionKeyDerivationMessage);

const dk = TwistedEd25519PrivateKey.fromSignature(signature);
```

Or use [`pepper`](/build/guides/aptos-keyless/how-keyless-works) from [Keyless Account](/build/guides/aptos-keyless)

### Register

Next, you need to [register](/build/sdks/ts-sdk/confidential-asset#register) a previously generated encryption key (EK) in contracts:

```typescript
export const registerConfidentialBalance = async (
  account: Account,
  publicKeyHex: string,
  tokenAddress = "0x...",
) => {
  const txBody = await aptos.confidentialAsset.deposit({
    sender: account.accountAddress,
    to: AccountAddress.from(to),
    tokenAddress: tokenAddress,
    amount: amount,
  })

  const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: userRegisterCBTxBody });

  const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });

  return txReceipt;
}
```

Check if a user has already registered a specific token:

```typescript
export const getIsAccountRegisteredWithToken = async (
  account: Account,
  tokenAddress = "0x...",
) => {
  const isRegistered = await aptos.confidentialAsset.hasUserRegistered({
    accountAddress: account.accountAddress,
    tokenAddress: tokenAddress,
  })

  return isRegistered
}
```

### Deposit

Let's say you already have tokens.

This will deposit them to your confidential balance

```typescript
export const depositConfidentialBalance = async (
  account: Account,
  amount: bigint,
  to: string,
  tokenAddress = "0x...",
) => {
  const txBody = await aptos.confidentialAsset.deposit({
    sender: account.accountAddress,
    to: AccountAddress.from(to),
    tokenAddress: tokenAddress,
    amount: amount,
  })
  // Sign and send transaction
}
```

### Get user's balance

Let's check the user's balance after the deposit.

```typescript
const userConfidentialBalance = await aptos.confidentialAsset.getBalance({ accountAddress: user.accountAddress, tokenAddress: TOKEN_ADDRESS });
```

This method returns you the user's [`pending` and `actual`](/build/sdks/ts-sdk/confidential-asset#confidential-asset-store) confidential balances, and to [decrypt](/build/sdks/ts-sdk/confidential-asset#encryption-and-decryption) them, you can use `ConfidentialAmount` class

```typescript
export const getConfidentialBalances = async (
  account: Account,
  decryptionKeyHex: string,
  tokenAddress = "0x...",
) => {
  const decryptionKey = new TwistedEd25519PrivateKey(decryptionKeyHex)

  const { pending, actual } = await aptos.confidentialAsset.getBalance({
    accountAddress: account.accountAddress,
    tokenAddress,
  })

  try {
    const [confidentialAmountPending, confidentialAmountActual] =
      await Promise.all([
        ConfidentialAmount.fromEncrypted(pending, decryptionKey),
        ConfidentialAmount.fromEncrypted(actual, decryptionKey),
      ])

    return {
      pending: confidentialAmountPending,
      actual: confidentialAmountActual,
    }
  } catch (error) {
    return {
      pending: ConfidentialAmount.fromAmount(0n),
      actual: ConfidentialAmount.fromAmount(0n),
    }
  }
}
```

### Rollover

After you deposited to user's confidential balance, you can see, that he has, for instance `5n` at his `pending` balance, and `0n` at his `actual` balance.

User can't operate with `pending` balance, so you could [rollover](/build/sdks/ts-sdk/confidential-asset#rollover-pending-balance) it to `actual` one.

And to do so - use `aptos.confidentialAsset.rolloverPendingBalance`.

<Aside type="caution">
  Important note, that user's actual balance need to be [normalized](/build/sdks/ts-sdk/confidential-asset#normalize) before `rollover` operation.
</Aside>

To cover [normalization](#normalization) & `rollover` simultaneously, you could use `aptos.confidentialAsset.safeRolloverPendingCB`.

```typescript
export const safelyRolloverConfidentialBalance = async (
  account: Account,
  decryptionKeyHex: string,
  tokenAddress = "0x...",
) => {
  const rolloverTxPayloads = await aptos.confidentialAsset.safeRolloverPendingCB({
    sender: account.accountAddress,
    tokenAddress,
    decryptionKey: new TwistedEd25519PrivateKey(decryptionKeyHex),
  })

  // Sign and send batch txs
}
```

***

### Normalization

Usually you don't need to explicitly call [normalization](/build/sdks/ts-sdk/confidential-asset#normalize)

In case you want to:

<Aside type="caution">
  Firstly, check a confidential balance is normalized, because trying to normalize an already normalized balance will return you an exception
</Aside>

```typescript
export const getIsBalanceNormalized = async (
  account: Account,
  tokenAddress = "0x...",
) => {
  const isNormalized = await aptos.confidentialAsset.isUserBalanceNormalized({
    accountAddress: account.accountAddress,
    tokenAddress: tokenAddress,
  })

  return isNormalized
}
```

Get your balance and finally call the `aptos.confidentialAsset.normalizeUserBalance` method:

```typescript
export const normalizeConfidentialBalance = async (
  account: Account,
  decryptionKeyHex: string,
  encryptedPendingBalance: TwistedElGamalCiphertext[],
  amount: bigint,
  tokenAddress = "0x...",
) => {
  const normalizeTx = await aptos.confidentialAsset.normalizeUserBalance({
    tokenAddress,
    decryptionKey: new TwistedEd25519PrivateKey(decryptionKeyHex),
    unnormalizedEncryptedBalance: encryptedPendingBalance,
    balanceAmount: amount,

    sender: account.accountAddress,
  })

  // Sign and send transaction
}
```

### Withdraw

To [withdraw](/build/sdks/ts-sdk/confidential-asset#withdraw) your assets out from confidential balance:

```typescript
export const withdrawConfidentialBalance = async (
  account: Account,
  receiver: string,
  decryptionKeyHex: string,
  withdrawAmount: bigint,
  encryptedActualBalance: TwistedElGamalCiphertext[],
  tokenAddress = '0x...',
) => {
  const withdrawTx = await aptos.confidentialAsset.withdraw({
    sender: account.accountAddress,
    to: receiver,
    tokenAddress,
    decryptionKey: decryptionKey,
    encryptedActualBalance,
    amountToWithdraw: withdrawAmount,
  })

  // Sign and send transaction
}
```

### Transfer

For [transfer](/build/sdks/ts-sdk/confidential-asset#confidential-transfer) you need to know the recipient's encryption key and `aptos` account address

Let's say you have a recipient's account address, let's get their encryption key.

```typescript
export const getEkByAddr = async (addrHex: string, tokenAddress: string) => {
  return aptos.confidentialAsset.getEncryptionByAddr({
    accountAddress: AccountAddress.from(addrHex),
    tokenAddress,
  })
}
```

Now, wrap it all together and transfer:

```typescript
export const transferConfidentialCoin = async (
  account: Account,
  decryptionKeyHex: string,
  encryptedActualBalance: TwistedElGamalCiphertext[],
  amountToTransfer: bigint,
  recipientAddressHex: string,
  auditorsEncryptionKeyHexList: string[],
  tokenAddress = "0x...",
) => {
  const decryptionKey = new TwistedEd25519PrivateKey(decryptionKeyHex)

  const recipientEncryptionKeyHex = await getEkByAddr(
    recipientAddressHex,
    tokenAddress,
  )

  const transferTx = await aptos.confidentialAsset.transferCoin({
    senderDecryptionKey: decryptionKey,
    recipientEncryptionKey: new TwistedEd25519PublicKey(
      recipientEncryptionKeyHex,
    ),
    encryptedActualBalance: encryptedActualBalance,
    amountToTransfer,
    sender: account.accountAddress,
    tokenAddress,
    recipientAddress: recipientAddressHex,
    auditorEncryptionKeys: auditorsEncryptionKeyHexList.map(
      hex => new TwistedEd25519PublicKey(hex),
    ),
  })

  // Sign and send transaction
}
```

### Key Rotation

To do [key rotation](/build/sdks/ts-sdk/confidential-asset#rotate-encryption-key), you need to create a new decryption key and use `aptos.confidentialAsset.rotateCBKey`

<Aside type="caution">
  But keep in mind, that `key-rotation` checks that pending balance equals 0.
  In that case, we could do a `rollover` with `freeze` option, to move assets from the pending balance to the actual one and lock our balance.

  ```typescript
  aptos.confidentialAsset.safeRolloverPendingCB({
    ...,
    withFreezeBalance: false,
  })
  ```
</Aside>

Now let's create a new decryption key and rotate our encryption key:

```typescript
const balances = await getBalances(user.accountAddress.toString(), myDecryptionKey, TOKEN_ADDRESS);

const NEW_DECRYPTION_KEY = TwistedEd25519PrivateKey.generate();
const keyRotationAndUnfreezeTxResponse = await ConfidentialCoin.safeRotateCBKey(aptos, user, {
  sender: user.accountAddress,

  currDecryptionKey: currentDecryptionKey,
  newDecryptionKey: NEW_DECRYPTION_KEY,

  currEncryptedBalance: balances.actual.amountEncrypted,

  withUnfreezeBalance: true, // if you want to unfreeze balance after
  tokenAddress: TOKEN_ADDRESS,
});

// save: new decryption key
console.log(NEW_DECRYPTION_KEY.toString());

// check new balances
const newBalance = await getBalances(user.accountAddress.toString(), NEW_DECRYPTION_KEY, TOKEN_ADDRESS);

console.log(newBalance.pending.amount);
console.log(newBalance.actual.amount);
```

# Fetch Data via SDK

> Learn how to retrieve on-chain data, query the Indexer API, and use view functions with the Aptos TypeScript SDK

import { Aside } from '@astrojs/starlight/components';

You can use the `Aptos` client to get on-chain data using a variety of helper functions. Specifically, many of the functions listed in the reference docs [here](https://aptos-labs.github.io/aptos-ts-sdk/@aptos-labs/ts-sdk-1.35.0/classes/Aptos.html) that start with `get...` will retrieve data from on-chain.

Heres an example showing how to fetch common data you may need in your application:

```typescript filename="fetch-data.ts"
const aptosConfig = new AptosConfig({ network: Network.DEVNET });
const aptos = new Aptos(aptosConfig);

const fund = await aptos.getAccountInfo({ accountAddress: "0x123" });
const modules = await aptos.getAccountModules({ accountAddress: "0x123" });
const tokens = await aptos.getAccountOwnedTokens({ accountAddress: "0x123" });
```

<Aside type="note">
  Many queries have a parameter named `options` to customize the results, use it to get specifically what you are looking for.
</Aside>

The `Aptos` client can out of the box query both network data from [fullnodes](https://api.mainnet.aptoslabs.com/v1/spec#/) and the [Indexer](https://cloud.hasura.io/public/graphiql?endpoint=https://api.mainnet.aptoslabs.com/v1/graphql) API which contains aggregated and enriched data. If you want to use a custom query for Indexer API data, you can use `aptos.queryIndexer` like so:

```typescript filename="fetch-data.ts"
  const ledgerInfo = await aptos.queryIndexer({
    query: {
      query: `
        query MyQuery {
          ledger_infos {
            chain_id
          }
        }
      `
    }
  })
```

## Using Generic Queries

Some queries are intentionally broad, but this can make inferring the proper return type difficult. To accommodate that, these broad requests like `getAccountResources` allow you to specify what the expected response type should be.

```typescript filename="fetch-data.ts"
type Coin = { coin: { value: string } };

const resource = await aptos.getAccountResource<Coin>({
  accountAddress: testAccount.accountAddress,
  resourceType: "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>",
});

// Now you have access to the response type property
const value = resource.coin.value;
```

## Using Move View Functions

You can call view functions which return custom data from on-chain by using `aptos.view`.

For example, you can look up the network you are using with the `chain_id` view function:

```typescript filename="fetch-data.ts"
const payload: InputViewFunctionData = {
  function: "0x1::chain_id::get",
};

const chainId = (await aptos.view({ payload }))[0];
```

## Ensuring Fresh Indexer Data

Behind the scenes, some requests use the [Indexer API](/build/indexer) to access data which has been processed or aggregated. That extra parsing can take a bit of time, so the data may lag slightly behind the latest ledger.

If you want to ensure that the data is fresh, you can specify the `minimumLedgerVersion` in any request which uses the Indexer API.

```typescript filename="fetch-data.ts"
// Get the latest ledger version number
const ledgerVersion = await aptos.getLedgerInfo().ledger_version;

const tokens = await aptos.getAccountOwnedTokens({
  accountAddress: alice.accountAddress,
  minimumLedgerVersion: BigInt(response.version),
});
```

You can also ensure that your request has the data from a transaction you submitted by getting the ledger version from the transaction validation itself.

```typescript filename="fetch-data.ts"
// Wait for a transaction you just submitted
const response = await aptos.waitForTransaction({
  transactionHash: pendingTransaction.hash,
});

// Then look up how that transaction affected alice's account
const tokens = await aptos.getAccountOwnedTokens({
  accountAddress: alice.accountAddress,
  minimumLedgerVersion: BigInt(response.version),
});
```

# Legacy TypeScript SDK

> Information about the deprecated TypeScript SDK package and migration instructions to the new SDK

import { Aside } from '@astrojs/starlight/components';

<Aside emoji="" type="danger">
  The Legacy TypeScript SDK package `aptos` is deprecated and will be replaced by the new TypeScript SDK. Please refer to the [new TypeScript SDK](/build/sdks/ts-sdk) for the latest features and updates.  Take a look at the [migration guide](/build/sdks/ts-sdk/legacy-ts-sdk/migration-guide).
</Aside>

# Migration Guide

> Complete guide for migrating from the legacy TypeScript SDK (v1.x.x) to the new @aptos-labs/ts-sdk package

import { Aside } from '@astrojs/starlight/components';

<Aside emoji="" type="danger">
  The Legacy TypeScript SDK package `aptos` is deprecated and will be replaced by the new TypeScript SDK. Please refer to the [new TypeScript SDK](/build/sdks/ts-sdk) for the latest features and updates.
</Aside>

If you are coming from an earlier version `1.x.x` of `aptos`, you will need to make the following updates.

<Aside type="note">
  This guide only contains API differences and updates required for deprecated features. New features of the v2 SDK are not included.
</Aside>

## Install the SDK

The TypeScript SDK V2 is under a new [GitHub repo](https://github.com/aptos-labs/aptos-ts-sdk) and with a new package name - `@aptos-labs/ts-sdk`

```shellscript npm2yarn
npm i @aptos-labs/ts-sdk
```

## SDK usage and query the Aptos chain

Remove all `<*>Client` modules (i.e `AptosClient`, `FaucetClient`, `CoinClient`, etc.) and replace with an `Aptos` entry point class

**V1**

```typescript filename="v1.ts"
const faucetClient = new FaucetClient(NODE_URL, FAUCET_URL);
const aptosClient = new AptosClient(NODE_URL);
const indexerClient = new IndexerClient(INDEXER_URL);
const tokenClient = new TokenClient(aptosClient);
```

**V2**

<Aside type="note">
  Read more about it [here](/build/sdks/ts-sdk).
</Aside>

```typescript filename="v2.ts"
const aptos = new Aptos();

// make queries
const fund = await aptos.fundAccount({ accountAddress: "0x123", amount: 100 });
const modules = await aptos.getAccountModules({ accountAddress: "0x123" });
const tokens = await aptos.getAccountOwnedTokens({ accountAddress: "0x123" });
```

## Configuration class

To configure your `Aptos` client, you can use an `AptosConfig` object.

```typescript filename="v2.ts"
const aptosConfig = new AptosConfig({ network: Network.DEVNET }); // default to devnet
const aptos = new Aptos(config);
```

## Transaction Builder Flow

Removed all separate transaction functions in favor of a more simplified and friendlier transaction builder flow

**V1**

```typescript filename="v1.ts"
const aptosClient = new AptosClient(NODE_URL);

// bcs serialized arguments payload
const entryFunctionPayload =
  new TxnBuilderTypes.TransactionPayloadEntryFunction(
    TxnBuilderTypes.EntryFunction.natural(
      "0x1::aptos_account",
      "transfer",
      [],
      [bcsToBytes(TxnBuilderTypes.AccountAddress.fromHex(receiver.address()))],
    ),
  );
// generate a raw transaction
const transaction = await client.generateRawTransaction(
  sender.address(),
  entryFunctionPayload,
);

// non-serialized arguments payload
const payload: Gen.TransactionPayload = {
  type: "entry_function_payload",
  function: "0x1::aptos_account::transfer",
  type_arguments: [],
  arguments: [account2.address().hex(), 100000],
};
// generate a raw transaction
const transaction = await client.generateTransaction(
  account1.address(),
  payload,
);

// sign transaction
const signedTransaction = AptosClient.generateBCSTransaction(
  sender,
  transaction,
);
// submit transaction
const txn = await client.submitSignedBCSTransaction(signedTransaction);
```

**V2**

<Aside type="note">
  Read more about it [here](/build/sdks/ts-sdk/building-transactions).
</Aside>

```typescript filename="v2.ts"
const aptos = new Aptos();

// non-serialized arguments transaction
const transaction = await aptos.build.transaction({
  sender: alice.accountAddress,
  data: {
    function: "0x1::coin::transfer",
    typeArguments: ["0x1::aptos_coin::AptosCoin"],
    functionArguments: [bobAddress, 100],
  },
});

// bcs serialized arguments transaction
const transaction = await aptos.build.transaction({
  sender: alice.accountAddress,
  data: {
    function: "0x1::coin::transfer",
    typeArguments: [parseTypeTag("0x1::aptos_coin::AptosCoin")],
    functionArguments: [bobAddress, new U64(100)],
  },
});
// sign transaction
const senderAuthenticator = aptos.sign.transaction({
  signer: alice,
  transaction,
});
// submit transaction
const committedTransaction = await aptos.submit.transaction({
  transaction,
  senderAuthenticator,
});
```

## Account

Rename `AptosAccount` to `Account` and use static methods to generate / derive an account

**V1**

```typescript filename="v1.ts"
// generate a new account (or key pair) OR derive from private key OR derive from private key and address
const account = new AptosAccount(); // supports only Legacy Ed25519

// derive account from derivation path
const account = AptosAccount.fromDerivePath(..)
```

**V2**

<Aside type="note">
  Read more about it [here](/build/sdks/ts-sdk/account).
</Aside>

```typescript filename="v2.ts"
// generate a new account (or key pair)
const account = Account.generate(); // defaults to Legacy Ed25519
const account = Account.generate({ scheme: SigningSchemeInput.Secp256k1Ecdsa }); // Single Sender Secp256k1
const account = Account.generate({
  scheme: SigningSchemeInput.Ed25519,
  legacy: false,
}); // Single Sender Ed25519

// derive account from private key
const account = Account.fromPrivateKey({ privateKey });

// derive account from private key and address
const account = Account.fromPrivateKeyAndAddress({
  privateKey,
  address: accountAddress,
});

// derive account from derivation path
const account = Account.fromDerivationPath({
  path,
  mnemonic,
  scheme: SigningSchemeInput.Ed25519,
});
```

